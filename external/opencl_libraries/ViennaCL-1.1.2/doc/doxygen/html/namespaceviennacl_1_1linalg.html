<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>viennacl::linalg Namespace Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">kernels</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">no_precond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for the stabilized Bi-conjugate gradient solver. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1bicgstab__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for the conjugate gradient Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1cg__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for the solver GMRES. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1gmres__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for incomplete LU factorization with threshold (ILUT).  <a href="classviennacl_1_1linalg_1_1ilut__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond.html">ilut_precond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">ilut_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__tag.html">jacobi_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for a jacobi preconditioner.  <a href="classviennacl_1_1linalg_1_1jacobi__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__precond.html">jacobi_precond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1jacobi__precond.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1jacobi__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">jacobi_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1jacobi__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling__tag.html">row_scaling_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for a row preconditioner.  <a href="classviennacl_1_1linalg_1_1row__scaling__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling.html">row_scaling</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1row__scaling.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1row__scaling_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">row_scaling&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1row__scaling_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2479f0743a32118e916cca8edb895c30">norm_1_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the l^1-norm of a vector.  <a href="#a2479f0743a32118e916cca8edb895c30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a96a2ee028641ffd7b80e6a1bfad34c6a">norm_2_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the l^2-norm of a vector - implementation.  <a href="#a96a2ee028641ffd7b80e6a1bfad34c6a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a43009c5365c78c81463f54c2848378ca">norm_inf_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#a43009c5365c78c81463f54c2848378ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, F, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5e71c3317fe25d0ce5e31be66597d8bb">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication.  <a href="#a5e71c3317fe25d0ce5e31be66597d8bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa965a1bc156b037f57b6a449dde4c7d1">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#aa965a1bc156b037f57b6a449dde4c7d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a79ec888c8ac1026f4591179fdd19e0de">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a79ec888c8ac1026f4591179fdd19e0de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT1, unsigned int ALIGNMENT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT1 &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT2 &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a23fbff833bbc632131b761e732bce72b">inner_prod_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the inner product of two vectors.  <a href="#a23fbff833bbc632131b761e732bce72b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afc191e1a26f0c0037e320a3b7dc831cc">inner_prod_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#afc191e1a26f0c0037e320a3b7dc831cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the stabilized Bi-conjugate gradient solver.  <a href="#ab50f87d195eb82ddbe5ce910e914bc55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7eb0bd2b912aa3c5d83aa4801e7e89fd">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, <a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adbcb7f6a46ca520d01f6ce53f83f5069">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the preconditioned stabilized Bi-conjugate gradient solver.  <a href="#adbcb7f6a46ca520d01f6ce53f83f5069"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6bc45bf37430c67d6a32ed8e10e77e94">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the conjugate gradient solver without preconditioner.  <a href="#a6bc45bf37430c67d6a32ed8e10e77e94"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a560520300c350a1d8afa44d5c036b48b">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, <a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adefd0a97aaeaa8eb75097847443c6ee1">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the preconditioned conjugate gradient solver.  <a href="#adefd0a97aaeaa8eb75097847443c6ee1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a469b22e14078bba1451afb09bbd2f7cc">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, size_t NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a469b22e14078bba1451afb09bbd2f7cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#ae927d6abe755d74744ec5ee9bd191210"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6d7d0a974cd68a51c4d5c4b7a16c1d28">solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, const <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#a6d7d0a974cd68a51c4d5c4b7a16c1d28"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa3a114636b1b542dfb42f48d2a0200a">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#aaa3a114636b1b542dfb42f48d2a0200a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa338acd99f7bfac8c0210ab05ecaa09">solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#aaa338acd99f7bfac8c0210ab05ecaa09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7984796b04f748d616d1071b0e70850b">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, size_t NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#a7984796b04f748d616d1071b0e70850b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afa56b176c5b19331a2fd286cac2f9c92">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#afa56b176c5b19331a2fd286cac2f9c92"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int A1, unsigned int A2, typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a18293ef61ad46907177e280d4b1d680a">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, A1 &gt; &amp;mat, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, A2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems.  <a href="#a18293ef61ad46907177e280d4b1d680a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int A1, unsigned int A2, typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0ec9d2642d98a204f1de4fdad9063c14">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, A1 &gt; &amp;mat, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, A2 &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, A2 &gt;, op_trans &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems.  <a href="#a0ec9d2642d98a204f1de4fdad9063c14"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int A1, unsigned int A2, typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad849b3114b76777bb0162ddf3fe8eba2">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, A1 &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, A1 &gt;, op_trans &gt; &amp;proxy, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, A2 &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#ad849b3114b76777bb0162ddf3fe8eba2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int A1, unsigned int A2, typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aae8acccfb7520c1c75d8bbb10130aa4a">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, A1 &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, A1 &gt;, op_trans &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, A2 &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, A2 &gt;, op_trans &gt; &amp;B, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#aae8acccfb7520c1c75d8bbb10130aa4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT, typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1fa59efa7e0a65e6e9c949b441696af1">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT, typename SOLVERTAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a373c29fa2cb02177b1450d36eabeb265">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, SOLVERTAG)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#a373c29fa2cb02177b1450d36eabeb265"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int ALIGNMENT_A, unsigned int ALIGNMENT_B, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, <br class="typebreak"/>
ALIGNMENT_B &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a658f2de0ab6804ebabbc4248adc2d927">solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for C = solve(A, B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#a658f2de0ab6804ebabbc4248adc2d927"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int ALIGNMENT_A, unsigned int ALIGNMENT_B, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, <br class="typebreak"/>
ALIGNMENT_B &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a13d7be38f0fbef200ccbe90d9240e542">solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, op_trans &gt; &amp;proxy, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for C = solve(A, B^T, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#a13d7be38f0fbef200ccbe90d9240e542"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9f5cb80858484131ecb73e867b2bf794">solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(mat, vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#a9f5cb80858484131ecb73e867b2bf794"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int ALIGNMENT_A, unsigned int ALIGNMENT_B, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, <br class="typebreak"/>
ALIGNMENT_B &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aec73c039978029c091e70224bf283ed5">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, op_trans &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#aec73c039978029c091e70224bf283ed5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int ALIGNMENT_A, unsigned int ALIGNMENT_B, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, <br class="typebreak"/>
ALIGNMENT_B &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a18da6b35b9790a1acd824dee6a8fb76a">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, op_trans &gt; &amp;proxy_A, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, op_trans &gt; &amp;proxy_B, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#a18da6b35b9790a1acd824dee6a8fb76a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#add76ce64e200f9193156a98a15bf42fd">solve</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>.  <a href="#add76ce64e200f9193156a98a15bf42fd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2aa3e7727b42bd95f5d1e5dd5366f807">lu_factorize</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU factorization of a dense matrix.  <a href="#a2aa3e7727b42bd95f5d1e5dd5366f807"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F1 , typename F2 , unsigned int ALIGNMENT_A, unsigned int ALIGNMENT_B&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1407e42bdce9d821baaf5d4163a09dd1">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; const &amp;A, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a1407e42bdce9d821baaf5d4163a09dd1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9da85acf3d7f22c869dfd52791a25d55">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a9da85acf3d7f22c869dfd52791a25d55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76b4d001b76edd2253dc7d3a2852b391">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the GMRES solver.  <a href="#a76b4d001b76edd2253dc7d3a2852b391"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad590c4eadb76eea1a806c3c4c026ba66">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload of the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function using GMRES. Per default, no preconditioner is used.  <a href="#ad590c4eadb76eea1a806c3c4c026ba66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad81c044903c3d571c5fa1354e94ce817">ilut_inc_row_iterator_to_row_index</a> (T &amp;row_iter, unsigned int k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments a row iterator (iteration along increasing row indices) up to a certain row index k.  <a href="#ad81c044903c3d571c5fa1354e94ce817"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8564080fc80b938370442ac4b9ba748f">ilut_inc_row_iterator_to_row_index</a> (<a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html">viennacl::tools::sparse_matrix_adapter</a>&lt; ScalarType &gt; &amp;row_iter, unsigned int k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments a row iterator (iteration along increasing row indices) up to a certain row index k.  <a href="#a8564080fc80b938370442ac4b9ba748f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a85b825153bda885996e0e2986854ab77">ilut_inc_row_iterator_to_row_index</a> (<a class="el" href="classviennacl_1_1tools_1_1const__sparse__matrix__adapter.html">viennacl::tools::const_sparse_matrix_adapter</a>&lt; ScalarType &gt; &amp;row_iter, unsigned int k)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments a row iterator (iteration along increasing row indices) up to a certain row index k.  <a href="#a85b825153bda885996e0e2986854ab77"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename LUType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa1642cbf74be37d2ae455606506dc578">precondition</a> (MatrixType const &amp;input, LUType &amp;output, <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of a ILU-preconditioner with threshold.  <a href="#aa1642cbf74be37d2ae455606506dc578"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab0726586b403c9538056414240f973eb">ilu_inplace_solve</a> (MatrixType const &amp;mat, VectorType &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic inplace solution of a unit lower triangular system.  <a href="#ab0726586b403c9538056414240f973eb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8160c457245b80c37acc7f3cfcc81a8f">ilu_inplace_solve</a> (MatrixType const &amp;mat, VectorType &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic inplace solution of a upper triangular system.  <a href="#a8160c457245b80c37acc7f3cfcc81a8f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#afe44b3505a4625dad0b551e648f3aff0">ilu_lu_substitute</a> (MatrixType const &amp;mat, VectorType &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic LU substitution.  <a href="#afe44b3505a4625dad0b551e648f3aff0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorT1 , typename VectorT2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT1::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae45d23e88210e06b69cd9fdc871f3dc9">inner_prod</a> (VectorT1 const &amp;v1, VectorT2 const &amp;v2, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT1 &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment1, unsigned int alignment2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment1 &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment2 &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">inner_prod</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment2 &gt; const &amp;vector2, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2777d6a19ce110ae9df6609f1677be0f">add</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat1, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds two dense matrices and writes the result to a third matrix.  <a href="#a2777d6a19ce110ae9df6609f1677be0f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a225d1c31fb7c1dac9f5b94f17ae1f950">inplace_add</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;result, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a dense matrix to another.  <a href="#a225d1c31fb7c1dac9f5b94f17ae1f950"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a707ace72b7ff8ad1e3a9ff2606567f1e">sub</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat1, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds two dense matrices and writes the result to a third matrix.  <a href="#a707ace72b7ff8ad1e3a9ff2606567f1e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae88903a9ae8dbc3fc47db7f37da326a6">inplace_sub</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;result, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a dense matrix to another.  <a href="#ae88903a9ae8dbc3fc47db7f37da326a6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0e4c7521b309670969d542805ac87b35">inplace_mult</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;result, SCALARTYPE val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a dense matrix by a scalar.  <a href="#a0e4c7521b309670969d542805ac87b35"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4501136a87a9d6294c210628ffcb23d0">inplace_mult</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;result, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; SCALARTYPE &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a dense matrix by a scalar.  <a href="#a4501136a87a9d6294c210628ffcb23d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e86b6169a6ff7495734d3eef5d4fd33">inplace_divide</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;result, <a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; SCALARTYPE &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies a dense matrix by a scalar.  <a href="#a6e86b6169a6ff7495734d3eef5d4fd33"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abbc7f86d9d7e24ff1eae02fe976bc77d">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#abbc7f86d9d7e24ff1eae02fe976bc77d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, <br class="typebreak"/>
ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, F, ALIGNMENT &gt;<br class="typebreak"/>
, op_trans &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
VECTOR_ALIGNMENT &gt;, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4f088d9329b8c801492830a519fdef15">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a transposed matrix.  <a href="#a4f088d9329b8c801492830a519fdef15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#af8a3b3e7b5421283ccdc96c07ce3c624">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwraps the transposed matrix proxy and forwards to <a class="el" href="namespaceviennacl_1_1linalg.html#a0c03a1482aebb921ce45f3b1c933697c" title="Carries out matrix-vector multiplication with a transposed matrix.">trans_prod_impl()</a>.  <a href="#af8a3b3e7b5421283ccdc96c07ce3c624"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0c03a1482aebb921ce45f3b1c933697c">trans_prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#a0c03a1482aebb921ce45f3b1c933697c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F1 , typename F2 , typename F3 , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1294bf672bcc55c62d1622b07b44425e">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F1, ALIGNMENT &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F2, ALIGNMENT &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;C, int block_size=15)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a1294bf672bcc55c62d1622b07b44425e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F1 , typename F2 , typename F3 , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa03a4515a4033a22afc6f2e9bfad1ed6">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F1, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F1, ALIGNMENT &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F2, ALIGNMENT &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#aa03a4515a4033a22afc6f2e9bfad1ed6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F1 , typename F2 , typename F3 , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a07e0985a7c2429067b483238d0ffeb2a">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F1, ALIGNMENT &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F2, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F2, ALIGNMENT &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a07e0985a7c2429067b483238d0ffeb2a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F1 , typename F2 , typename F3 , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a21163d892b2568fa4fa3abe750a5504f">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F1, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F1, ALIGNMENT &gt;, op_trans &gt; &amp;A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F2, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; TYPE, F2, ALIGNMENT &gt;, op_trans &gt; &amp;B, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;C)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-matrix multiplication.  <a href="#a21163d892b2568fa4fa3abe750a5504f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int VA1, unsigned int VA2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VA1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
VA2 &gt;, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1b56d764864ae3d91bb6bac2ae87bec8">outer_prod</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA1 &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA2 &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update.  <a href="#a1b56d764864ae3d91bb6bac2ae87bec8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a90c6aa1f54abd466421ea06bf9b49716">rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The implementation of the operation mat += vec1 * vec2^T, i.e. a rank 1 update.  <a href="#a90c6aa1f54abd466421ea06bf9b49716"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a46f8f468d8d1d6deec2a4d906f987e85">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, SCALARTYPE val, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#a46f8f468d8d1d6deec2a4d906f987e85"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab37ecf5aa97762b3e174b862912f510a">norm_1</a> (VectorT const &amp;v1, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac5e7e99c21b05b4db0e9422d9c9ed181">norm_1</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a87acc0739e4f1bc63934e9ad24f35a9a">norm_2</a> (VectorT const &amp;v1, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a12a0a2106e96f8f1625b6c5bdec90f4c">norm_2</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;v, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a03a5b5434ce08fac52aa22dbb684029c">norm_inf</a> (VectorT const &amp;v1, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_inf &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aadc500239f2e1967e584b71171cba268">norm_inf</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;v1, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename A1 , typename A2 , typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a07b1f6f849c9950dd557bbf3e38f569d">prod_impl</a> (std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename KEY , typename DATA , typename COMPARE , typename AMAP , typename AVEC , typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8bb2b3cdaa265974abb81154593357b3">prod_impl</a> (std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorT&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae1687a9eb40c623b00c880cd88f176d7">prod</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const MatrixT, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT, <br class="typebreak"/>
ALIGNMENT &gt;, viennacl::op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abe959c83610141222955cfa6c52ed961">prod</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT, ALIGNMENT &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const MatrixT, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, <br class="typebreak"/>
ALIGNMENT &gt;, viennacl::op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a12682dd49c61d3897b1c18e49042c721">prod</a> (MatrixT const &amp;matrix_A, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, ALIGNMENT &gt; const &amp;matrix_B, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename NumericT , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const MatrixT, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a><br class="typebreak"/>
&lt; NumericT, F, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a><br class="typebreak"/>
&lt; NumericT, F, ALIGNMENT &gt;<br class="typebreak"/>
, viennacl::op_trans &gt;<br class="typebreak"/>
, viennacl::op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acfb30430740c1e7b8ab2c81aee31878a">prod</a> (MatrixT const &amp;matrix_A, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, ALIGNMENT &gt;, viennacl::op_trans &gt; &amp;matrix_B, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9ea1aff45c0fb10d62801c9c25c8831e">add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a9ea1aff45c0fb10d62801c9c25c8831e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aca5f0d1977c4cd4e70cc6af6c91fce86">inplace_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aca5f0d1977c4cd4e70cc6af6c91fce86"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aad5f201a0e90a230b4376deb311c019a">sub</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtraction of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aad5f201a0e90a230b4376deb311c019a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a04b2c67e5839525ba813da61fde893ab">inplace_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a04b2c67e5839525ba813da61fde893ab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acae4aaa06516b42063bd44c12e5d56d0">mult</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#acae4aaa06516b42063bd44c12e5d56d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7cefe6d56ec8672118ff744eac103cae">mult</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a7cefe6d56ec8672118ff744eac103cae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#affe330e509b142a9db9004f6a67c4183">inplace_mult</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#affe330e509b142a9db9004f6a67c4183"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2aa5a5587eeadc46ce37159c0429f13e">inplace_mult</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a2aa5a5587eeadc46ce37159c0429f13e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0acf4875161f1193bcda16d33a66ce61">divide</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a0acf4875161f1193bcda16d33a66ce61"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9dfce56da8c2b9d901800b205fb6b2e2">inplace_divide</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a9dfce56da8c2b9d901800b205fb6b2e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6047863f8fb097162ffad8b1b847d1df">mul_add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6047863f8fb097162ffad8b1b847d1df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a136d1799060f2adc907c8b67371a4134">mul_add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, SCALARTYPE alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a136d1799060f2adc907c8b67371a4134"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7">inplace_mul_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a7fadfccd4d7dd18f74cbe448302236e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa53a9e3743e89dd87f5e77d28621a52">inplace_mul_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aaa53a9e3743e89dd87f5e77d28621a52"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0bf813502bb4d25ab2613f1575a4fca3">mul_sub</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a0bf813502bb4d25ab2613f1575a4fca3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab2cf15c4dcf00b57cf6342492ab8ea8e">inplace_mul_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#ab2cf15c4dcf00b57cf6342492ab8ea8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abbe5a4f98fb91f55c405aa857af71d83">inplace_div_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace divide-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#abbe5a4f98fb91f55c405aa857af71d83"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aad1b78ccd178079d1c3c503b6810dd21">inplace_div_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace divide-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aad1b78ccd178079d1c3c503b6810dd21"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_uint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad87b9ecda483a69e5d5eed36928840da">index_norm_inf</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#ad87b9ecda483a69e5d5eed36928840da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a38eb0d2bea8cb4a78253c9fe329000a9">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, SCALARTYPE beta)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#a38eb0d2bea8cb4a78253c9fe329000a9"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2777d6a19ce110ae9df6609f1677be0f"></a><!-- doxytag: member="viennacl::linalg::add" ref="a2777d6a19ce110ae9df6609f1677be0f" args="(const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat1, const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2, viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two dense matrices and writes the result to a third matrix. </p>
<p>This is the implementation of the convenience expression result = mat1 + mat2;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ea1aff45c0fb10d62801c9c25c8831e"></a><!-- doxytag: member="viennacl::linalg::add" ref="a9ea1aff45c0fb10d62801c9c25c8831e" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0acf4875161f1193bcda16d33a66ce61"></a><!-- doxytag: member="viennacl::linalg::divide" ref="a0acf4875161f1193bcda16d33a66ce61" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::divide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = vec / alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The (inverse) scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8160c457245b80c37acc7f3cfcc81a8f"></a><!-- doxytag: member="viennacl::linalg::ilu_inplace_solve" ref="a8160c457245b80c37acc7f3cfcc81a8f" args="(MatrixType const &amp;mat, VectorType &amp;vec, viennacl::linalg::upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_inplace_solve </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic inplace solution of a upper triangular system. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0726586b403c9538056414240f973eb"></a><!-- doxytag: member="viennacl::linalg::ilu_inplace_solve" ref="ab0726586b403c9538056414240f973eb" args="(MatrixType const &amp;mat, VectorType &amp;vec, viennacl::linalg::unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_inplace_solve </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic inplace solution of a unit lower triangular system. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe44b3505a4625dad0b551e648f3aff0"></a><!-- doxytag: member="viennacl::linalg::ilu_lu_substitute" ref="afe44b3505a4625dad0b551e648f3aff0" args="(MatrixType const &amp;mat, VectorType &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilu_lu_substitute </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic LU substitution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85b825153bda885996e0e2986854ab77"></a><!-- doxytag: member="viennacl::linalg::ilut_inc_row_iterator_to_row_index" ref="a85b825153bda885996e0e2986854ab77" args="(viennacl::tools::const_sparse_matrix_adapter&lt; ScalarType &gt; &amp;row_iter, unsigned int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilut_inc_row_iterator_to_row_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1tools_1_1const__sparse__matrix__adapter.html">viennacl::tools::const_sparse_matrix_adapter</a>&lt; ScalarType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>row_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments a row iterator (iteration along increasing row indices) up to a certain row index k. </p>
<p>Specialization for the const sparse matrix adapter shipped with ViennaCL</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>row_iter</em>&nbsp;</td><td>The row iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The final row index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad81c044903c3d571c5fa1354e94ce817"></a><!-- doxytag: member="viennacl::linalg::ilut_inc_row_iterator_to_row_index" ref="ad81c044903c3d571c5fa1354e94ce817" args="(T &amp;row_iter, unsigned int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilut_inc_row_iterator_to_row_index </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>row_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments a row iterator (iteration along increasing row indices) up to a certain row index k. </p>
<p>Generic implementation using the iterator concept from boost::numeric::ublas. Could not find a better way for sparse matrices...</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>row_iter</em>&nbsp;</td><td>The row iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The final row index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8564080fc80b938370442ac4b9ba748f"></a><!-- doxytag: member="viennacl::linalg::ilut_inc_row_iterator_to_row_index" ref="a8564080fc80b938370442ac4b9ba748f" args="(viennacl::tools::sparse_matrix_adapter&lt; ScalarType &gt; &amp;row_iter, unsigned int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::ilut_inc_row_iterator_to_row_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html">viennacl::tools::sparse_matrix_adapter</a>&lt; ScalarType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>row_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increments a row iterator (iteration along increasing row indices) up to a certain row index k. </p>
<p>Specialization for the sparse matrix adapter shipped with ViennaCL</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>row_iter</em>&nbsp;</td><td>The row iterator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>The final row index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad87b9ecda483a69e5d5eed36928840da"></a><!-- doxytag: member="viennacl::linalg::index_norm_inf" ref="ad87b9ecda483a69e5d5eed36928840da" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint viennacl::linalg::index_norm_inf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result. Note that the result must be a CPU scalar (unsigned int), since gpu scalars are floating point types. </dd></dl>

</div>
</div>
<a class="anchor" id="ae45d23e88210e06b69cd9fdc871f3dc9"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="ae45d23e88210e06b69cd9fdc871f3dc9" args="(VectorT1 const &amp;v1, VectorT2 const &amp;v2, typename viennacl::tools::enable_if&lt; viennacl::is_stl&lt; typename viennacl::traits::tag_of&lt; VectorT1 &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT1::value_type viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype">VectorT1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT2 const &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT1 &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1348122d27efc695914431a7e9e15718"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="a1348122d27efc695914431a7e9e15718" args="(viennacl::vector&lt; ScalarType, alignment1 &gt; const &amp;vector1, viennacl::vector&lt; ScalarType, alignment2 &gt; const &amp;vector2, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; viennacl::vector&lt; ScalarType, alignment1 &gt; &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment1&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment2&gt;, viennacl::op_inner_prod &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afc191e1a26f0c0037e320a3b7dc831cc"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="afc191e1a26f0c0037e320a3b7dc831cc" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result scalar (on the gpu) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23fbff833bbc632131b761e732bce72b"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="a23fbff833bbc632131b761e732bce72b" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt;, viennacl::op_inner_prod &gt; inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="aca5f0d1977c4cd4e70cc6af6c91fce86"></a><!-- doxytag: member="viennacl::linalg::inplace_add" ref="aca5f0d1977c4cd4e70cc6af6c91fce86" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += vec2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The addend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a225d1c31fb7c1dac9f5b94f17ae1f950"></a><!-- doxytag: member="viennacl::linalg::inplace_add" ref="a225d1c31fb7c1dac9f5b94f17ae1f950" args="(viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;result, const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a dense matrix to another. </p>
<p>This is the implementation of the convenience expression result += mat1;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbe5a4f98fb91f55c405aa857af71d83"></a><!-- doxytag: member="viennacl::linalg::inplace_div_add" ref="abbe5a4f98fb91f55c405aa857af71d83" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_div_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace divide-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += vec2 / alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The vector update </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the second vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad1b78ccd178079d1c3c503b6810dd21"></a><!-- doxytag: member="viennacl::linalg::inplace_div_sub" ref="aad1b78ccd178079d1c3c503b6810dd21" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_div_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace divide-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 -= vec2 / alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The vector update </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the second vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dfce56da8c2b9d901800b205fb6b2e2"></a><!-- doxytag: member="viennacl::linalg::inplace_divide" ref="a9dfce56da8c2b9d901800b205fb6b2e2" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result *= alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The (inverse) scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e86b6169a6ff7495734d3eef5d4fd33"></a><!-- doxytag: member="viennacl::linalg::inplace_divide" ref="a6e86b6169a6ff7495734d3eef5d4fd33" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;result, viennacl::scalar&lt; SCALARTYPE &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a dense matrix by a scalar. </p>
<p>This is the implementation of the convenience expression result += mat1;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fadfccd4d7dd18f74cbe448302236e7"></a><!-- doxytag: member="viennacl::linalg::inplace_mul_add" ref="a7fadfccd4d7dd18f74cbe448302236e7" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mul_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += alpha * vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa53a9e3743e89dd87f5e77d28621a52"></a><!-- doxytag: member="viennacl::linalg::inplace_mul_add" ref="aaa53a9e3743e89dd87f5e77d28621a52" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mul_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += alpha * vec2, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2cf15c4dcf00b57cf6342492ab8ea8e"></a><!-- doxytag: member="viennacl::linalg::inplace_mul_sub" ref="ab2cf15c4dcf00b57cf6342492ab8ea8e" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mul_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 -= alpha * vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The result vector which is updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the vector update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affe330e509b142a9db9004f6a67c4183"></a><!-- doxytag: member="viennacl::linalg::inplace_mult" ref="affe330e509b142a9db9004f6a67c4183" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result *= alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aa5a5587eeadc46ce37159c0429f13e"></a><!-- doxytag: member="viennacl::linalg::inplace_mult" ref="a2aa5a5587eeadc46ce37159c0429f13e" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result *= alpha, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4501136a87a9d6294c210628ffcb23d0"></a><!-- doxytag: member="viennacl::linalg::inplace_mult" ref="a4501136a87a9d6294c210628ffcb23d0" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;result, viennacl::scalar&lt; SCALARTYPE &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">viennacl::scalar</a>&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a dense matrix by a scalar. </p>
<p>This is the implementation of the convenience expression result += mat1;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e4c7521b309670969d542805ac87b35"></a><!-- doxytag: member="viennacl::linalg::inplace_mult" ref="a0e4c7521b309670969d542805ac87b35" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;result, SCALARTYPE val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a dense matrix by a scalar. </p>
<p>This is the implementation of the convenience expression result += mat1;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae927d6abe755d74744ec5ee9bd191210"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="ae927d6abe755d74744ec5ee9bd191210" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, viennacl::linalg::unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa3a114636b1b542dfb42f48d2a0200a"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aaa3a114636b1b542dfb42f48d2a0200a" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, viennacl::linalg::upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>The upper triangular matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18293ef61ad46907177e280d4b1d680a"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a18293ef61ad46907177e280d4b1d680a" args="(const matrix&lt; SCALARTYPE, F1, A1 &gt; &amp;mat, matrix&lt; SCALARTYPE, F2, A2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F1, A1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F2, A2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ec9d2642d98a204f1de4fdad9063c14"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a0ec9d2642d98a204f1de4fdad9063c14" args="(const matrix&lt; SCALARTYPE, F1, A1 &gt; &amp;mat, const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, A2 &gt;, const matrix&lt; SCALARTYPE, F2, A2 &gt;, op_trans &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F1, A1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, A2 &gt;, const matrix&lt; SCALARTYPE, F2, A2 &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The (transposed) matrix of row vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad849b3114b76777bb0162ddf3fe8eba2"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="ad849b3114b76777bb0162ddf3fe8eba2" args="(const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, A1 &gt;, const matrix&lt; SCALARTYPE, F1, A1 &gt;, op_trans &gt; &amp;proxy, matrix&lt; SCALARTYPE, F2, A2 &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, A1 &gt;, const matrix&lt; SCALARTYPE, F1, A1 &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F2, A2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae8acccfb7520c1c75d8bbb10130aa4a"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aae8acccfb7520c1c75d8bbb10130aa4a" args="(const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, A1 &gt;, const matrix&lt; SCALARTYPE, F1, A1 &gt;, op_trans &gt; &amp;proxy, const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, A2 &gt;, const matrix&lt; SCALARTYPE, F2, A2 &gt;, op_trans &gt; &amp;B, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, A1 &gt;, const matrix&lt; SCALARTYPE, F1, A1 &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, A2 &gt;, const matrix&lt; SCALARTYPE, F2, A2 &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The matrix holding the load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fa59efa7e0a65e6e9c949b441696af1"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a1fa59efa7e0a65e6e9c949b441696af1" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a373c29fa2cb02177b1450d36eabeb265"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a373c29fa2cb02177b1450d36eabeb265" args="(const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;proxy, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, SOLVERTAG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SOLVERTAG&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04b2c67e5839525ba813da61fde893ab"></a><!-- doxytag: member="viennacl::linalg::inplace_sub" ref="a04b2c67e5839525ba813da61fde893ab" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 -= vec2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The subtracted vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae88903a9ae8dbc3fc47db7f37da326a6"></a><!-- doxytag: member="viennacl::linalg::inplace_sub" ref="ae88903a9ae8dbc3fc47db7f37da326a6" args="(viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;result, const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a dense matrix to another. </p>
<p>This is the implementation of the convenience expression result += mat1;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aa3e7727b42bd95f5d1e5dd5366f807"></a><!-- doxytag: member="viennacl::linalg::lu_factorize" ref="a2aa3e7727b42bd95f5d1e5dd5366f807" args="(matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_factorize </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU factorization of a dense matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1407e42bdce9d821baaf5d4163a09dd1"></a><!-- doxytag: member="viennacl::linalg::lu_substitute" ref="a1407e42bdce9d821baaf5d4163a09dd1" args="(matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; const &amp;A, matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_substitute </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The matrix of load vectors, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9da85acf3d7f22c869dfd52791a25d55"></a><!-- doxytag: member="viennacl::linalg::lu_substitute" ref="a9da85acf3d7f22c869dfd52791a25d55" args="(matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_substitute </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6047863f8fb097162ffad8b1b847d1df"></a><!-- doxytag: member="viennacl::linalg::mul_add" ref="a6047863f8fb097162ffad8b1b847d1df" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, scalar&lt; SCALARTYPE &gt; const &amp;alpha, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mul_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = alpha * vec1 + vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a136d1799060f2adc907c8b67371a4134"></a><!-- doxytag: member="viennacl::linalg::mul_add" ref="a136d1799060f2adc907c8b67371a4134" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, SCALARTYPE alpha, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mul_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = alpha * vec1 + vec2, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bf813502bb4d25ab2613f1575a4fca3"></a><!-- doxytag: member="viennacl::linalg::mul_sub" ref="a0bf813502bb4d25ab2613f1575a4fca3" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, scalar&lt; SCALARTYPE &gt; const &amp;alpha, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mul_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = alpha * vec1 - vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acae4aaa06516b42063bd44c12e5d56d0"></a><!-- doxytag: member="viennacl::linalg::mult" ref="acae4aaa06516b42063bd44c12e5d56d0" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = vec * alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cefe6d56ec8672118ff744eac103cae"></a><!-- doxytag: member="viennacl::linalg::mult" ref="a7cefe6d56ec8672118ff744eac103cae" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = vec * alpha, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab37ecf5aa97762b3e174b862912f510a"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="ab37ecf5aa97762b3e174b862912f510a" args="(VectorT const &amp;v1, typename viennacl::tools::enable_if&lt; viennacl::is_stl&lt; typename viennacl::traits::tag_of&lt; VectorT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT::value_type viennacl::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5e7e99c21b05b4db0e9422d9c9ed181"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="ac5e7e99c21b05b4db0e9422d9c9ed181" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;vector, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; viennacl::vector&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_1 &gt; viennacl::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2479f0743a32118e916cca8edb895c30"></a><!-- doxytag: member="viennacl::linalg::norm_1_impl" ref="a2479f0743a32118e916cca8edb895c30" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, scalar&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void norm_1_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87acc0739e4f1bc63934e9ad24f35a9a"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="a87acc0739e4f1bc63934e9ad24f35a9a" args="(VectorT const &amp;v1, typename viennacl::tools::enable_if&lt; viennacl::is_stl&lt; typename viennacl::traits::tag_of&lt; VectorT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT::value_type viennacl::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12a0a2106e96f8f1625b6c5bdec90f4c"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="a12a0a2106e96f8f1625b6c5bdec90f4c" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;v, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; viennacl::vector&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_2 &gt; viennacl::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a96a2ee028641ffd7b80e6a1bfad34c6a"></a><!-- doxytag: member="viennacl::linalg::norm_2_impl" ref="a96a2ee028641ffd7b80e6a1bfad34c6a" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, scalar&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void norm_2_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - implementation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc500239f2e1967e584b71171cba268"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="aadc500239f2e1967e584b71171cba268" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;v1, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; viennacl::vector&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_inf &gt; viennacl::linalg::norm_inf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03a5b5434ce08fac52aa22dbb684029c"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="a03a5b5434ce08fac52aa22dbb684029c" args="(VectorT const &amp;v1, typename viennacl::tools::enable_if&lt; viennacl::is_stl&lt; typename viennacl::traits::tag_of&lt; VectorT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT::value_type viennacl::linalg::norm_inf </td>
          <td>(</td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; VectorT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43009c5365c78c81463f54c2848378ca"></a><!-- doxytag: member="viennacl::linalg::norm_inf_impl" ref="a43009c5365c78c81463f54c2848378ca" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, scalar&lt; SCALARTYPE &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void norm_inf_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b56d764864ae3d91bb6bac2ae87bec8"></a><!-- doxytag: member="viennacl::linalg::outer_prod" ref="a1b56d764864ae3d91bb6bac2ae87bec8" args="(const viennacl::vector&lt; SCALARTYPE, VA1 &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, VA2 &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VA1&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VA2&gt;, op_prod&gt; viennacl::linalg::outer_prod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38eb0d2bea8cb4a78253c9fe329000a9"></a><!-- doxytag: member="viennacl::linalg::plane_rotation" ref="a38eb0d2bea8cb4a78253c9fe329000a9" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, SCALARTYPE beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::plane_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>beta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The first transformation coefficient </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beta</em>&nbsp;</td><td>The second transformation coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1642cbf74be37d2ae455606506dc578"></a><!-- doxytag: member="viennacl::linalg::precondition" ref="aa1642cbf74be37d2ae455606506dc578" args="(MatrixType const &amp;input, LUType &amp;output, ilut_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::precondition </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LUType &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ilut_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of a ILU-preconditioner with threshold. </p>
<p>refer to Algorithm 10.6 by Saad's book (1996 edition)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The input matrix. Type requirements: const_iterator1 for iteration along rows, const_iterator2 for iteration along columns </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>The output matrix. Type requirements: const_iterator1 for iteration along rows, const_iterator2 for iteration along columns and write access via operator() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>An <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html" title="A tag for incomplete LU factorization with threshold (ILUT).">ilut_tag</a> in order to dispatch among several other preconditioners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1687a9eb40c623b00c880cd88f176d7"></a><!-- doxytag: member="viennacl::linalg::prod" ref="ae1687a9eb40c623b00c880cd88f176d7" args="(MatrixT const &amp;matrix, VectorT const &amp;vector, typename viennacl::tools::enable_if&lt; viennacl::is_stl&lt; typename viennacl::traits::tag_of&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__stl.html">viennacl::is_stl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12682dd49c61d3897b1c18e49042c721"></a><!-- doxytag: member="viennacl::linalg::prod" ref="a12682dd49c61d3897b1c18e49042c721" args="(MatrixT const &amp;matrix_A, viennacl::matrix&lt; NumericT, F, ALIGNMENT &gt; const &amp;matrix_B, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const MatrixT, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt;NumericT, F, ALIGNMENT&gt;, viennacl::op_prod &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abe959c83610141222955cfa6c52ed961"></a><!-- doxytag: member="viennacl::linalg::prod" ref="abe959c83610141222955cfa6c52ed961" args="(MatrixT const &amp;matrix, viennacl::vector&lt; NumericT, ALIGNMENT &gt; const &amp;vector, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const MatrixT, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;NumericT, ALIGNMENT&gt;, viennacl::op_prod &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; NumericT, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acfb30430740c1e7b8ab2c81aee31878a"></a><!-- doxytag: member="viennacl::linalg::prod" ref="acfb30430740c1e7b8ab2c81aee31878a" args="(MatrixT const &amp;matrix_A, const viennacl::matrix_expression&lt; const viennacl::matrix&lt; NumericT, F, ALIGNMENT &gt;, const viennacl::matrix&lt; NumericT, F, ALIGNMENT &gt;, viennacl::op_trans &gt; &amp;matrix_B, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const MatrixT, const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt;NumericT, F, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt;NumericT, F, ALIGNMENT&gt;, viennacl::op_trans &gt;, viennacl::op_prod &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; NumericT, F, ALIGNMENT &gt;, viennacl::op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a21163d892b2568fa4fa3abe750a5504f"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a21163d892b2568fa4fa3abe750a5504f" args="(const viennacl::matrix_expression&lt; const matrix&lt; TYPE, F1, ALIGNMENT &gt;, const matrix&lt; TYPE, F1, ALIGNMENT &gt;, op_trans &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix&lt; TYPE, F2, ALIGNMENT &gt;, const matrix&lt; TYPE, F2, ALIGNMENT &gt;, op_trans &gt; &amp;B, viennacl::matrix&lt; TYPE, F3, ALIGNMENT &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix&lt; TYPE, F1, ALIGNMENT &gt;, const matrix&lt; TYPE, F1, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix&lt; TYPE, F2, ALIGNMENT &gt;, const matrix&lt; TYPE, F2, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), trans(B)); </p>

</div>
</div>
<a class="anchor" id="abbc7f86d9d7e24ff1eae02fe976bc77d"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="abbc7f86d9d7e24ff1eae02fe976bc77d" args="(const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07b1f6f849c9950dd557bbf3e38f569d"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a07b1f6f849c9950dd557bbf3e38f569d" args="(std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;matrix, VectorT const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T, A1 &gt;, A2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07e0985a7c2429067b483238d0ffeb2a"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a07e0985a7c2429067b483238d0ffeb2a" args="(const viennacl::matrix&lt; TYPE, F1, ALIGNMENT &gt; &amp;A, const viennacl::matrix_expression&lt; const matrix&lt; TYPE, F2, ALIGNMENT &gt;, const matrix&lt; TYPE, F2, ALIGNMENT &gt;, op_trans &gt; &amp;B, viennacl::matrix&lt; TYPE, F3, ALIGNMENT &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F1, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix&lt; TYPE, F2, ALIGNMENT &gt;, const matrix&lt; TYPE, F2, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, trans(B)); </p>

</div>
</div>
<a class="anchor" id="afa56b176c5b19331a2fd286cac2f9c92"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="afa56b176c5b19331a2fd286cac2f9c92" args="(const viennacl::coordinate_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa965a1bc156b037f57b6a449dde4c7d1"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="aa965a1bc156b037f57b6a449dde4c7d1" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; prod_impl </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a469b22e14078bba1451afb09bbd2f7cc"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a469b22e14078bba1451afb09bbd2f7cc" args="(const viennacl::compressed_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, size_t NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bb2b3cdaa265974abb81154593357b3"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a8bb2b3cdaa265974abb81154593357b3" args="(std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;matrix, VectorT const &amp;vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorT viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::map&lt; KEY, DATA, COMPARE, AMAP &gt;, AVEC &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1294bf672bcc55c62d1622b07b44425e"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a1294bf672bcc55c62d1622b07b44425e" args="(const viennacl::matrix&lt; TYPE, F1, ALIGNMENT &gt; &amp;A, const viennacl::matrix&lt; TYPE, F2, ALIGNMENT &gt; &amp;B, viennacl::matrix&lt; TYPE, F3, ALIGNMENT &gt; &amp;C, int block_size=15)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F1, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F2, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>block_size</em> = <code>15</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(A, B); </p>

</div>
</div>
<a class="anchor" id="a79ec888c8ac1026f4591179fdd19e0de"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a79ec888c8ac1026f4591179fdd19e0de" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; prod_impl </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e71c3317fe25d0ce5e31be66597d8bb"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a5e71c3317fe25d0ce5e31be66597d8bb" args="(const viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7984796b04f748d616d1071b0e70850b"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a7984796b04f748d616d1071b0e70850b" args="(const viennacl::coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, size_t NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt;SCALARTYPE, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt;, viennacl::op_prod &gt; viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f088d9329b8c801492830a519fdef15"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a4f088d9329b8c801492830a519fdef15" args="(const viennacl::matrix_expression&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;proxy, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F, ALIGNMENT&gt;, op_trans&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt;, op_prod &gt; viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a transposed matrix. </p>
<p>This is used for the convenience expression result = trans(mat) * vec;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The transposed matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8a3b3e7b5421283ccdc96c07ce3c624"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="af8a3b3e7b5421283ccdc96c07ce3c624" args="(const viennacl::matrix_expression&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwraps the transposed matrix proxy and forwards to <a class="el" href="namespaceviennacl_1_1linalg.html#a0c03a1482aebb921ce45f3b1c933697c" title="Carries out matrix-vector multiplication with a transposed matrix.">trans_prod_impl()</a>. </p>

</div>
</div>
<a class="anchor" id="aa03a4515a4033a22afc6f2e9bfad1ed6"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="aa03a4515a4033a22afc6f2e9bfad1ed6" args="(const viennacl::matrix_expression&lt; const matrix&lt; TYPE, F1, ALIGNMENT &gt;, const matrix&lt; TYPE, F1, ALIGNMENT &gt;, op_trans &gt; &amp;A, const viennacl::matrix&lt; TYPE, F2, ALIGNMENT &gt; &amp;B, viennacl::matrix&lt; TYPE, F3, ALIGNMENT &gt; &amp;C)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const matrix&lt; TYPE, F1, ALIGNMENT &gt;, const matrix&lt; TYPE, F1, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F2, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F3, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>C</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-matrix multiplication. </p>
<p>Implementation of C = prod(trans(A), B); </p>

</div>
</div>
<a class="anchor" id="a90c6aa1f54abd466421ea06bf9b49716"></a><!-- doxytag: member="viennacl::linalg::rank_1_update" ref="a90c6aa1f54abd466421ea06bf9b49716" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::rank_1_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += vec1 * vec2^T, i.e. a rank 1 update. </p>
<p>Implementation of the convenience expression result += outer_prod(vec1, vec2);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The matrix to be updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46f8f468d8d1d6deec2a4d906f987e85"></a><!-- doxytag: member="viennacl::linalg::scaled_rank_1_update" ref="a46f8f468d8d1d6deec2a4d906f987e85" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, SCALARTYPE val, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::scaled_rank_1_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The matrix to be updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The scaling factor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d7d0a974cd68a51c4d5c4b7a16c1d28"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a6d7d0a974cd68a51c4d5c4b7a16c1d28" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, const viennacl::linalg::unit_lower_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>The lower triangular sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76b4d001b76edd2253dc7d3a2852b391"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a76b4d001b76edd2253dc7d3a2852b391" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, gmres_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&nbsp;</td>
          <td class="paramname"> <em>precond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the GMRES solver. </p>
<p>Following the algorithm proposed by Walker in "A Simpler GMRES"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precond</em>&nbsp;</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a6bc45bf37430c67d6a32ed8e10e77e94"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a6bc45bf37430c67d6a32ed8e10e77e94" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the conjugate gradient solver without preconditioner. </p>
<p>Following the algorithm in the book by Y. Saad "Iterative Methods for sparse linear systems"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a658f2de0ab6804ebabbc4248adc2d927"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a658f2de0ab6804ebabbc4248adc2d927" args="(const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; &amp;A, const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F2, ALIGNMENT_B&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for C = solve(A, B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The matrix of load vectors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a560520300c350a1d8afa44d5c036b48b"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a560520300c350a1d8afa44d5c036b48b" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag, viennacl::linalg::no_precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aec73c039978029c091e70224bf283ed5"></a><!-- doxytag: member="viennacl::linalg::solve" ref="aec73c039978029c091e70224bf283ed5" args="(const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, op_trans &gt; &amp;proxy, const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;B, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F2, ALIGNMENT_B&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), B, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The transposed system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>The matrix of load vectors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add76ce64e200f9193156a98a15bf42fd"></a><!-- doxytag: member="viennacl::linalg::solve" ref="add76ce64e200f9193156a98a15bf42fd" args="(const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;proxy, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The transposed system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7eb0bd2b912aa3c5d83aa4801e7e89fd"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a7eb0bd2b912aa3c5d83aa4801e7e89fd" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag, viennacl::linalg::no_precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">viennacl::linalg::no_precond</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab50f87d195eb82ddbe5ce910e914bc55"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ab50f87d195eb82ddbe5ce910e914bc55" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the stabilized Bi-conjugate gradient solver. </p>
<p>Following the description in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a13d7be38f0fbef200ccbe90d9240e542"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a13d7be38f0fbef200ccbe90d9240e542" args="(const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; &amp;A, const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, op_trans &gt; &amp;proxy, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F2, ALIGNMENT_B&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for C = solve(A, B^T, some_tag()); Creates a temporary result matrix and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The transposed load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbcb7f6a46ca520d01f6ce53f83f5069"></a><!-- doxytag: member="viennacl::linalg::solve" ref="adbcb7f6a46ca520d01f6ce53f83f5069" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&nbsp;</td>
          <td class="paramname"> <em>precond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the preconditioned stabilized Bi-conjugate gradient solver. </p>
<p>Following the description of the unpreconditioned case in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precond</em>&nbsp;</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="adefd0a97aaeaa8eb75097847443c6ee1"></a><!-- doxytag: member="viennacl::linalg::solve" ref="adefd0a97aaeaa8eb75097847443c6ee1" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&nbsp;</td>
          <td class="paramname"> <em>precond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the preconditioned conjugate gradient solver. </p>
<p>Following Algorithm 9.1 in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precond</em>&nbsp;</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a9f5cb80858484131ecb73e867b2bf794"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a9f5cb80858484131ecb73e867b2bf794" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(mat, vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa338acd99f7bfac8c0210ab05ecaa09"></a><!-- doxytag: member="viennacl::linalg::solve" ref="aaa338acd99f7bfac8c0210ab05ecaa09" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, viennacl::linalg::upper_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>The lower triangular sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18da6b35b9790a1acd824dee6a8fb76a"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a18da6b35b9790a1acd824dee6a8fb76a" args="(const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, op_trans &gt; &amp;proxy_A, const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, op_trans &gt; &amp;proxy_B, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F2, ALIGNMENT_B&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, const matrix&lt; SCALARTYPE, F1, ALIGNMENT_A &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, const matrix&lt; SCALARTYPE, F2, ALIGNMENT_B &gt;, op_trans &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically used for LU su...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy_A</em>&nbsp;</td><td>The transposed system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy_B</em>&nbsp;</td><td>The transposed matrix of load vectors, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad590c4eadb76eea1a806c3c4c026ba66"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ad590c4eadb76eea1a806c3c4c026ba66" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, gmres_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload of the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function using GMRES. Per default, no preconditioner is used. </p>

</div>
</div>
<a class="anchor" id="a707ace72b7ff8ad1e3a9ff2606567f1e"></a><!-- doxytag: member="viennacl::linalg::sub" ref="a707ace72b7ff8ad1e3a9ff2606567f1e" args="(const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat1, const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2, viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two dense matrices and writes the result to a third matrix. </p>
<p>This is the implementation of the convenience expression result = mat1 + mat2;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad5f201a0e90a230b4376deb311c019a"></a><!-- doxytag: member="viennacl::linalg::sub" ref="aad5f201a0e90a230b4376deb311c019a" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtraction of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>result = vec1 - vec2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c03a1482aebb921ce45f3b1c933697c"></a><!-- doxytag: member="viennacl::linalg::trans_prod_impl" ref="a0c03a1482aebb921ce45f3b1c933697c" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::trans_prod_impl </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat May 21 2011 20:36:51 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
