<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceviennacl.html">viennacl</a>::<a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a>
  </div>
</div>
<div class="contents">
<h1>viennacl::linalg Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg_1_1kernels.html">kernels</a></td></tr>
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing a lower triangular matrix.  <a href="structviennacl_1_1linalg_1_1lower__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing an upper triangular matrix.  <a href="structviennacl_1_1linalg_1_1upper__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing a lower triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__lower__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing an upper triangular matrix with unit diagonal.  <a href="structviennacl_1_1linalg_1_1unit__upper__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1no__precond.html">no_precond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag class representing the use of no preconditioner.  <a href="classviennacl_1_1linalg_1_1no__precond.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for the stabilized Bi-conjugate gradient solver. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1bicgstab__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for the conjugate gradient Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1cg__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for the solver GMRES. Used for supplying solver parameters and for dispatching the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function.  <a href="classviennacl_1_1linalg_1_1gmres__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for incomplete LU factorization with threshold (ILUT).  <a href="classviennacl_1_1linalg_1_1ilut__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond.html">ilut_precond</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1linalg_1_1ilut__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html">ilut_precond&lt; compressed_matrix&lt; ScalarType, MAT_ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ILUT preconditioner class, can be supplied to <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a>-routines.  <a href="classviennacl_1_1linalg_1_1ilut__precond_3_01compressed__matrix_3_01_scalar_type_00_01_m_a_t___a_l_i_g_n_m_e_n_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8cb58d3e096e8eefd750aee35249765e">norm_2_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;result, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the l^2-norm of a vector - implementation.  <a href="#a8cb58d3e096e8eefd750aee35249765e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, F, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a52ace672f389f46bd2e8ec8440b4dda3">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication.  <a href="#a52ace672f389f46bd2e8ec8440b4dda3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a838721b6e2f200516c5a17368b19841a">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a838721b6e2f200516c5a17368b19841a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3bb32bd79aa964e6fd59f48976917678">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a>.  <a href="#a3bb32bd79aa964e6fd59f48976917678"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT1, unsigned int ALIGNMENT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT1 &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT2 &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acec2a9ca55e33f98defcde0b2cf3db18">inner_prod_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;vec2, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the inner product of two vectors.  <a href="#acec2a9ca55e33f98defcde0b2cf3db18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a507b21e23e973342ea180f6f0cfed447">inner_prod_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;result, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#a507b21e23e973342ea180f6f0cfed447"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the stabilized Bi-conjugate gradient solver.  <a href="#ab50f87d195eb82ddbe5ce910e914bc55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adbcb7f6a46ca520d01f6ce53f83f5069">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1bicgstab__tag.html">bicgstab_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the preconditioned stabilized Bi-conjugate gradient solver.  <a href="#adbcb7f6a46ca520d01f6ce53f83f5069"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6bc45bf37430c67d6a32ed8e10e77e94">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the conjugate gradient solver without preconditioner.  <a href="#a6bc45bf37430c67d6a32ed8e10e77e94"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adefd0a97aaeaa8eb75097847443c6ee1">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1cg__tag.html">cg_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the preconditioned conjugate gradient solver.  <a href="#adefd0a97aaeaa8eb75097847443c6ee1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ac73aba1ff7c252029b1b1566b0760567">prod_impl</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#ac73aba1ff7c252029b1b1566b0760567"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions.  <a href="#ae927d6abe755d74744ec5ee9bd191210"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6d7d0a974cd68a51c4d5c4b7a16c1d28">solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, const <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>.  <a href="#a6d7d0a974cd68a51c4d5c4b7a16c1d28"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa3a114636b1b542dfb42f48d2a0200a">inplace_solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions.  <a href="#aaa3a114636b1b542dfb42f48d2a0200a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int MAT_ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aaa338acd99f7bfac8c0210ab05ecaa09">solve</a> (<a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>.  <a href="#aaa338acd99f7bfac8c0210ab05ecaa09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adaac2c72634061bef5ca4fd29e98e909">prod_impl</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a>.  <a href="#adaac2c72634061bef5ca4fd29e98e909"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad718b280589f7bac3c08b762ccadb0de">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems.  <a href="#ad718b280589f7bac3c08b762ccadb0de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa382b49402710ba3c6ad49eacd4b5828">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__upper__tag.html">unit_upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems with unit diagonal.  <a href="#aa382b49402710ba3c6ad49eacd4b5828"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aefa9ce1abd6fc75bbc2e100c891feb67">inplace_solve</a> (const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems.  <a href="#aefa9ce1abd6fc75bbc2e100c891feb67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5efd4d0220c14ec26af0002309ae25a9">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for lower triangular systems.  <a href="#a5efd4d0220c14ec26af0002309ae25a9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aadd56604eb48b5d7b9b63d8fceaa1d6b">inplace_solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for lower triangular systems with unit diagonal.  <a href="#aadd56604eb48b5d7b9b63d8fceaa1d6b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aea73e85eea4019f9381f691408974d1f">inplace_solve</a> (const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1lower__tag.html">lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct inplace solver for dense lower triangular systems that stem from transposed upper triangular systems.  <a href="#aea73e85eea4019f9381f691408974d1f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9f5cb80858484131ecb73e867b2bf794">solve</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(mat, vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>.  <a href="#a9f5cb80858484131ecb73e867b2bf794"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a09ea4f013f48c87c30e8f9013b673d24">solve</a> (const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>.  <a href="#a09ea4f013f48c87c30e8f9013b673d24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a2aa3e7727b42bd95f5d1e5dd5366f807">lu_factorize</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU factorization of a dense matrix.  <a href="#a2aa3e7727b42bd95f5d1e5dd5366f807"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VEC_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a9da85acf3d7f22c869dfd52791a25d55">lu_substitute</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;mat, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU substitution for the system LU = rhs.  <a href="#a9da85acf3d7f22c869dfd52791a25d55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType , typename PreconditionerType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a76b4d001b76edd2253dc7d3a2852b391">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag, PreconditionerType const &amp;precond)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the GMRES solver.  <a href="#a76b4d001b76edd2253dc7d3a2852b391"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ad590c4eadb76eea1a806c3c4c026ba66">solve</a> (const MatrixType &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorType const &amp;rhs, <a class="el" href="classviennacl_1_1linalg_1_1gmres__tag.html">gmres_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload of the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function using GMRES. Per default, no preconditioner is used.  <a href="#ad590c4eadb76eea1a806c3c4c026ba66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename LUType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aa1642cbf74be37d2ae455606506dc578">precondition</a> (MatrixType const &amp;input, LUType &amp;output, <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html">ilut_tag</a> const &amp;tag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of a ILU-preconditioner with threshold.  <a href="#aa1642cbf74be37d2ae455606506dc578"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adcaf1fbcaed75ec8e7b07ff5d746b5c9">inplace_solve</a> (MatrixType const &amp;mat, VectorType &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic inplace solution of a unit lower triangular system.  <a href="#adcaf1fbcaed75ec8e7b07ff5d746b5c9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a88e91005d8ffc7f708ac001d14a080ce">inplace_solve</a> (MatrixType const &amp;mat, VectorType &amp;vec, <a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic inplace solution of a upper triangular system.  <a href="#a88e91005d8ffc7f708ac001d14a080ce"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1116cc2939461ade988f81140e617c24">lu_substitute</a> (MatrixType const &amp;mat, VectorType &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic LU substitution.  <a href="#a1116cc2939461ade988f81140e617c24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment1, unsigned int alignment2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment1 &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment2 &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">inner_prod</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; const &amp;vector1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment2 &gt; const &amp;vector2, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6ca4f06df288fda54a8ed6f5665b19df">add</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat1, const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2, <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds two dense matrices and writes the result to a third matrix.  <a href="#a6ca4f06df288fda54a8ed6f5665b19df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab965ea63d68073b56e20470a17c540d3">prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication.  <a href="#ab965ea63d68073b56e20470a17c540d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">viennacl::transposed_matrix_proxy</a><br class="typebreak"/>
&lt; SCALARTYPE, F, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a24c76630b27107c4d62c9ec981fa920e">prod_impl</a> (const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">viennacl::transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class that represents matrix-vector multiplication with a transposed matrix.  <a href="#a24c76630b27107c4d62c9ec981fa920e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a01059b42db0cbb19ac1904bada8329e3">prod_impl</a> (const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">viennacl::transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwraps the transposed matrix proxy and forwards to <a class="el" href="namespaceviennacl_1_1linalg.html#ab684949fe77b0db121f62f1f8a0de435" title="Carries out matrix-vector multiplication with a transposed matrix.">trans_prod_impl()</a>.  <a href="#a01059b42db0cbb19ac1904bada8329e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT, unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ab684949fe77b0db121f62f1f8a0de435">trans_prod_impl</a> (const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Carries out matrix-vector multiplication with a transposed matrix.  <a href="#ab684949fe77b0db121f62f1f8a0de435"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1outer__prod__proxy.html">viennacl::outer_prod_proxy</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a0568dee2f2b612e438661eb455cd76c0">outer_prod</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update.  <a href="#a0568dee2f2b612e438661eb455cd76c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a08b4cf23e757e692a430cadc45e3a6e9">rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The implementation of the operation mat += vec1 * vec2^T, i.e. a rank 1 update.  <a href="#a08b4cf23e757e692a430cadc45e3a6e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a147d5b548e31dc563a257e4745b86ab6">scaled_rank_1_update</a> (<a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, SCALARTYPE val, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update.  <a href="#a147d5b548e31dc563a257e4745b86ab6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , unsigned int alignment&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; ScalarType, alignment &gt;<br class="typebreak"/>
, viennacl::op_norm_2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a5f13104ad8997fe4eb97717fde2bec1a">norm_2</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , typename VectorT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a><br class="typebreak"/>
&lt; const MatrixT, const VectorT, <br class="typebreak"/>
viennacl::op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acd380c11fa6a29fc1021e7b60f34dcf1">prod</a> (MatrixT const &amp;<a class="el" href="classviennacl_1_1matrix.html">matrix</a>, VectorT const &amp;<a class="el" href="classviennacl_1_1vector.html">vector</a>, typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ace5ef08d2e7baddbd98262f0093665de">add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#ace5ef08d2e7baddbd98262f0093665de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a57d94fbbd2c6becdc836360b48560c36">inplace_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a57d94fbbd2c6becdc836360b48560c36"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a99aa3a3f1e37472564b2b73c61231a37">sub</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtraction of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a99aa3a3f1e37472564b2b73c61231a37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6df0e919b134ddfd7ef814e35b9d71b1">inplace_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6df0e919b134ddfd7ef814e35b9d71b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abd5ba35456dad83b2b92bdc2b975f1de">mult</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#abd5ba35456dad83b2b92bdc2b975f1de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aad80ec890c37305239e26131957a60fb">mult</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aad80ec890c37305239e26131957a60fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6324a36a09e1a21cc4cc4d866dda5bc4">inplace_mult</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6324a36a09e1a21cc4cc4d866dda5bc4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aecbb67f095fe30240a634cce5dfe8e66">inplace_mult</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aecbb67f095fe30240a634cce5dfe8e66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a951fc996a086d8d946471305bd947de3">divide</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a951fc996a086d8d946471305bd947de3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acc6c8bf5616af9dd1402d85d23cc7d2b">inplace_divide</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#acc6c8bf5616af9dd1402d85d23cc7d2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6469ec227ee3c0a9f8c9e31d16e80856">mul_add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6469ec227ee3c0a9f8c9e31d16e80856"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a148b16c1cf52db44408ff100bda45be2">mul_add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, SCALARTYPE alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a148b16c1cf52db44408ff100bda45be2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4911ae3ec8685a1f041e37c009c31892">inplace_mul_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a4911ae3ec8685a1f041e37c009c31892"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adab8fb5aa2530e48c7ba7d2987aa4448">inplace_mul_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#adab8fb5aa2530e48c7ba7d2987aa4448"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7ab4e344aa136d4221bc2f22c1431a03">mul_sub</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a7ab4e344aa136d4221bc2f22c1431a03"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a247561256ec5f76d90f68cd4271749ea">inplace_mul_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a247561256ec5f76d90f68cd4271749ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e9cf3be544743cf0f79d8eea4d63b3b">inplace_div_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace divide-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6e9cf3be544743cf0f79d8eea4d63b3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a11f746acdd474fb7de5347e562fb92d6">inplace_div_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace divide-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a11f746acdd474fb7de5347e562fb92d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SCALARTYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a773963ad0576dedd6ea9677a964d7eb6">norm_1</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the l^1-norm of a vector.  <a href="#a773963ad0576dedd6ea9677a964d7eb6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SCALARTYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aed0642dda58cce7ebceffceb2bb1dc7c">norm_inf</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#aed0642dda58cce7ebceffceb2bb1dc7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_uint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3b084a55303d0df592ffd96ea591eb93">index_norm_inf</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a3b084a55303d0df592ffd96ea591eb93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a475332833e58b7d657544f3e40164f9a">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, SCALARTYPE beta, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#a475332833e58b7d657544f3e40164f9a"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ace5ef08d2e7baddbd98262f0093665de"></a><!-- doxytag: member="viennacl::linalg::add" ref="ace5ef08d2e7baddbd98262f0093665de" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ca4f06df288fda54a8ed6f5665b19df"></a><!-- doxytag: member="viennacl::linalg::add" ref="a6ca4f06df288fda54a8ed6f5665b19df" args="(const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat1, const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;mat2, viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds two dense matrices and writes the result to a third matrix. </p>
<p>This is the implementation of the convenience expression result = mat1 + mat2;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The left hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mat2</em>&nbsp;</td><td>The right hand side operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a951fc996a086d8d946471305bd947de3"></a><!-- doxytag: member="viennacl::linalg::divide" ref="a951fc996a086d8d946471305bd947de3" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::divide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = vec / alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The (inverse) scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b084a55303d0df592ffd96ea591eb93"></a><!-- doxytag: member="viennacl::linalg::index_norm_inf" ref="a3b084a55303d0df592ffd96ea591eb93" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl_uint viennacl::linalg::index_norm_inf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the index of the first entry that is equal to the supremum-norm in modulus. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result. Note that the result must be a CPU scalar (unsigned int), since gpu scalars are floating point types. </dd></dl>

</div>
</div>
<a class="anchor" id="a1348122d27efc695914431a7e9e15718"></a><!-- doxytag: member="viennacl::linalg::inner_prod" ref="a1348122d27efc695914431a7e9e15718" args="(viennacl::vector&lt; ScalarType, alignment1 &gt; const &amp;vector1, viennacl::vector&lt; ScalarType, alignment2 &gt; const &amp;vector2, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; viennacl::vector&lt; ScalarType, alignment1 &gt; &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment1&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment2&gt;, viennacl::op_inner_prod &gt; viennacl::linalg::inner_prod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment1 &gt; &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a507b21e23e973342ea180f6f0cfed447"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="a507b21e23e973342ea180f6f0cfed447" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; &amp;result, unsigned int NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result scalar (on the gpu) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acec2a9ca55e33f98defcde0b2cf3db18"></a><!-- doxytag: member="viennacl::linalg::inner_prod_impl" ref="acec2a9ca55e33f98defcde0b2cf3db18" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;vec2, unsigned int NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt;, viennacl::op_inner_prod &gt; inner_prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the inner product of two vectors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a57d94fbbd2c6becdc836360b48560c36"></a><!-- doxytag: member="viennacl::linalg::inplace_add" ref="a57d94fbbd2c6becdc836360b48560c36" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += vec2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The addend </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e9cf3be544743cf0f79d8eea4d63b3b"></a><!-- doxytag: member="viennacl::linalg::inplace_div_add" ref="a6e9cf3be544743cf0f79d8eea4d63b3b" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_div_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace divide-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += vec2 / alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The vector update </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the second vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11f746acdd474fb7de5347e562fb92d6"></a><!-- doxytag: member="viennacl::linalg::inplace_div_sub" ref="a11f746acdd474fb7de5347e562fb92d6" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_div_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace divide-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 -= vec2 / alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The vector update </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the second vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc6c8bf5616af9dd1402d85d23cc7d2b"></a><!-- doxytag: member="viennacl::linalg::inplace_divide" ref="acc6c8bf5616af9dd1402d85d23cc7d2b" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result *= alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The (inverse) scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adab8fb5aa2530e48c7ba7d2987aa4448"></a><!-- doxytag: member="viennacl::linalg::inplace_mul_add" ref="adab8fb5aa2530e48c7ba7d2987aa4448" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mul_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += alpha * vec2, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4911ae3ec8685a1f041e37c009c31892"></a><!-- doxytag: member="viennacl::linalg::inplace_mul_add" ref="a4911ae3ec8685a1f041e37c009c31892" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mul_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 += alpha * vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a247561256ec5f76d90f68cd4271749ea"></a><!-- doxytag: member="viennacl::linalg::inplace_mul_sub" ref="a247561256ec5f76d90f68cd4271749ea" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mul_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 -= alpha * vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The result vector which is updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the vector update. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecbb67f095fe30240a634cce5dfe8e66"></a><!-- doxytag: member="viennacl::linalg::inplace_mult" ref="aecbb67f095fe30240a634cce5dfe8e66" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result *= alpha, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6324a36a09e1a21cc4cc4d866dda5bc4"></a><!-- doxytag: member="viennacl::linalg::inplace_mult" ref="a6324a36a09e1a21cc4cc4d866dda5bc4" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result *= alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88e91005d8ffc7f708ac001d14a080ce"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a88e91005d8ffc7f708ac001d14a080ce" args="(MatrixType const &amp;mat, VectorType &amp;vec, viennacl::linalg::upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic inplace solution of a upper triangular system. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcaf1fbcaed75ec8e7b07ff5d746b5c9"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="adcaf1fbcaed75ec8e7b07ff5d746b5c9" args="(MatrixType const &amp;mat, VectorType &amp;vec, viennacl::linalg::unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic inplace solution of a unit lower triangular system. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea73e85eea4019f9381f691408974d1f"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aea73e85eea4019f9381f691408974d1f" args="(const transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lower_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense lower triangular systems that stem from transposed upper triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadd56604eb48b5d7b9b63d8fceaa1d6b"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aadd56604eb48b5d7b9b63d8fceaa1d6b" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unit_lower_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for lower triangular systems with unit diagonal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5efd4d0220c14ec26af0002309ae25a9"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="a5efd4d0220c14ec26af0002309ae25a9" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lower_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for lower triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefa9ce1abd6fc75bbc2e100c891feb67"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aefa9ce1abd6fc75bbc2e100c891feb67" args="(const transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">upper_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems that stem from transposed lower triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa382b49402710ba3c6ad49eacd4b5828"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aa382b49402710ba3c6ad49eacd4b5828" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, unit_upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unit_upper_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems with unit diagonal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad718b280589f7bac3c08b762ccadb0de"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="ad718b280589f7bac3c08b762ccadb0de" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">upper_tag&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct inplace solver for dense upper triangular systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa3a114636b1b542dfb42f48d2a0200a"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="aaa3a114636b1b542dfb42f48d2a0200a" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;U, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, viennacl::linalg::upper_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a upper triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. Typically used for LU substitutions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>U</em>&nbsp;</td><td>The upper triangular matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae927d6abe755d74744ec5ee9bd191210"></a><!-- doxytag: member="viennacl::linalg::inplace_solve" ref="ae927d6abe755d74744ec5ee9bd191210" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, viennacl::linalg::unit_lower_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace solution of a lower triangular <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> with unit diagonal. Typically used for LU substitutions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6df0e919b134ddfd7ef814e35b9d71b1"></a><!-- doxytag: member="viennacl::linalg::inplace_sub" ref="a6df0e919b134ddfd7ef814e35b9d71b1" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::inplace_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes vec1 -= vec2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The subtracted vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aa3e7727b42bd95f5d1e5dd5366f807"></a><!-- doxytag: member="viennacl::linalg::lu_factorize" ref="a2aa3e7727b42bd95f5d1e5dd5366f807" args="(matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_factorize </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU factorization of a dense matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1116cc2939461ade988f81140e617c24"></a><!-- doxytag: member="viennacl::linalg::lu_substitute" ref="a1116cc2939461ade988f81140e617c24" args="(MatrixType const &amp;mat, VectorType &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_substitute </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic LU substitution. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9da85acf3d7f22c869dfd52791a25d55"></a><!-- doxytag: member="viennacl::linalg::lu_substitute" ref="a9da85acf3d7f22c869dfd52791a25d55" args="(matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;mat, vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::lu_substitute </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU substitution for the system LU = rhs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix, where the LU matrices are directly written to. The implicit unit diagonal of L is not written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a148b16c1cf52db44408ff100bda45be2"></a><!-- doxytag: member="viennacl::linalg::mul_add" ref="a148b16c1cf52db44408ff100bda45be2" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, SCALARTYPE alpha, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mul_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = alpha * vec1 + vec2, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6469ec227ee3c0a9f8c9e31d16e80856"></a><!-- doxytag: member="viennacl::linalg::mul_add" ref="a6469ec227ee3c0a9f8c9e31d16e80856" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, scalar&lt; SCALARTYPE &gt; const &amp;alpha, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mul_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = alpha * vec1 + vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first addend. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ab4e344aa136d4221bc2f22c1431a03"></a><!-- doxytag: member="viennacl::linalg::mul_sub" ref="a7ab4e344aa136d4221bc2f22c1431a03" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, scalar&lt; SCALARTYPE &gt; const &amp;alpha, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mul_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = alpha * vec1 - vec2, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector operand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor for the first vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad80ec890c37305239e26131957a60fb"></a><!-- doxytag: member="viennacl::linalg::mult" ref="aad80ec890c37305239e26131957a60fb" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = vec * alpha, where alpha is a cpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd5ba35456dad83b2b92bdc2b975f1de"></a><!-- doxytag: member="viennacl::linalg::mult" ref="abd5ba35456dad83b2b92bdc2b975f1de" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>Computes result = vec * alpha, where alpha is a gpu scalar</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector to be scaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The scaling factor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a773963ad0576dedd6ea9677a964d7eb6"></a><!-- doxytag: member="viennacl::linalg::norm_1" ref="a773963ad0576dedd6ea9677a964d7eb6" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SCALARTYPE viennacl::linalg::norm_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^1-norm of a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a5f13104ad8997fe4eb97717fde2bec1a"></a><!-- doxytag: member="viennacl::linalg::norm_2" ref="a5f13104ad8997fe4eb97717fde2bec1a" args="(viennacl::vector&lt; ScalarType, alignment &gt; const &amp;vector, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; viennacl::vector&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;ScalarType, alignment&gt;, viennacl::op_norm_2 &gt; viennacl::linalg::norm_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; ScalarType, alignment &gt; &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cb58d3e096e8eefd750aee35249765e"></a><!-- doxytag: member="viennacl::linalg::norm_2_impl" ref="a8cb58d3e096e8eefd750aee35249765e" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, scalar&lt; SCALARTYPE &gt; &amp;result, unsigned int NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void norm_2_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the l^2-norm of a vector - implementation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="aed0642dda58cce7ebceffceb2bb1dc7c"></a><!-- doxytag: member="viennacl::linalg::norm_inf" ref="aed0642dda58cce7ebceffceb2bb1dc7c" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SCALARTYPE viennacl::linalg::norm_inf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vcl_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the supremum-norm of a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vcl_vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result </dd></dl>

</div>
</div>
<a class="anchor" id="a0568dee2f2b612e438661eb455cd76c0"></a><!-- doxytag: member="viennacl::linalg::outer_prod" ref="a0568dee2f2b612e438661eb455cd76c0" args="(const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1outer__prod__proxy.html">viennacl::outer_prod_proxy</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt; viennacl::linalg::outer_prod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class for the operation mat += vec1 * vec2^T, i.e. a rank 1 update. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a475332833e58b7d657544f3e40164f9a"></a><!-- doxytag: member="viennacl::linalg::plane_rotation" ref="a475332833e58b7d657544f3e40164f9a" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, SCALARTYPE beta, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::plane_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a plane rotation of two vectors. </p>
<p>Computes (x,y) &lt;- (alpha * x + beta * y, -beta * x + alpha * y) WARNING: For mysterious reasons this simple kernel does not work in double precision and on AMD GPUs...</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>The first transformation coefficient </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beta</em>&nbsp;</td><td>The second transformation coefficient </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1642cbf74be37d2ae455606506dc578"></a><!-- doxytag: member="viennacl::linalg::precondition" ref="aa1642cbf74be37d2ae455606506dc578" args="(MatrixType const &amp;input, LUType &amp;output, ilut_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::precondition </td>
          <td>(</td>
          <td class="paramtype">MatrixType const &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LUType &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ilut_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of a ILU-preconditioner with threshold. </p>
<p>refer to Algorithm 10.6 by Saad's book (1996 edition)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>The input matrix. Type requirements: const_iterator1 for iteration along rows, const_iterator2 for iteration along columns </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>The output matrix. Type requirements: const_iterator1 for iteration along rows, const_iterator2 for iteration along columns and write access via operator() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>An <a class="el" href="classviennacl_1_1linalg_1_1ilut__tag.html" title="A tag for incomplete LU factorization with threshold (ILUT).">ilut_tag</a> in order to dispatch among several other preconditioners. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd380c11fa6a29fc1021e7b60f34dcf1"></a><!-- doxytag: member="viennacl::linalg::prod" ref="acd380c11fa6a29fc1021e7b60f34dcf1" args="(MatrixT const &amp;matrix, VectorT const &amp;vector, typename viennacl::tools::enable_if&lt; viennacl::is_viennacl&lt; typename viennacl::traits::tag_of&lt; MatrixT &gt;::type &gt;::value &gt;::type *dummy=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const MatrixT, const VectorT, viennacl::op_prod &gt; viennacl::linalg::prod </td>
          <td>(</td>
          <td class="paramtype">MatrixT const &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorT const &amp;&nbsp;</td>
          <td class="paramname"> <em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structviennacl_1_1tools_1_1enable__if.html">viennacl::tools::enable_if</a>&lt; <a class="el" href="structviennacl_1_1is__viennacl.html">viennacl::is_viennacl</a>&lt; typename <a class="el" href="structviennacl_1_1traits_1_1tag__of.html">viennacl::traits::tag_of</a>&lt; MatrixT &gt;::type &gt;::value &gt;::type *&nbsp;</td>
          <td class="paramname"> <em>dummy</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a01059b42db0cbb19ac1904bada8329e3"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a01059b42db0cbb19ac1904bada8329e3" args="(const viennacl::transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">viennacl::transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwraps the transposed matrix proxy and forwards to <a class="el" href="namespaceviennacl_1_1linalg.html#ab684949fe77b0db121f62f1f8a0de435" title="Carries out matrix-vector multiplication with a transposed matrix.">trans_prod_impl()</a>. </p>

</div>
</div>
<a class="anchor" id="a24c76630b27107c4d62c9ec981fa920e"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a24c76630b27107c4d62c9ec981fa920e" args="(const viennacl::transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt;const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">viennacl::transposed_matrix_proxy</a>&lt;SCALARTYPE, F, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt;, op_prod &gt; viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">viennacl::transposed_matrix_proxy</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a transposed matrix. </p>
<p>This is used for the convenience expression result = trans(mat) * vec;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The transposed matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab965ea63d68073b56e20470a17c540d3"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="ab965ea63d68073b56e20470a17c540d3" args="(const viennacl::matrix&lt; TYPE, F, ALIGNMENT &gt; &amp;matrix, const viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; TYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaac2c72634061bef5ca4fd29e98e909"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="adaac2c72634061bef5ca4fd29e98e909" args="(const viennacl::coordinate_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac73aba1ff7c252029b1b1566b0760567"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="ac73aba1ff7c252029b1b1566b0760567" args="(const viennacl::compressed_matrix&lt; TYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1compressed__matrix.html">viennacl::compressed_matrix</a>&lt; TYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; TYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bb32bd79aa964e6fd59f48976917678"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a3bb32bd79aa964e6fd59f48976917678" args="(const viennacl::coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, viennacl::op_prod &gt; prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1coordinate__matrix.html">viennacl::coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a>. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a838721b6e2f200516c5a17368b19841a"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a838721b6e2f200516c5a17368b19841a" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;mat, const vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; prod_impl </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication with a <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52ace672f389f46bd2e8ec8440b4dda3"></a><!-- doxytag: member="viennacl::linalg::prod_impl" ref="a52ace672f389f46bd2e8ec8440b4dda3" args="(const viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, unsigned int NUM_THREADS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a proxy class that represents matrix-vector multiplication. </p>
<p>This is used for the convenience expression result = prod(mat, vec);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08b4cf23e757e692a430cadc45e3a6e9"></a><!-- doxytag: member="viennacl::linalg::rank_1_update" ref="a08b4cf23e757e692a430cadc45e3a6e9" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::rank_1_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += vec1 * vec2^T, i.e. a rank 1 update. </p>
<p>Implementation of the convenience expression result += outer_prod(vec1, vec2);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The matrix to be updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a147d5b548e31dc563a257e4745b86ab6"></a><!-- doxytag: member="viennacl::linalg::scaled_rank_1_update" ref="a147d5b548e31dc563a257e4745b86ab6" args="(viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat1, SCALARTYPE val, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::scaled_rank_1_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The implementation of the operation mat += alpha * vec1 * vec2^T, i.e. a scaled rank 1 update. </p>
<p>Implementation of the convenience expression result += alpha * outer_prod(vec1, vec2);</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat1</em>&nbsp;</td><td>The matrix to be updated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The scaling factor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad590c4eadb76eea1a806c3c4c026ba66"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ad590c4eadb76eea1a806c3c4c026ba66" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, gmres_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload of the <a class="el" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve()</a> function using GMRES. Per default, no preconditioner is used. </p>

</div>
</div>
<a class="anchor" id="a76b4d001b76edd2253dc7d3a2852b391"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a76b4d001b76edd2253dc7d3a2852b391" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, gmres_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gmres_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&nbsp;</td>
          <td class="paramname"> <em>precond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the GMRES solver. </p>
<p>Following the algorithm proposed by Walker in "A Simpler GMRES"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precond</em>&nbsp;</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a09ea4f013f48c87c30e8f9013b673d24"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a09ea4f013f48c87c30e8f9013b673d24" args="(const transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;proxy, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const transposed_matrix_proxy&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The transposed system matrix proxy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f5cb80858484131ecb73e867b2bf794"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a9f5cb80858484131ecb73e867b2bf794" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, TAG const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAG const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(mat, vec, some_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa338acd99f7bfac8c0210ab05ecaa09"></a><!-- doxytag: member="viennacl::linalg::solve" ref="aaa338acd99f7bfac8c0210ab05ecaa09" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, viennacl::linalg::upper_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structviennacl_1_1linalg_1_1upper__tag.html">viennacl::linalg::upper_tag</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>The lower triangular sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d7d0a974cd68a51c4d5c4b7a16c1d28"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a6d7d0a974cd68a51c4d5c4b7a16c1d28" args="(compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;L, const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;vec, const viennacl::linalg::unit_lower_tag &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, VEC_ALIGNMENT&gt; viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; SCALARTYPE, VEC_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structviennacl_1_1linalg_1_1unit__lower__tag.html">viennacl::linalg::unit_lower_tag</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functions for result = solve(trans(mat), vec, unit_lower_tag()); Creates a temporary result vector and forwards the request to <a class="el" href="namespaceviennacl_1_1linalg.html#ae927d6abe755d74744ec5ee9bd191210" title="Inplace solution of a lower triangular compressed_matrix with unit diagonal. Typically...">inplace_solve()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>L</em>&nbsp;</td><td>The lower triangular sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The load vector, where the solution is directly written to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Dispatch tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adefd0a97aaeaa8eb75097847443c6ee1"></a><!-- doxytag: member="viennacl::linalg::solve" ref="adefd0a97aaeaa8eb75097847443c6ee1" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&nbsp;</td>
          <td class="paramname"> <em>precond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the preconditioned conjugate gradient solver. </p>
<p>Following Algorithm 9.1 in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precond</em>&nbsp;</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a6bc45bf37430c67d6a32ed8e10e77e94"></a><!-- doxytag: member="viennacl::linalg::solve" ref="a6bc45bf37430c67d6a32ed8e10e77e94" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, cg_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cg_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the conjugate gradient solver without preconditioner. </p>
<p>Following the algorithm in the book by Y. Saad "Iterative Methods for sparse linear systems"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="adbcb7f6a46ca520d01f6ce53f83f5069"></a><!-- doxytag: member="viennacl::linalg::solve" ref="adbcb7f6a46ca520d01f6ce53f83f5069" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag, PreconditionerType const &amp;precond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PreconditionerType const &amp;&nbsp;</td>
          <td class="paramname"> <em>precond</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the preconditioned stabilized Bi-conjugate gradient solver. </p>
<p>Following the description of the unpreconditioned case in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precond</em>&nbsp;</td><td>A preconditioner. Precondition operation is done via member function apply() </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="ab50f87d195eb82ddbe5ce910e914bc55"></a><!-- doxytag: member="viennacl::linalg::solve" ref="ab50f87d195eb82ddbe5ce910e914bc55" args="(const MatrixType &amp;matrix, VectorType const &amp;rhs, bicgstab_tag const &amp;tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType viennacl::linalg::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bicgstab_tag const &amp;&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the stabilized Bi-conjugate gradient solver. </p>
<p>Following the description in "Iterative Methods for Sparse Linear Systems" by Y. Saad</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The system matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The load vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>Solver configuration tag </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The result vector </dd></dl>

</div>
</div>
<a class="anchor" id="a99aa3a3f1e37472564b2b73c61231a37"></a><!-- doxytag: member="viennacl::linalg::sub" ref="a99aa3a3f1e37472564b2b73c61231a37" args="(const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtraction of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved. </p>
<p>result = vec1 - vec2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second operand. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab684949fe77b0db121f62f1f8a0de435"></a><!-- doxytag: member="viennacl::linalg::trans_prod_impl" ref="ab684949fe77b0db121f62f1f8a0de435" args="(const viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;vec, viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::linalg::trans_prod_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix.html">viennacl::matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Carries out matrix-vector multiplication with a transposed matrix. </p>
<p>Implementation of the convenience expression result = trans(mat) * vec;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>The matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>The vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The result vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>Number of threads per work group. Can be used for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 8 13:48:32 2010 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
