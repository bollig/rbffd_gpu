<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: viennacl::tools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceviennacl.html">viennacl</a>::<a class="el" href="namespaceviennacl_1_1tools.html">tools</a>
  </div>
</div>
<div class="contents">
<h1>viennacl::tools Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r.html">MATRIX_ITERATOR_INCREMENTER</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1tools_1_1const__sparse__matrix__adapted__iterator.html">const_sparse_matrix_adapted_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A const iterator for sparse matrices of type std::vector&lt;std::map&lt;unsigned int, SCALARTYPE&gt; &gt;  <a href="classviennacl_1_1tools_1_1const__sparse__matrix__adapted__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1tools_1_1const__sparse__matrix__adapter.html">const_sparse_matrix_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adapts a constant sparse matrix type made up from std::vector&lt;std::map&lt;unsigned int, SCALARTYPE&gt; &gt; to basic ublas-compatibility.  <a href="classviennacl_1_1tools_1_1const__sparse__matrix__adapter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapted__iterator.html">sparse_matrix_adapted_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A non-const iterator for sparse matrices of type std::vector&lt;std::map&lt;unsigned int, SCALARTYPE&gt; &gt;  <a href="classviennacl_1_1tools_1_1sparse__matrix__adapted__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html">sparse_matrix_adapter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adapts a non-const sparse matrix type made up from std::vector&lt;std::map&lt;unsigned int, SCALARTYPE&gt; &gt; to basic ublas-compatibility.  <a href="classviennacl_1_1tools_1_1sparse__matrix__adapter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r_3_01viennacl_1bca92c58b35c5ea472fa723e2dbcd14a.html">MATRIX_ITERATOR_INCREMENTER&lt; viennacl::row_iteration, viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_m_a_t_r_i_x___i_t_e_r_a_t_o_r___i_n_c_r_e_m_e_n_t_e_r_3_01viennacl_1c86a2c2a13c1f4853c9afb7871a47194.html">MATRIX_ITERATOR_INCREMENTER&lt; viennacl::col_iteration, viennacl::matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1enable__if_3_01false_00_01_t_01_4.html">enable_if&lt; false, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t.html">CHECK_SCALAR_TEMPLATE_ARGUMENT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A guard that checks whether the floating point type of GPU types is either float or double.  <a href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t_3_01float_01_4.html">CHECK_SCALAR_TEMPLATE_ARGUMENT&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t_3_01double_01_4.html">CHECK_SCALAR_TEMPLATE_ARGUMENT&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_o_n_s_t___r_e_m_o_v_e_r.html">CONST_REMOVER</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the const qualifier from a type.  <a href="structviennacl_1_1tools_1_1_c_o_n_s_t___r_e_m_o_v_e_r.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_o_n_s_t___r_e_m_o_v_e_r_3_01const_01_t_01_4.html">CONST_REMOVER&lt; const T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r___i_m_p_l.html">VECTOR_EXTRACTOR_IMPL</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the vector type from one of the two arguments. Used for the <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> type.  <a href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r___i_m_p_l.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r___i_m_p_l_3_01_l_h_s_00_01viennacl_1882605388412d3966461746c5b88eabd.html">VECTOR_EXTRACTOR_IMPL&lt; LHS, viennacl::vector&lt; ScalarType, A &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r___i_m_p_l_3_01viennacl_1_1vector_3_06f3e35bbd0fe5f0dc2637861e914c68d.html">VECTOR_EXTRACTOR_IMPL&lt; viennacl::vector&lt; ScalarType, A &gt;, RHS &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r___i_m_p_l_3_01viennacl_1_1vector_3_06c4b94a78124174dcdfa8958e33b87aa.html">VECTOR_EXTRACTOR_IMPL&lt; viennacl::vector&lt; ScalarType, A &gt;, viennacl::vector&lt; ScalarType, A &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r.html">VECTOR_EXTRACTOR</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___s_i_z_e___d_e_d_u_c_e_r.html">VECTOR_SIZE_DEDUCER</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deduces the size of the resulting vector represented by a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> from the operands.  <a href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___s_i_z_e___d_e_d_u_c_e_r.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___s_i_z_e___d_e_d_u_c_e_r_3_01_matrix_type_00_01viennacl87de6897a7f35020b3e0547215bfded5.html">VECTOR_SIZE_DEDUCER&lt; MatrixType, viennacl::vector&lt; ScalarType, A &gt;, viennacl::op_prod &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___s_i_z_e___d_e_d_u_c_e_r_3_01_matrix_type_00_01const_019fd85c1fb09e11c5d9ac8cd5a9aaad49.html">VECTOR_SIZE_DEDUCER&lt; MatrixType, const viennacl::vector&lt; ScalarType, A &gt;, viennacl::op_prod &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_p_u___s_c_a_l_a_r___t_y_p_e___d_e_d_u_c_e_r.html">CPU_SCALAR_TYPE_DEDUCER</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the cpu scalar type from a type, including a GPU type like viennacl::scalar&lt;T&gt;  <a href="structviennacl_1_1tools_1_1_c_p_u___s_c_a_l_a_r___t_y_p_e___d_e_d_u_c_e_r.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tools_1_1_c_p_u___s_c_a_l_a_r___t_y_p_e___d_e_d_u_c_e_r_3_01viennacl_1_1scalar_3_01_t_01_4_01_4.html">CPU_SCALAR_TYPE_DEDUCER&lt; viennacl::scalar&lt; T &gt; &gt;</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html#ae0476afc58ea44d5d67ffe7384f59389">readTextFromFile</a> (const std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a text from a file into a std::string.  <a href="#ae0476afc58ea44d5d67ffe7384f59389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html#aabca73e564ff14ed639cfe0a94c88cf8">strReplace</a> (const std::string &amp;text, std::string to_search, std::string to_replace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of a substring by another stringstream.  <a href="#aabca73e564ff14ed639cfe0a94c88cf8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">INT_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html#a8422b8f21a3e19bc1dcd4cc3a8447227">roundUpToNextMultiple</a> (INT_TYPE to_reach, INT_TYPE base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rounds an integer to the next multiple of another integer.  <a href="#a8422b8f21a3e19bc1dcd4cc3a8447227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html#ada2c4ac3a07c38baf760b2b24d0a9b60">make_double_kernel</a> (std::string const &amp;source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a double precision kernel out of a single precision kernel.  <a href="#ada2c4ac3a07c38baf760b2b24d0a9b60"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ada2c4ac3a07c38baf760b2b24d0a9b60"></a><!-- doxytag: member="viennacl::tools::make_double_kernel" ref="ada2c4ac3a07c38baf760b2b24d0a9b60" args="(std::string const &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viennacl::tools::make_double_kernel </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a double precision kernel out of a single precision kernel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The double precision kernel </dd></dl>

</div>
</div>
<a class="anchor" id="ae0476afc58ea44d5d67ffe7384f59389"></a><!-- doxytag: member="viennacl::tools::readTextFromFile" ref="ae0476afc58ea44d5d67ffe7384f59389" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viennacl::tools::readTextFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a text from a file into a std::string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The text read from the file </dd></dl>

</div>
</div>
<a class="anchor" id="a8422b8f21a3e19bc1dcd4cc3a8447227"></a><!-- doxytag: member="viennacl::tools::roundUpToNextMultiple" ref="a8422b8f21a3e19bc1dcd4cc3a8447227" args="(INT_TYPE to_reach, INT_TYPE base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT_TYPE viennacl::tools::roundUpToNextMultiple </td>
          <td>(</td>
          <td class="paramtype">INT_TYPE&nbsp;</td>
          <td class="paramname"> <em>to_reach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT_TYPE&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rounds an integer to the next multiple of another integer. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>INT_TYPE</em>&nbsp;</td><td>The integer type </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to_reach</em>&nbsp;</td><td>The integer to be rounded up (ceil operation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>The base </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The smallest multiple of 'base' such that to_reach &lt;= base </dd></dl>

</div>
</div>
<a class="anchor" id="aabca73e564ff14ed639cfe0a94c88cf8"></a><!-- doxytag: member="viennacl::tools::strReplace" ref="aabca73e564ff14ed639cfe0a94c88cf8" args="(const std::string &amp;text, std::string to_search, std::string to_replace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string viennacl::tools::strReplace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>to_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>to_replace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of a substring by another stringstream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>The string to search in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to_search</em>&nbsp;</td><td>The substring to search for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to_replace</em>&nbsp;</td><td>The replacement for found substrings </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The resulting string </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 8 13:48:32 2010 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
