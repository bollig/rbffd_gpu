#ifndef VIENNACL_LINALG_KERNELS_RAND_SOURCE_HPP_
#define VIENNACL_LINALG_KERNELS_RAND_SOURCE_HPP_
//Automatically generated file from auxiliary-directory, do not edit manually!
/** @file rand_source.h
 *  @brief OpenCL kernel source file, generated automatically from scripts in auxiliary/. */
namespace viennacl
{
 namespace linalg
 {
  namespace kernels
  {
const char * const rand_align1__mwc64x = 
"/*\n"
"Part of MWC64X by David Thomas, dt10@imperial.ac.uk\n"
"This is provided under BSD, full license is with the main package.\n"
"See http://www.doc.ic.ac.uk/~dt10/research\n"
"*/\n"
"// Pre: a<M, b<M\n"
"// Post: r=(a+b) mod M\n"
"ulong MWC_AddMod64(ulong a, ulong b, ulong M)\n"
"{\n"
"        ulong v=a+b;\n"
"        if( (v>=M) || (v<a) )\n"
"                v=v-M;\n"
"        return v;\n"
"}\n"
"// Pre: a<M,b<M\n"
"// Post: r=(a*b) mod M\n"
"// This could be done more efficently, but it is portable, and should\n"
"// be easy to understand. It can be replaced with any of the better\n"
"// modular multiplication algorithms (for example if you know you have\n"
"// double precision available or something).\n"
"ulong MWC_MulMod64(ulong a, ulong b, ulong M)\n"
"{\n"
"        ulong r=0;\n"
"        while(a!=0){\n"
"                if(a&1)\n"
"                        r=MWC_AddMod64(r,b,M);\n"
"                b=MWC_AddMod64(b,b,M);\n"
"                a=a>>1;\n"
"        }\n"
"        return r;\n"
"}\n"
"// Pre: a<M, e>=0\n"
"// Post: r=(a^b) mod M\n"
"// This takes at most ~64^2 modular additions, so probably about 2^15 or so instructions on\n"
"// most architectures\n"
"ulong MWC_PowMod64(ulong a, ulong e, ulong M)\n"
"{\n"
"        ulong sqr=a, acc=1;\n"
"        while(e!=0){\n"
"                if(e&1)\n"
"                        acc=MWC_MulMod64(acc,sqr,M);\n"
"                sqr=MWC_MulMod64(sqr,sqr,M);\n"
"                e=e>>1;\n"
"        }\n"
"        return acc;\n"
"}\n"
"uint2 MWC_SkipImpl_Mod64(uint2 curr, ulong A, ulong M, ulong distance)\n"
"{\n"
"        ulong m=MWC_PowMod64(A, distance, M);\n"
"        ulong x=curr.x*(ulong)A+curr.y;\n"
"        x=MWC_MulMod64(x, m, M);\n"
"        return (uint2)((uint)(x/A), (uint)(x%A));\n"
"}\n"
"uint2 MWC_SeedImpl_Mod64(ulong A, ulong M, uint vecSize, uint vecOffset, ulong streamBase, ulong streamGap)\n"
"{\n"
"        // This is an arbitrary constant for starting LCG jumping from. I didn't\n"
"        // want to start from 1, as then you end up with the two or three first values\n"
"        // being a bit poor in ones - once you've decided that, one constant is as\n"
"        // good as any another. There is no deep mathematical reason for it, I just\n"
"        // generated a random number.\n"
"        enum{ MWC_BASEID = 4077358422479273989UL };\n"
"        ulong dist=streamBase + (get_global_id(0)*vecSize+vecOffset)*streamGap;\n"
"        ulong m=MWC_PowMod64(A, dist, M);\n"
"        ulong x=MWC_MulMod64(MWC_BASEID, m, M);\n"
"        return (uint2)((uint)(x/A), (uint)(x%A));\n"
"}\n"
"//! Represents the state of a particular generator\n"
"typedef struct{ uint x; uint c; } mwc64x_state_t;\n"
"enum{ MWC64X_A = 4294883355U };\n"
"enum{ MWC64X_M = 18446383549859758079UL };\n"
"void MWC64X_Step(mwc64x_state_t *s)\n"
"{\n"
"        uint X=s->x, C=s->c;\n"
"        uint Xn=MWC64X_A*X+C;\n"
"        uint carry=(uint)(Xn<C);				// The (Xn<C) will be zero or one for scalar\n"
"        uint Cn=mad_hi(MWC64X_A,X,carry);\n"
"        s->x=Xn;\n"
"        s->c=Cn;\n"
"}\n"
"void MWC64X_Skip(mwc64x_state_t *s, ulong distance)\n"
"{\n"
"        uint2 tmp=MWC_SkipImpl_Mod64((uint2)(s->x,s->c), MWC64X_A, MWC64X_M, distance);\n"
"        s->x=tmp.x;\n"
"        s->c=tmp.y;\n"
"}\n"
"void MWC64X_SeedStreams(mwc64x_state_t *s, ulong baseOffset, ulong perStreamOffset)\n"
"{\n"
"        uint2 tmp=MWC_SeedImpl_Mod64(MWC64X_A, MWC64X_M, 1, 0, baseOffset, perStreamOffset);\n"
"        s->x=tmp.x;\n"
"        s->c=tmp.y;\n"
"}\n"
"//! Return a 32-bit integer in the range [0..2^32)\n"
"uint MWC64X_NextUint(mwc64x_state_t *s)\n"
"{\n"
"        uint res=s->x ^ s->c;\n"
"        MWC64X_Step(s);\n"
"        return res;\n"
"}\n"
"//! Represents the state of a particular generator\n"
"typedef struct{ uint2 x; uint2 c; } mwc64xvec2_state_t;\n"
"enum{ MWC64XVEC2_A = 4294883355U };\n"
"enum{ MWC64XVEC2_M = 18446383549859758079UL };\n"
"void MWC64XVEC2_Step(mwc64xvec2_state_t *s)\n"
"{\n"
"        uint2 X=s->x, C=s->c;\n"
"        uint2 Xn=MWC64XVEC2_A*X+C;\n"
"        // Note that vector comparisons return -1 for true, so we have to do this negation\n"
"        // I would hope that the compiler would do something sensible if possible...\n"
"        uint2 carry=as_uint2(-(Xn<C));\n"
"        uint2 Cn=mad_hi((uint2)MWC64XVEC2_A,X,carry);\n"
"        s->x=Xn;\n"
"        s->c=Cn;\n"
"}\n"
"void MWC64XVEC2_Skip(mwc64xvec2_state_t *s, ulong distance)\n"
"{\n"
"        uint2 tmp0=MWC_SkipImpl_Mod64((uint2)(s->x.s0,s->c.s0), MWC64XVEC2_A, MWC64XVEC2_M, distance);\n"
"        uint2 tmp1=MWC_SkipImpl_Mod64((uint2)(s->x.s1,s->c.s1), MWC64XVEC2_A, MWC64XVEC2_M, distance);\n"
"        s->x=(uint2)(tmp0.x, tmp1.x);\n"
"        s->c=(uint2)(tmp0.y, tmp1.y);\n"
"}\n"
"void MWC64XVEC2_SeedStreams(mwc64xvec2_state_t *s, ulong baseOffset, ulong perStreamOffset)\n"
"{\n"
"        uint2 tmp0=MWC_SeedImpl_Mod64(MWC64XVEC2_A, MWC64XVEC2_M, 2, 0, baseOffset, perStreamOffset);\n"
"        uint2 tmp1=MWC_SeedImpl_Mod64(MWC64XVEC2_A, MWC64XVEC2_M, 2, 1, baseOffset, perStreamOffset);\n"
"        s->x=(uint2)(tmp0.x, tmp1.x);\n"
"        s->c=(uint2)(tmp0.y, tmp1.y);\n"
"}\n"
"//! Return a 32-bit integer in the range [0..2^32)\n"
"uint2 MWC64XVEC2_NextUint2(mwc64xvec2_state_t *s)\n"
"{\n"
"        uint2 res=s->x ^ s->c;\n"
"        MWC64XVEC2_Step(s);\n"
"        return res;\n"
"}\n"
"//! Represents the state of a particular generator\n"
"typedef struct{ uint4 x; uint4 c; } mwc64xvec4_state_t;\n"
"enum{ MWC64XVEC4_A = 4294883355U };\n"
"enum{ MWC64XVEC4_M = 18446383549859758079UL };\n"
"void MWC64XVEC4_Step(mwc64xvec4_state_t *s)\n"
"{\n"
"        uint4 X=s->x, C=s->c;\n"
"        uint4 Xn=MWC64XVEC4_A*X+C;\n"
"        // Note that vector comparisons return -1 for true, so we have to do this odd negation\n"
"        // I would hope that the compiler would do something sensible if possible...\n"
"        uint4 carry=as_uint4(-(Xn<C));\n"
"        uint4 Cn=mad_hi((uint4)MWC64XVEC4_A,X,carry);\n"
"        s->x=Xn;\n"
"        s->c=Cn;\n"
"}\n"
"void MWC64XVEC4_Skip(mwc64xvec4_state_t *s, ulong distance)\n"
"{\n"
"        uint2 tmp0=MWC_SkipImpl_Mod64((uint2)(s->x.s0,s->c.s0), MWC64XVEC4_A, MWC64XVEC4_M, distance);\n"
"        uint2 tmp1=MWC_SkipImpl_Mod64((uint2)(s->x.s1,s->c.s1), MWC64XVEC4_A, MWC64XVEC4_M, distance);\n"
"        uint2 tmp2=MWC_SkipImpl_Mod64((uint2)(s->x.s2,s->c.s2), MWC64XVEC4_A, MWC64XVEC4_M, distance);\n"
"        uint2 tmp3=MWC_SkipImpl_Mod64((uint2)(s->x.s3,s->c.s3), MWC64XVEC4_A, MWC64XVEC4_M, distance);\n"
"        s->x=(uint4)(tmp0.x, tmp1.x, tmp2.x, tmp3.x);\n"
"        s->c=(uint4)(tmp0.y, tmp1.y, tmp2.y, tmp3.y);\n"
"}\n"
"void MWC64XVEC4_SeedStreams(mwc64xvec4_state_t *s, ulong baseOffset, ulong perStreamOffset)\n"
"{\n"
"        uint2 tmp0=MWC_SeedImpl_Mod64(MWC64XVEC4_A, MWC64XVEC4_M, 4, 0, baseOffset, perStreamOffset);\n"
"        uint2 tmp1=MWC_SeedImpl_Mod64(MWC64XVEC4_A, MWC64XVEC4_M, 4, 1, baseOffset, perStreamOffset);\n"
"        uint2 tmp2=MWC_SeedImpl_Mod64(MWC64XVEC4_A, MWC64XVEC4_M, 4, 2, baseOffset, perStreamOffset);\n"
"        uint2 tmp3=MWC_SeedImpl_Mod64(MWC64XVEC4_A, MWC64XVEC4_M, 4, 3, baseOffset, perStreamOffset);\n"
"        s->x=(uint4)(tmp0.x, tmp1.x, tmp2.x, tmp3.x);\n"
"        s->c=(uint4)(tmp0.y, tmp1.y, tmp2.y, tmp3.y);\n"
"}\n"
"//! Return a 32-bit integer in the range [0..2^32)\n"
"uint4 MWC64XVEC4_NextUint4(mwc64xvec4_state_t *s)\n"
"{\n"
"        uint4 res=s->x ^ s->c;\n"
"        MWC64XVEC4_Step(s);\n"
"        return res;\n"
"}\n"
"//! Represents the state of a particular generator\n"
"typedef struct{ uint8 x; uint8 c; } mwc64xvec8_state_t;\n"
"enum{ MWC64XVEC8_A = 4294883355U };\n"
"enum{ MWC64XVEC8_M = 18446383549859758079UL };\n"
"void MWC64XVEC8_Step(mwc64xvec8_state_t *s)\n"
"{\n"
"        uint8 X=s->x, C=s->c;\n"
"        uint8 Xn=MWC64XVEC8_A*X+C;\n"
"        // Note that vector comparisons return -1 for true, so we have to do this odd negation\n"
"        // I would hope that the compiler would do something sensible if possible...\n"
"        uint8 carry=as_uint8(-(Xn<C));\n"
"        uint8 Cn=mad_hi((uint8)MWC64XVEC8_A,X,carry);\n"
"        s->x=Xn;\n"
"        s->c=Cn;\n"
"}\n"
"void MWC64XVEC8_Skip(mwc64xvec8_state_t *s, ulong distance)\n"
"{\n"
"        uint2 tmp0=MWC_SkipImpl_Mod64((uint2)(s->x.s0,s->c.s0), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp1=MWC_SkipImpl_Mod64((uint2)(s->x.s1,s->c.s1), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp2=MWC_SkipImpl_Mod64((uint2)(s->x.s2,s->c.s2), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp3=MWC_SkipImpl_Mod64((uint2)(s->x.s3,s->c.s3), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp4=MWC_SkipImpl_Mod64((uint2)(s->x.s4,s->c.s4), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp5=MWC_SkipImpl_Mod64((uint2)(s->x.s5,s->c.s5), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp6=MWC_SkipImpl_Mod64((uint2)(s->x.s6,s->c.s6), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        uint2 tmp7=MWC_SkipImpl_Mod64((uint2)(s->x.s7,s->c.s7), MWC64XVEC8_A, MWC64XVEC8_M, distance);\n"
"        s->x=(uint8)(tmp0.x, tmp1.x, tmp2.x, tmp3.x, tmp4.x, tmp5.x, tmp6.x, tmp7.x);\n"
"        s->c=(uint8)(tmp0.y, tmp1.y, tmp2.y, tmp3.y, tmp4.y, tmp5.y, tmp6.y, tmp7.y);\n"
"}\n"
"void MWC64XVEC8_SeedStreams(mwc64xvec8_state_t *s, ulong baseOffset, ulong perStreamOffset)\n"
"{\n"
"        uint2 tmp0=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 0, baseOffset, perStreamOffset);\n"
"        uint2 tmp1=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 1, baseOffset, perStreamOffset);\n"
"        uint2 tmp2=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 2, baseOffset, perStreamOffset);\n"
"        uint2 tmp3=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 3, baseOffset, perStreamOffset);\n"
"        uint2 tmp4=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 4, baseOffset, perStreamOffset);\n"
"        uint2 tmp5=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 5, baseOffset, perStreamOffset);\n"
"        uint2 tmp6=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 6, baseOffset, perStreamOffset);\n"
"        uint2 tmp7=MWC_SeedImpl_Mod64(MWC64XVEC8_A, MWC64XVEC8_M, 8, 7, baseOffset, perStreamOffset);\n"
"        s->x=(uint8)(tmp0.x, tmp1.x, tmp2.x, tmp3.x, tmp4.x, tmp5.x, tmp6.x, tmp7.x);\n"
"        s->c=(uint8)(tmp0.y, tmp1.y, tmp2.y, tmp3.y, tmp4.y, tmp5.y, tmp6.y, tmp7.y);\n"
"}\n"
"//! Return a 32-bit integer in the range [0..2^32)\n"
"uint8 MWC64XVEC8_NextUint8(mwc64xvec8_state_t *s)\n"
"{\n"
"        uint8 res=s->x ^ s->c;\n"
"        MWC64XVEC8_Step(s);\n"
"        return res;\n"
"}\n"
; //rand_align1__mwc64x

const char * const rand_align1_dump_gaussian = 
"// Dump random gaussian variables into the vector\n"
"__kernel void dump_gaussian(__global float *data, uint start, uint size, float mu, float sigma, uint baseOffset)\n"
"{\n"
"    unsigned int i = 2*get_global_id(0);\n"
"    if(i<size){\n"
"        const ulong MAX = 0xFFFF;\n"
"        mwc64xvec2_state_t rng;\n"
"        MWC64XVEC2_SeedStreams(&rng, baseOffset, 2);\n"
"        __global float *dest=data+start;\n"
"        uint2 x=MWC64XVEC2_NextUint2(&rng);\n"
"        float val1 = (x.s0 & MAX) / (float)MAX;\n"
"        float val2 = (x.s1 & MAX) / (float)MAX;\n"
"        float z1 = sqrt(-2*log(val1))*cos(2*M_PI*val2);\n"
"        float z2 = sqrt(-2*log(val1))*sin(2*M_PI*val2);\n"
"        dest[i] = mu + sigma*z1;\n"
"        if(i+1<size) dest[i+1] = mu + sigma*z2;\n"
"    }\n"
"}\n"
; //rand_align1_dump_gaussian

const char * const rand_align1_dump_uniform = 
"// Dump uniform random variable into the given vector\n"
"__kernel void dump_uniform(__global float *data, uint start, uint size, float a, float b, uint baseOffset)\n"
"{\n"
"      unsigned int i = get_global_id(0);\n"
"      if(i<size){\n"
"          const ulong MAX = 0xFFFF;\n"
"          mwc64x_state_t rng;\n"
"          MWC64X_SeedStreams(&rng, baseOffset, 1);\n"
"          __global float *dest=data+start;\n"
"          uint x=MWC64X_NextUint(&rng);\n"
"          float val = (x&MAX)/(float)MAX;\n"
"          float s = (b-a);\n"
"          dest[i]= a + s*val;\n"
"      }\n"
"}\n"
; //rand_align1_dump_uniform

  }  //namespace kernels
 }  //namespace linalg
}  //namespace viennacl
#endif

