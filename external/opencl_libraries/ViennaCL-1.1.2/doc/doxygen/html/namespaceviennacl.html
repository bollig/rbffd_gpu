<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: viennacl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>viennacl Namespace Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1io.html">io</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">ocl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">tools</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">traits</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format.  <a href="classviennacl_1_1compressed__matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row and column indices and val denotes the entry.  <a href="classviennacl_1_1coordinate__matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__none.html">tag_none</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__mtl4.html">tag_mtl4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__eigen.html">tag_eigen</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__stl.html">tag_stl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__mtl4.html">is_mtl4</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__mtl4.html">tag_mtl4</a>.  <a href="structviennacl_1_1is__mtl4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__mtl4_3_01viennacl_1_1tag__mtl4_01_4.html">is_mtl4&lt; viennacl::tag_mtl4 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__eigen.html">is_eigen</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__eigen.html">tag_eigen</a>.  <a href="structviennacl_1_1is__eigen.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__eigen_3_01viennacl_1_1tag__eigen_01_4.html">is_eigen&lt; viennacl::tag_eigen &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas.html">is_ublas</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a>.  <a href="structviennacl_1_1is__ublas.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas_3_01viennacl_1_1tag__ublas_01_4.html">is_ublas&lt; viennacl::tag_ublas &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__stl.html">is_stl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a>.  <a href="structviennacl_1_1is__stl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__stl_3_01viennacl_1_1tag__stl_01_4.html">is_stl&lt; viennacl::tag_stl &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl.html">is_viennacl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a>.  <a href="structviennacl_1_1is__viennacl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl_3_01viennacl_1_1tag__viennacl_01_4.html">is_viennacl&lt; viennacl::tag_viennacl &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1column__major.html">column_major</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy for scalar expressions (e.g. from inner vector products).  <a href="classviennacl_1_1scalar__expression.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar.html">scalar</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type like float or double.  <a href="classviennacl_1_1scalar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1entry__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An expression template class that represents a binary operation that yields a vector.  <a href="classviennacl_1_1vector__expression.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  <a href="classviennacl_1_1const__vector__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!  <a href="classviennacl_1_1vector__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html">vector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::vector.  <a href="classviennacl_1_1vector.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU).  <a href="#a5684964ce1519c88a443aa14be9428f0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a25d1118aadbe1e6cb69b70df35f94763">copy</a> (const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#a25d1118aadbe1e6cb69b70df35f94763"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6b202ebcc6108940a59881c42f3d86da">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a6b202ebcc6108940a59881c42f3d86da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8a0feeb7a31a31f45e1d014512758fe6">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a8a0feeb7a31a31f45e1d014512758fe6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a87f711ebb1d8fd6435d31f1841f9cfaf">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU).  <a href="#a87f711ebb1d8fd6435d31f1841f9cfaf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab4fb2cd615454e656202d5d6f1a54483">copy</a> (const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#ab4fb2cd615454e656202d5d6f1a54483"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab2ea05f107d5ec7f31214a2898ccbe08">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#ab2ea05f107d5ec7f31214a2898ccbe08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae1d2b8aa5bf56f7479a66d51713708d2">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#ae1d2b8aa5bf56f7479a66d51713708d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afb1db189fa5cd8ee4a8222d8b87f3ab0">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#afb1db189fa5cd8ee4a8222d8b87f3ab0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af638a30a9dd2001143b4c92072c76d48">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#af638a30a9dd2001143b4c92072c76d48"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9164bd549b986f39b035c24a426869b9">copy</a> (<a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy (parts of a) GPU vector to another GPU vector.  <a href="#a9164bd549b986f39b035c24a426869b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abc6cd55d2644b2c6b5f69cb733fb6f24">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#abc6cd55d2644b2c6b5f69cb733fb6f24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab7b70e43299f65259cc61849f9ad997c">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; LHS, RHS, OP &gt; &amp;expr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#ab7b70e43299f65259cc61849f9ad997c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, <br class="typebreak"/>
ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; SCALARTYPE, F, ALIGNMENT &gt;<br class="typebreak"/>
, op_trans &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a95013bc545c5642ccfbd8c5ceb3b885c">trans</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a95013bc545c5642ccfbd8c5ceb3b885c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4bd43fae5bc2cdd71e384d1794527add">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU).  <a href="#a4bd43fae5bc2cdd71e384d1794527add"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a376734f00b48e1c773c82eb9290c1f08">copy</a> (const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU).  <a href="#a376734f00b48e1c773c82eb9290c1f08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99">fast_copy</a> (SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU.  <a href="#ab917c8f27a8f1cf7b8d6be54989efb99"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0b4ced508c064fe8b45f437b538ed2ca">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a0b4ced508c064fe8b45f437b538ed2ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename A1 , typename A2 , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a72359f3759c0067ac956d01c36651f9a">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a72359f3759c0067ac956d01c36651f9a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a2fae23064f21ff285672845e82545fd2">fast_copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a2fae23064f21ff285672845e82545fd2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_SCALAR , typename SCALARTYPE , unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;<br class="typebreak"/>
, op_prod &gt;, const SCALARTYPE, <br class="typebreak"/>
op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a45c8d32b7d99c62cdb10899d70e7bad9">operator*</a> (const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; &amp;proxy, CPU_SCALAR val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_SCALAR , typename SCALARTYPE , unsigned int VA1, unsigned int VA2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, VA1 &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
VA2 &gt;, op_prod &gt;, const <br class="typebreak"/>
SCALARTYPE, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae29e41dc09ce774a0082eb52bdcb81e7">operator*</a> (CPU_SCALAR val, <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA1 &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA2 &gt;, op_prod &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5b3d6b04f0d7dac6aec4342e0b37656e">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows to directly print the value of a scalar to an output stream.  <a href="#a5b3d6b04f0d7dac6aec4342e0b37656e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab4ea659d4449111a55f748c34226f305">operator&gt;&gt;</a> (std::istream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows to directly read a value of a scalar from an input stream.  <a href="#ab4ea659d4449111a55f748c34226f305"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7953e64a62d2209621a3f4a505dc9f9e">copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a7953e64a62d2209621a3f4a505dc9f9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6713b60b19010992ea611ef7ecd4fdf2">copy</a> (const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a6713b60b19010992ea611ef7ecd4fdf2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#afb5884675d2f3a9ca1a57a3a722aa78a">copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#afb5884675d2f3a9ca1a57a3a722aa78a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9c694a91cf3e54637ed6a05ab7d9ce75">fast_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a9c694a91cf3e54637ed6a05ab7d9ce75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aad3621936e6071d2777aae22a5f891ec">fast_copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#aad3621936e6071d2777aae22a5f891ec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a12da6187594db18ae7aa4874e1ad3f1d">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0d4fd919fa235b1c7dabd0049740e774">copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a0d4fd919fa235b1c7dabd0049740e774"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9250bb8c996f6eab600899146e0cbf26">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a9250bb8c996f6eab600899146e0cbf26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#af7146b5952b3532c74728adc05d4de55">fast_copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#af7146b5952b3532c74728adc05d4de55"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT_SRC, unsigned int ALIGNMENT_DEST&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ad823fb30fd180da375a1e09d56c0a1b8">copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;gpu_dest_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());.  <a href="#ad823fb30fd180da375a1e09d56c0a1b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5e572599ddbae8812154538849fa707c">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output stream. Output format is ublas compatible.  <a href="#a5e572599ddbae8812154538849fa707c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0c01dfab44c6d3849f7d0eac55539142">swap</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the contents of two vectors, data is copied.  <a href="#a0c01dfab44c6d3849f7d0eac55539142"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a976181b1f6aa698b64a4746f0949fce0">fast_swap</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v1, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied.  <a href="#a976181b1f6aa698b64a4746f0949fce0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;, const <br class="typebreak"/>
SCALARTYPE, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa60d7cda126efd13c3413453606850b7">operator*</a> (SCALARTYPE const &amp;value, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector.  <a href="#aa60d7cda126efd13c3413453606850b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3b34a609403378a81c3a2589a5418077">operator*</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;value, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a ViennaCL scalar (float or double) and v1 is a ViennaCL vector.  <a href="#a3b34a609403378a81c3a2589a5418077"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aae3143a0fbb9e586b489cea90acf6659">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the addition of two vector expressions.  <a href="#aae3143a0fbb9e586b489cea90acf6659"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a77d42d098f9212ba53487deb6ddacf57">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the subtraction of two vector expressions.  <a href="#a77d42d098f9212ba53487deb6ddacf57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A, typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0808ef51d9a2d2e1ecbed3d4b63e159f">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the addition of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then added to vec2.  <a href="#a0808ef51d9a2d2e1ecbed3d4b63e159f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A, typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae00e47f8124b08cbeb8b7fc9ff537081">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then added to vec2.  <a href="#ae00e47f8124b08cbeb8b7fc9ff537081"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a00f47d8ad32713f98c6979c245b88cdb">operator*</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the right.  <a href="#a00f47d8ad32713f98c6979c245b88cdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3aeb5b431a9c6d0b3af24a1513e8e9ad">operator/</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then divided by alpha.  <a href="#a3aeb5b431a9c6d0b3af24a1513e8e9ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a66a24c58d27c6368ac879f4d7cc4cfc9">operator*</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;val, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left.  <a href="#a66a24c58d27c6368ac879f4d7cc4cfc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4522333fedaf508711a5aa02c47e5c7a">operator*</a> (SCALARTYPE val, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a host scalar (float or double) from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left.  <a href="#a4522333fedaf508711a5aa02c47e5c7a"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa2aeb075792a4f72abdd84b393d41869"></a><!-- doxytag: member="viennacl::vcl_ptrdiff_t" ref="aa2aeb075792a4f72abdd84b393d41869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a151281d5407af580310fed77af40f052"></a><!-- doxytag: member="viennacl::vcl_size_t" ref="a151281d5407af580310fed77af40f052" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5684964ce1519c88a443aa14be9428f0"></a><!-- doxytag: member="viennacl::copy" ref="a5684964ce1519c88a443aa14be9428f0" args="(const CPU_MATRIX &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU). </p>
<p>There are some type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.size1() returns the number of rows</li>
<li>.size2() returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25d1118aadbe1e6cb69b70df35f94763"></a><!-- doxytag: member="viennacl::copy" ref="a25d1118aadbe1e6cb69b70df35f94763" args="(const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a0feeb7a31a31f45e1d014512758fe6"></a><!-- doxytag: member="viennacl::copy" ref="a8a0feeb7a31a31f45e1d014512758fe6" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1d2b8aa5bf56f7479a66d51713708d2"></a><!-- doxytag: member="viennacl::copy" ref="ae1d2b8aa5bf56f7479a66d51713708d2" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a376734f00b48e1c773c82eb9290c1f08"></a><!-- doxytag: member="viennacl::copy" ref="a376734f00b48e1c773c82eb9290c1f08" args="(const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense STL-type matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A dense matrix on the host of type std::vector&lt; std::vector&lt;&gt; &gt;. cpu_matrix[i][j] returns the element in the i-th row and j-th columns (both starting with zero) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad823fb30fd180da375a1e09d56c0a1b8"></a><!-- doxytag: member="viennacl::copy" ref="ad823fb30fd180da375a1e09d56c0a1b8" args="(vector&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_vec, vector&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;gpu_dest_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_src_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT_DEST &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_dest_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a ViennaCL vector to another ViennaCL vector. Convenience wrapper for viennacl::linalg::copy(gpu_src_vec.begin(), gpu_src_vec.end(), gpu_dest_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_src_vec</em>&nbsp;</td><td>A gpu vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_dest_vec</em>&nbsp;</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb1db189fa5cd8ee4a8222d8b87f3ab0"></a><!-- doxytag: member="viennacl::copy" ref="afb1db189fa5cd8ee4a8222d8b87f3ab0" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>CPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_end</em>&nbsp;</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b4ced508c064fe8b45f437b538ed2ca"></a><!-- doxytag: member="viennacl::copy" ref="a0b4ced508c064fe8b45f437b538ed2ca" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A dense memory on the host. Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72359f3759c0067ac956d01c36651f9a"></a><!-- doxytag: member="viennacl::copy" ref="a72359f3759c0067ac956d01c36651f9a" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; SCALARTYPE, A1 &gt;, A2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A dense memory on the host using STL types, typically std::vector&lt; std::vector&lt;&gt; &gt; Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87f711ebb1d8fd6435d31f1841f9cfaf"></a><!-- doxytag: member="viennacl::copy" ref="a87f711ebb1d8fd6435d31f1841f9cfaf" args="(const CPU_MATRIX &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU). </p>
<p>For the requirements on the CPU_MATRIX type, see the documentation of the function copy(CPU_MATRIX, compressed_matrix&lt;&gt;)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af638a30a9dd2001143b4c92072c76d48"></a><!-- doxytag: member="viennacl::copy" ref="af638a30a9dd2001143b4c92072c76d48" args="(const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&nbsp;</td>
          <td class="paramname"> <em>gpu_dest_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_src_begin</em>&nbsp;</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_src_end</em>&nbsp;</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_dest_begin</em>&nbsp;</td><td>Output iterator for the gpu vector. The gpu_dest vector must be at least as long as the gpu_src vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9164bd549b986f39b035c24a426869b9"></a><!-- doxytag: member="viennacl::copy" ref="a9164bd549b986f39b035c24a426869b9" args="(const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_begin, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;gpu_src_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt; gpu_dest_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_src_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_SRC &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_src_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT_DEST &gt;&nbsp;</td>
          <td class="paramname"> <em>gpu_dest_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy (parts of a) GPU vector to another GPU vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_src_begin</em>&nbsp;</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_src_end</em>&nbsp;</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_dest_begin</em>&nbsp;</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b202ebcc6108940a59881c42f3d86da"></a><!-- doxytag: member="viennacl::copy" ref="a6b202ebcc6108940a59881c42f3d86da" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fb2cd615454e656202d5d6f1a54483"></a><!-- doxytag: member="viennacl::copy" ref="ab4fb2cd615454e656202d5d6f1a54483" args="(const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7953e64a62d2209621a3f4a505dc9f9e"></a><!-- doxytag: member="viennacl::copy" ref="a7953e64a62d2209621a3f4a505dc9f9e" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>GPU constant iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_end</em>&nbsp;</td><td>GPU constant iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6713b60b19010992ea611ef7ecd4fdf2"></a><!-- doxytag: member="viennacl::copy" ref="a6713b60b19010992ea611ef7ecd4fdf2" args="(const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_end</em>&nbsp;</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb5884675d2f3a9ca1a57a3a722aa78a"></a><!-- doxytag: member="viennacl::copy" ref="afb5884675d2f3a9ca1a57a3a722aa78a" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_vec</em>&nbsp;</td><td>A gpu vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_vec</em>&nbsp;</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d4fd919fa235b1c7dabd0049740e774"></a><!-- doxytag: member="viennacl::copy" ref="a0d4fd919fa235b1c7dabd0049740e774" args="(const CPUVECTOR &amp;cpu_vec, vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_vec</em>&nbsp;</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_vec</em>&nbsp;</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2ea05f107d5ec7f31214a2898ccbe08"></a><!-- doxytag: member="viennacl::copy" ref="ab2ea05f107d5ec7f31214a2898ccbe08" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bd43fae5bc2cdd71e384d1794527add"></a><!-- doxytag: member="viennacl::copy" ref="a4bd43fae5bc2cdd71e384d1794527add" args="(const CPU_MATRIX &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A dense matrix on the host. Type requirements: .size1() returns number of rows, .size2() returns number of columns. Access to entries via operator() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12da6187594db18ae7aa4874e1ad3f1d"></a><!-- doxytag: member="viennacl::copy" ref="a12da6187594db18ae7aa4874e1ad3f1d" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9250bb8c996f6eab600899146e0cbf26"></a><!-- doxytag: member="viennacl::fast_copy" ref="a9250bb8c996f6eab600899146e0cbf26" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy()</a> function, because entries are directly read from the cpu vector, starting with &amp;(*cpu.begin()). However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_end</em>&nbsp;</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>Output iterator for the gpu vector. The gpu iterator must be incrementable (cpu_end - cpu_begin) times, otherwise the result is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7146b5952b3532c74728adc05d4de55"></a><!-- doxytag: member="viennacl::fast_copy" ref="af7146b5952b3532c74728adc05d4de55" args="(const CPUVECTOR &amp;cpu_vec, vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::fast_copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_vec</em>&nbsp;</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_vec</em>&nbsp;</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab917c8f27a8f1cf7b8d6be54989efb99"></a><!-- doxytag: member="viennacl::fast_copy" ref="ab917c8f27a8f1cf7b8d6be54989efb99" args="(SCALARTYPE *cpu_matrix_begin, SCALARTYPE *cpu_matrix_end, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE *&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE *&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without temporary. Matrix-Layout on CPU must be equal to the matrix-layout on the GPU. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix_begin</em>&nbsp;</td><td>Pointer to the first matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix_end</em>&nbsp;</td><td>Pointer past the last matrix entry. Cf. iterator concept in STL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fae23064f21ff285672845e82545fd2"></a><!-- doxytag: member="viennacl::fast_copy" ref="a2fae23064f21ff285672845e82545fd2" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, SCALARTYPE *cpu_matrix_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE *&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix_begin</em>&nbsp;</td><td>Pointer to the output memory on the CPU. User must ensure that provided memory is large enough. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad3621936e6071d2777aae22a5f891ec"></a><!-- doxytag: member="viennacl::fast_copy" ref="aad3621936e6071d2777aae22a5f891ec" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::fast_copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_vec</em>&nbsp;</td><td>A gpu vector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_vec</em>&nbsp;</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c694a91cf3e54637ed6a05ab7d9ce75"></a><!-- doxytag: member="viennacl::fast_copy" ref="a9c694a91cf3e54637ed6a05ab7d9ce75" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy()</a> function, because entries are directly written to the cpu vector, starting with &amp;(*cpu.begin()) However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_end</em>&nbsp;</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a976181b1f6aa698b64a4746f0949fce0"></a><!-- doxytag: member="viennacl::fast_swap" ref="a976181b1f6aa698b64a4746f0949fce0" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v1, vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; viennacl::fast_swap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>The second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4522333fedaf508711a5aa02c47e5c7a"></a><!-- doxytag: member="viennacl::operator*" ref="a4522333fedaf508711a5aa02c47e5c7a" args="(SCALARTYPE val, viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a host scalar (float or double) from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00f47d8ad32713f98c6979c245b88cdb"></a><!-- doxytag: member="viennacl::operator*" ref="a00f47d8ad32713f98c6979c245b88cdb" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, scalar&lt; SCALARTYPE &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the right. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa60d7cda126efd13c3413453606850b7"></a><!-- doxytag: member="viennacl::operator*" ref="aa60d7cda126efd13c3413453606850b7" args="(SCALARTYPE const &amp;value, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt;, const SCALARTYPE, op_prod&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The host scalar (float or double) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45c8d32b7d99c62cdb10899d70e7bad9"></a><!-- doxytag: member="viennacl::operator*" ref="a45c8d32b7d99c62cdb10899d70e7bad9" args="(const viennacl::matrix_expression&lt; const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, const viennacl::vector&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; &amp;proxy, CPU_SCALAR val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt;, op_prod&gt;, const SCALARTYPE, op_prod&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_SCALAR&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b34a609403378a81c3a2589a5418077"></a><!-- doxytag: member="viennacl::operator*" ref="a3b34a609403378a81c3a2589a5418077" args="(scalar&lt; SCALARTYPE &gt; const &amp;value, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt;, op_prod&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a ViennaCL scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The ViennaCL scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae29e41dc09ce774a0082eb52bdcb81e7"></a><!-- doxytag: member="viennacl::operator*" ref="ae29e41dc09ce774a0082eb52bdcb81e7" args="(CPU_SCALAR val, viennacl::matrix_expression&lt; const viennacl::vector&lt; SCALARTYPE, VA1 &gt;, const viennacl::vector&lt; SCALARTYPE, VA2 &gt;, op_prod &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VA1&gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, VA2&gt;, op_prod&gt;, const SCALARTYPE, op_prod&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">CPU_SCALAR&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1matrix__expression.html">viennacl::matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA1 &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, VA2 &gt;, op_prod &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a66a24c58d27c6368ac879f4d7cc4cfc9"></a><!-- doxytag: member="viennacl::operator*" ref="a66a24c58d27c6368ac879f4d7cc4cfc9" args="(scalar&lt; SCALARTYPE &gt; const &amp;val, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0808ef51d9a2d2e1ecbed3d4b63e159f"></a><!-- doxytag: member="viennacl::operator+" ref="a0808ef51d9a2d2e1ecbed3d4b63e159f" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then added to vec2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>Right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae3143a0fbb9e586b489cea90acf6659"></a><!-- doxytag: member="viennacl::operator+" ref="aae3143a0fbb9e586b489cea90acf6659" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;::VectorType viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of two vector expressions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy1</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy2</em>&nbsp;</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae00e47f8124b08cbeb8b7fc9ff537081"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ae00e47f8124b08cbeb8b7fc9ff537081" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then added to vec2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>Right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77d42d098f9212ba53487deb6ddacf57"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a77d42d098f9212ba53487deb6ddacf57" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;::VectorType viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of two vector expressions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy1</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy2</em>&nbsp;</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aeb5b431a9c6d0b3af24a1513e8e9ad"></a><!-- doxytag: member="viennacl::operator/" ref="a3aeb5b431a9c6d0b3af24a1513e8e9ad" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, scalar&lt; SCALARTYPE &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a> and then divided by alpha. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e572599ddbae8812154538849fa707c"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a5e572599ddbae8812154538849fa707c" args="(std::ostream &amp;s, vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output stream. Output format is ublas compatible. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>STL output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The vector that should be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7b70e43299f65259cc61849f9ad997c"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="ab7b70e43299f65259cc61849f9ad997c" args="(std::ostream &amp;s, const matrix_expression&lt; LHS, RHS, OP &gt; &amp;expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix_expression&lt; LHS, RHS, OP &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>STL output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc6cd55d2644b2c6b5f69cb733fb6f24"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="abc6cd55d2644b2c6b5f69cb733fb6f24" args="(std::ostream &amp;s, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>STL output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b3d6b04f0d7dac6aec4342e0b37656e"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a5b3d6b04f0d7dac6aec4342e0b37656e" args="(std::ostream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly print the value of a scalar to an output stream. </p>

</div>
</div>
<a class="anchor" id="ab4ea659d4449111a55f748c34226f305"></a><!-- doxytag: member="viennacl::operator&gt;&gt;" ref="ab4ea659d4449111a55f748c34226f305" args="(std::istream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; viennacl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly read a value of a scalar from an input stream. </p>

</div>
</div>
<a class="anchor" id="a0c01dfab44c6d3849f7d0eac55539142"></a><!-- doxytag: member="viennacl::swap" ref="a0c01dfab44c6d3849f7d0eac55539142" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors, data is copied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95013bc545c5642ccfbd8c5ceb3b885c"></a><!-- doxytag: member="viennacl::trans" ref="a95013bc545c5642ccfbd8c5ceb3b885c" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt;SCALARTYPE, F, ALIGNMENT&gt;, op_trans&gt; viennacl::trans </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat May 21 2011 20:36:51 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
