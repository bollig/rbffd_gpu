<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: /data/development/ViennaCL/ViennaCL-1.1.2/viennacl/vector.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>/data/development/ViennaCL/ViennaCL-1.1.2/viennacl/vector.hpp</h1>  </div>
</div>
<div class="contents">
<a href="vector_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* =======================================================================</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (c) 2010, Institute for Microelectronics, TU Vienna.</span>
<a name="l00003"></a>00003 <span class="comment">   http://www.iue.tuwien.ac.at</span>
<a name="l00004"></a>00004 <span class="comment">                             -----------------</span>
<a name="l00005"></a>00005 <span class="comment">                     ViennaCL - The Vienna Computing Library</span>
<a name="l00006"></a>00006 <span class="comment">                             -----------------</span>
<a name="l00007"></a>00007 <span class="comment">                            </span>
<a name="l00008"></a>00008 <span class="comment">   authors:    Karl Rupp                          rupp@iue.tuwien.ac.at</span>
<a name="l00009"></a>00009 <span class="comment">               Florian Rudolf                     flo.rudy+viennacl@gmail.com</span>
<a name="l00010"></a>00010 <span class="comment">               Josef Weinbub                      weinbub@iue.tuwien.ac.at</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   license:    MIT (X11), see file LICENSE in the ViennaCL base directory</span>
<a name="l00013"></a>00013 <span class="comment">======================================================================= */</span>
<a name="l00014"></a>00014 
<a name="l00020"></a>00020 <span class="preprocessor">#ifndef _VIENNACL_VECTOR_HPP_</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define _VIENNACL_VECTOR_HPP_</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL.">viennacl/forwards.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="backend_8hpp.html" title="Implementations of the OpenCL backend, where all contexts are stored in.">viennacl/ocl/backend.hpp</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html" title="Implementation of the ViennaCL scalar class.">viennacl/scalar.hpp</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html" title="Various little tools used here and there in ViennaCL.">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="entry__proxy_8hpp.html" title="A proxy class for entries in a vector.">viennacl/tools/entry_proxy.hpp</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="vector__operations_8hpp.html" title="Implementations of vector operations.">viennacl/linalg/vector_operations.hpp</a>&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keyword">namespace </span>viennacl
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032     
<a name="l00045"></a>00045     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l00046"></a><a class="code" href="classviennacl_1_1vector__expression.html">00046</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>
<a name="l00047"></a>00047     {
<a name="l00048"></a>00048       <span class="keyword">public</span>:
<a name="l00051"></a><a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067">00051</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1tools_1_1_v_e_c_t_o_r___e_x_t_r_a_c_t_o_r.html#a9e7f3539ef2e71a6b4d199d882a40da0">viennacl::tools::VECTOR_EXTRACTOR&lt;LHS, RHS&gt;::ResultType</a>    VectorType;
<a name="l00052"></a>00052       
<a name="l00053"></a><a class="code" href="classviennacl_1_1vector__expression.html#a47b51aeee8120fa441f37d71f56b12c7">00053</a>         <a class="code" href="classviennacl_1_1vector__expression.html#a47b51aeee8120fa441f37d71f56b12c7">vector_expression</a>(LHS &amp; <a class="code" href="classviennacl_1_1vector__expression.html#abb680866089de4e937ddc6ce6f1f1830" title="Get left hand side operand.">lhs</a>, RHS &amp; <a class="code" href="classviennacl_1_1vector__expression.html#a563f5aecaa0755006225235e44a11a82" title="Get right hand side operand.">rhs</a>) : _lhs(lhs), _rhs(rhs) {}
<a name="l00054"></a>00054         
<a name="l00057"></a><a class="code" href="classviennacl_1_1vector__expression.html#abb680866089de4e937ddc6ce6f1f1830">00057</a>         LHS &amp; <a class="code" href="classviennacl_1_1vector__expression.html#abb680866089de4e937ddc6ce6f1f1830" title="Get left hand side operand.">lhs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _lhs; }
<a name="l00060"></a><a class="code" href="classviennacl_1_1vector__expression.html#a563f5aecaa0755006225235e44a11a82">00060</a>         RHS &amp; <a class="code" href="classviennacl_1_1vector__expression.html#a563f5aecaa0755006225235e44a11a82" title="Get right hand side operand.">rhs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _rhs; }
<a name="l00061"></a>00061         
<a name="l00063"></a><a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812">00063</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">viennacl::tools::VECTOR_SIZE_DEDUCER&lt;LHS, RHS, OP&gt;::size</a>(_lhs, _rhs); }
<a name="l00064"></a>00064         
<a name="l00065"></a>00065       <span class="keyword">private</span>:
<a name="l00067"></a>00067         LHS &amp; _lhs;
<a name="l00069"></a>00069         RHS &amp; _rhs;
<a name="l00070"></a>00070     };
<a name="l00071"></a>00071     
<a name="l00090"></a>00090     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00091"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html">00091</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator</a>
<a name="l00092"></a>00092     {
<a name="l00093"></a>00093         <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>    <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>;
<a name="l00094"></a>00094       <span class="keyword">public</span>:
<a name="l00095"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ae59e37ebbe3a193fa2dd307e94d99518">00095</a>         <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>            <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">value_type</a>;
<a name="l00096"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">00096</a>         <span class="keyword">typedef</span> <span class="keywordtype">long</span>                          difference_type;
<a name="l00097"></a>00097         
<a name="l00098"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ac6a7762dba62eaf3d6379fc12481b559">00098</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html#ac6a7762dba62eaf3d6379fc12481b559">const_vector_iterator</a>() {};
<a name="l00103"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#aa8e2e53d1a9740dc9a7e5dc30b03734b">00103</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html#aa8e2e53d1a9740dc9a7e5dc30b03734b" title="Constructor.">const_vector_iterator</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>,      cl_uint <a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>)  : <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">elements_</a>(vec.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a625da5e66b023a7ed067040a21ec834d">handle</a>()), <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>(index) {};
<a name="l00104"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a9cf058c9dc4e611bc1a4c0690fe02492">00104</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html#a9cf058c9dc4e611bc1a4c0690fe02492">const_vector_iterator</a>(<a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> <span class="keyword">const</span> &amp; elements, cl_uint <a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>)  : <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">elements_</a>(elements), <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>(index) {};
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         
<a name="l00107"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a832e184e247b97ecb752bf291d814dff">00107</a>         <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">value_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a832e184e247b97ecb752bf291d814dff">operator*</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>
<a name="l00108"></a>00108 <span class="keyword">        </span>{ 
<a name="l00109"></a>00109            <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">value_type</a> result;
<a name="l00110"></a>00110            result = <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">elements_</a>);
<a name="l00111"></a>00111            <span class="keywordflow">return</span> result;
<a name="l00112"></a>00112         }
<a name="l00113"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a0b50df67a5cd6493e8839fd8990500a7">00113</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a0b50df67a5cd6493e8839fd8990500a7">operator++</a>(<span class="keywordtype">void</span>) { ++<a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00114"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a39f7c37604fd9845ff487b36b6f88602">00114</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a39f7c37604fd9845ff487b36b6f88602">operator++</a>(<span class="keywordtype">int</span>) { <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> tmp = *<span class="keyword">this</span>; ++(*this); <span class="keywordflow">return</span> tmp; }
<a name="l00115"></a>00115         
<a name="l00116"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#ae01970b831b1c1dc3a9f22f7a4e19cf6">00116</a>         <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#ae01970b831b1c1dc3a9f22f7a4e19cf6">operator==</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a> == other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>; }
<a name="l00117"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a0c704f6470bc4c7392b964dd83a1d97b">00117</a>         <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a0c704f6470bc4c7392b964dd83a1d97b">operator!=</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a> != other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>; }
<a name="l00118"></a>00118         
<a name="l00119"></a>00119 <span class="comment">//        self_type &amp; operator=(self_type const &amp; other)</span>
<a name="l00120"></a>00120 <span class="comment">//        {</span>
<a name="l00121"></a>00121 <span class="comment">//           _index = other._index;</span>
<a name="l00122"></a>00122 <span class="comment">//           elements_ = other._elements;</span>
<a name="l00123"></a>00123 <span class="comment">//           return *this;</span>
<a name="l00124"></a>00124 <span class="comment">//        }   </span>
<a name="l00125"></a>00125 
<a name="l00126"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">00126</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#aec7de6121b5440524976b3baf978fb5c">operator-</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <span class="keyword">const</span> &amp; other)<span class="keyword"> const </span>{ <a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> result = <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>; <span class="keywordflow">return</span> result - other.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>; }
<a name="l00127"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">00127</a>         <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a63fe5e79738641bc4c5fd1f07740e3c7">operator+</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a8ad60a9ff2530781950dbfd682353e64">difference_type</a> diff)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">elements_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a> + diff); }
<a name="l00128"></a>00128         
<a name="l00129"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">00129</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>; }
<a name="l00130"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a625da5e66b023a7ed067040a21ec834d">00130</a>         <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classviennacl_1_1const__vector__iterator.html#a625da5e66b023a7ed067040a21ec834d">handle</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">elements_</a>; }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132       <span class="keyword">protected</span>:
<a name="l00134"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc">00134</a>         <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">elements_</a>;
<a name="l00135"></a><a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">00135</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">index_</a>;
<a name="l00136"></a>00136     };
<a name="l00137"></a>00137     
<a name="l00138"></a>00138 
<a name="l00158"></a>00158     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00159"></a><a class="code" href="classviennacl_1_1vector__iterator.html">00159</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator</a> : <span class="keyword">public</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator</a>&lt;SCALARTYPE, ALIGNMENT&gt;
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161         <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>  <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>;
<a name="l00162"></a>00162         <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>        <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">self_type</a>;
<a name="l00163"></a>00163       <span class="keyword">public</span>:
<a name="l00164"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a870d4c95600057004f7f4022a87bcf2a">00164</a>         <a class="code" href="classviennacl_1_1vector__iterator.html#a870d4c95600057004f7f4022a87bcf2a">vector_iterator</a>() : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(){};
<a name="l00165"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a85d26854f63fc4da7b9f64f1dc1885b6">00165</a>         <a class="code" href="classviennacl_1_1vector__iterator.html#a85d26854f63fc4da7b9f64f1dc1885b6">vector_iterator</a>(<a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> <span class="keyword">const</span> &amp; elements, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>)  : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(elements, index) {};
<a name="l00170"></a><a class="code" href="classviennacl_1_1vector__iterator.html#ab2e550b8717745228f53d20fa8cd4a88">00170</a>         <a class="code" href="classviennacl_1_1vector__iterator.html#ab2e550b8717745228f53d20fa8cd4a88" title="Constructor.">vector_iterator</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>, cl_uint <a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>) : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(vec, index) {};
<a name="l00171"></a><a class="code" href="classviennacl_1_1vector__iterator.html#ad856d30aabbab284be47dcf0a38c0693">00171</a>         <a class="code" href="classviennacl_1_1vector__iterator.html#ad856d30aabbab284be47dcf0a38c0693">vector_iterator</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a> <span class="keyword">const</span> &amp; b) : <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(b) {};
<a name="l00172"></a>00172 
<a name="l00173"></a><a class="code" href="classviennacl_1_1vector__iterator.html#aca896a4673a17317ad7068e8b769a6c8">00173</a>         <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">base_type::value_type</a> <a class="code" href="classviennacl_1_1vector__iterator.html#aca896a4673a17317ad7068e8b769a6c8">operator*</a>(<span class="keywordtype">void</span>)  
<a name="l00174"></a>00174         { 
<a name="l00175"></a>00175            <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">base_type::value_type</a> result;
<a name="l00176"></a>00176            result = <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">base_type::index_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">base_type::elements_</a>); 
<a name="l00177"></a>00177            <span class="keywordflow">return</span> result;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         
<a name="l00180"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a7e12b10e3e03ef763a5aa8a70eb21aa7">00180</a>         <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> <a class="code" href="classviennacl_1_1vector__iterator.html#a7e12b10e3e03ef763a5aa8a70eb21aa7">handle</a>() { <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">base_type::elements_</a>; }
<a name="l00181"></a>00181         
<a name="l00182"></a><a class="code" href="classviennacl_1_1vector__iterator.html#a327ab3f759dae4072bfabbef27d7a981">00182</a>         <a class="code" href="classviennacl_1_1vector__iterator.html#a327ab3f759dae4072bfabbef27d7a981">operator base_type</a>()<span class="keyword"> const</span>
<a name="l00183"></a>00183 <span class="keyword">        </span>{
<a name="l00184"></a>00184           <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">base_type</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html#a620028b02247d371f9637f6a648a13cc" title="The index of the entry the iterator is currently pointing to.">base_type::elements_</a>, <a class="code" href="classviennacl_1_1const__vector__iterator.html#a961e8f62e2b57b3021c417a2c61dfb82">base_type::index_</a>);
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186     };
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="comment">// forward definition in VCLForwards.h!</span>
<a name="l00197"></a>00197 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00198"></a><a class="code" href="classviennacl_1_1vector.html">00198</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector</a>
<a name="l00199"></a>00199     {
<a name="l00200"></a>00200       
<a name="l00201"></a>00201     <span class="keyword">public</span>:
<a name="l00202"></a><a class="code" href="classviennacl_1_1vector.html#aed985c700866b1bae61cb8bcd5d322fe">00202</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;typename viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT&lt;SCALARTYPE&gt;::ResultType</a>&gt;   <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">value_type</a>;
<a name="l00203"></a><a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">00203</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>                                        size_type;
<a name="l00204"></a><a class="code" href="classviennacl_1_1vector.html#a1d7ed47a15fea60d02986112826f40bc">00204</a>       <span class="keyword">typedef</span> <a class="code" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a>                                     difference_type;
<a name="l00205"></a><a class="code" href="classviennacl_1_1vector.html#a5b0cecdbbf962357b5dc5f79dcae2d66">00205</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>      <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_iterator</a>;
<a name="l00206"></a><a class="code" href="classviennacl_1_1vector.html#a589223a5e682b4a61d57bb8742b1cec9">00206</a>       <span class="keyword">typedef</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>            <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">iterator</a>;
<a name="l00207"></a>00207 
<a name="l00210"></a><a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383">00210</a>       <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>() : size_(0) { viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::init();  }
<a name="l00211"></a>00211 
<a name="l00216"></a><a class="code" href="classviennacl_1_1vector.html#a37af05b711e0806bd57ae6e4adfeb46e">00216</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> vec_size) : size_(vec_size)
<a name="l00217"></a>00217       {
<a name="l00218"></a>00218         viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::init(); 
<a name="l00219"></a>00219         
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (size_ &gt; 0)
<a name="l00221"></a>00221           elements_ = <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a22299eef7ac0c36ba322a2bb25e953c5" title="Creates a memory buffer within the context.">create_memory</a>(CL_MEM_READ_WRITE, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00222"></a>00222         
<a name="l00223"></a>00223         <span class="comment">//force entries above size_ to zero:</span>
<a name="l00224"></a>00224         <span class="keywordflow">if</span> (size_ &lt; <a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>())
<a name="l00225"></a>00225         {
<a name="l00226"></a>00226           std::vector&lt;SCALARTYPE&gt; temp(<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>() - size_);
<a name="l00227"></a>00227           cl_int err = clEnqueueWriteBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>(), elements_, CL_TRUE, <span class="keyword">sizeof</span>(SCALARTYPE)*size_, <span class="keyword">sizeof</span>(SCALARTYPE)*(<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>() - size_), &amp;(temp[0]), 0, NULL, NULL);
<a name="l00228"></a>00228           <span class="comment">//assert(err == CL_SUCCESS);</span>
<a name="l00229"></a>00229           <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231       }
<a name="l00232"></a>00232 
<a name="l00241"></a><a class="code" href="classviennacl_1_1vector.html#ae8ca03c5bcafbb1520e7382e8ac0050d">00241</a>       <span class="keyword">explicit</span> <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(cl_mem existing_mem, <a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> vec_size) : size_(vec_size),  elements_(existing_mem)
<a name="l00242"></a>00242       {
<a name="l00243"></a>00243         elements_.<a class="code" href="classviennacl_1_1ocl_1_1handle.html#a40b09187c94d100512d5e49b1d2fd9bd" title="Manually increment the OpenCL reference count. Typically called automatically, but is necessary if us...">inc</a>();  <span class="comment">//prevents that the user-provided memory is deleted once the vector object is destroyed.</span>
<a name="l00244"></a>00244       }
<a name="l00245"></a>00245       
<a name="l00246"></a>00246       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l00247"></a><a class="code" href="classviennacl_1_1vector.html#a90f2d2832c55e1631a0cf00bc61c9a3d">00247</a>       <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt;LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; other) : size_(other.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>())
<a name="l00248"></a>00248       {
<a name="l00249"></a>00249         elements_ = <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a22299eef7ac0c36ba322a2bb25e953c5" title="Creates a memory buffer within the context.">create_memory</a>(CL_MEM_READ_WRITE, <span class="keyword">sizeof</span>(SCALARTYPE)*other.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l00250"></a>00250         *<span class="keyword">this</span> = other;
<a name="l00251"></a>00251       }
<a name="l00252"></a>00252       
<a name="l00257"></a><a class="code" href="classviennacl_1_1vector.html#abcd7469cb88bdf2e0f146b73ef567887">00257</a>       <a class="code" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383" title="Default constructor in order to be compatible with various containers.">vector</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>) :
<a name="l00258"></a>00258         size_(vec.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>())
<a name="l00259"></a>00259       {
<a name="l00260"></a>00260         viennacl::linalg::kernels::vector&lt;SCALARTYPE, 1&gt;::init(); 
<a name="l00261"></a>00261         
<a name="l00262"></a>00262         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>() != 0)
<a name="l00263"></a>00263         {
<a name="l00264"></a>00264           elements_ = <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a22299eef7ac0c36ba322a2bb25e953c5" title="Creates a memory buffer within the context.">create_memory</a>(CL_MEM_READ_WRITE, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00265"></a>00265           cl_int err;
<a name="l00266"></a>00266           err = clEnqueueCopyBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>(), vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>(), elements_, 0, 0, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>(), 0, NULL, NULL);
<a name="l00267"></a>00267           <span class="comment">//assert(err == CL_SUCCESS);</span>
<a name="l00268"></a>00268           <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00269"></a>00269         }
<a name="l00270"></a>00270       }
<a name="l00271"></a>00271 
<a name="l00274"></a><a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c">00274</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l00275"></a>00275       {
<a name="l00276"></a>00276         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(vec.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00277"></a>00277         <span class="keywordflow">if</span> (<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>() != 0)
<a name="l00278"></a>00278         {
<a name="l00279"></a>00279           cl_int err;
<a name="l00280"></a>00280           err = clEnqueueCopyBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>(), vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>(), elements_, 0, 0, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>(), 0, NULL, NULL);
<a name="l00281"></a>00281           <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00284"></a>00284       }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
<a name="l00291"></a>00291       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;   <span class="comment">//use template to cover const/non-const of VectorType:</span>
<a name="l00292"></a><a class="code" href="classviennacl_1_1vector.html#ac4770655192f11ccca15bbd39219d725">00292</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; VectorType,
<a name="l00293"></a>00293                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00294"></a>00294                                                                            op_prod&gt; &amp; proxy)
<a name="l00295"></a>00295       {
<a name="l00296"></a>00296         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(proxy.lhs().size());
<a name="l00297"></a>00297         <span class="comment">//std::cout &lt;&lt; &quot;vector::operator=(vec_times_scalar_proxy)&quot; &lt;&lt; std::endl; </span>
<a name="l00298"></a>00298         <a class="code" href="namespaceviennacl_1_1linalg.html#acae4aaa06516b42063bd44c12e5d56d0" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune...">viennacl::linalg::mult</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00299"></a>00299         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00300"></a>00300       }
<a name="l00301"></a>00301 
<a name="l00306"></a>00306       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;   <span class="comment">//use template to cover const/non-const of VectorType:</span>
<a name="l00307"></a><a class="code" href="classviennacl_1_1vector.html#ae91c07bfd48f22c8ea54d42583c3611f">00307</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; VectorType,
<a name="l00308"></a>00308                                                                            <span class="keyword">const</span> SCALARTYPE,
<a name="l00309"></a>00309                                                                            op_prod&gt; &amp; proxy)
<a name="l00310"></a>00310       {
<a name="l00311"></a>00311         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(proxy.lhs().size());
<a name="l00312"></a>00312         <a class="code" href="namespaceviennacl_1_1linalg.html#acae4aaa06516b42063bd44c12e5d56d0" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune...">viennacl::linalg::mult</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00313"></a>00313         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00314"></a>00314       }
<a name="l00315"></a>00315 
<a name="l00320"></a>00320       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;   <span class="comment">//use template to cover const/non-const of VectorType:</span>
<a name="l00321"></a><a class="code" href="classviennacl_1_1vector.html#a2cb54ea322ec4f89df8b798350c84f1b">00321</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; VectorType,
<a name="l00322"></a>00322                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00323"></a>00323                                                                            op_div&gt; &amp; proxy)
<a name="l00324"></a>00324       {
<a name="l00325"></a>00325         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(proxy.lhs().size());
<a name="l00326"></a>00326         <span class="comment">//std::cout &lt;&lt; &quot;vector::operator=(vec_times_scalar_proxy)&quot; &lt;&lt; std::endl; </span>
<a name="l00327"></a>00327         <a class="code" href="namespaceviennacl_1_1linalg.html#a0acf4875161f1193bcda16d33a66ce61" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune...">viennacl::linalg::divide</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00328"></a>00328         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00329"></a>00329       }
<a name="l00330"></a>00330 
<a name="l00335"></a>00335       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;   <span class="comment">//use template to cover const/non-const of VectorType:</span>
<a name="l00336"></a><a class="code" href="classviennacl_1_1vector.html#a4a926e47e610c69c69d0f37a858cc69b">00336</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; VectorType,
<a name="l00337"></a>00337                                                                            <span class="keyword">const</span> SCALARTYPE,
<a name="l00338"></a>00338                                                                            op_div&gt; &amp; proxy)
<a name="l00339"></a>00339       {
<a name="l00340"></a>00340         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(proxy.lhs().size());
<a name="l00341"></a>00341         <span class="comment">//std::cout &lt;&lt; &quot;vector::operator=(vec_times_scalar_proxy)&quot; &lt;&lt; std::endl; </span>
<a name="l00342"></a>00342         <a class="code" href="namespaceviennacl_1_1linalg.html#acae4aaa06516b42063bd44c12e5d56d0" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune...">viennacl::linalg::mult</a>(proxy.lhs(), <span class="keyword">static_cast&lt;</span>SCALARTYPE<span class="keyword">&gt;</span>(1.0) / proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00343"></a>00343         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346       <span class="comment">//v1 = v2 + v3; </span>
<a name="l00351"></a><a class="code" href="classviennacl_1_1vector.html#a77b68e4bfde82a92f70728c40b652f03">00351</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00352"></a>00352                                                                            <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00353"></a>00353                                                                            op_add&gt; &amp; proxy)
<a name="l00354"></a>00354       {
<a name="l00355"></a>00355         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(proxy.lhs().size());
<a name="l00356"></a>00356         <span class="comment">//std::cout &lt;&lt; &quot;vector::operator=(vec_times_scalar_proxy)&quot; &lt;&lt; std::endl; </span>
<a name="l00357"></a>00357         <a class="code" href="namespaceviennacl_1_1linalg.html#a2777d6a19ce110ae9df6609f1677be0f" title="Adds two dense matrices and writes the result to a third matrix.">viennacl::linalg::add</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00358"></a>00358         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00359"></a>00359       }
<a name="l00360"></a>00360       
<a name="l00361"></a>00361       <span class="comment">//v1 = v2 - v3; </span>
<a name="l00366"></a><a class="code" href="classviennacl_1_1vector.html#a5bcfcbcb1d03f00ee8942a39e881207f">00366</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator = </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00367"></a>00367                                                                            <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00368"></a>00368                                                                            op_sub&gt; &amp; proxy)
<a name="l00369"></a>00369       {
<a name="l00370"></a>00370         <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(proxy.lhs().size());
<a name="l00371"></a>00371         <span class="comment">//std::cout &lt;&lt; &quot;vector::operator=(vec_times_scalar_proxy)&quot; &lt;&lt; std::endl; </span>
<a name="l00372"></a>00372         <a class="code" href="namespaceviennacl_1_1linalg.html#a707ace72b7ff8ad1e3a9ff2606567f1e" title="Adds two dense matrices and writes the result to a third matrix.">viennacl::linalg::sub</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>);
<a name="l00373"></a>00373         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00374"></a>00374       }
<a name="l00375"></a>00375       
<a name="l00377"></a>00377 
<a name="l00378"></a>00378       <span class="comment">//Note: The following operator overloads are defined in matrix_operations.hpp, compressed_matrix_operations.hpp and coordinate_matrix_operations.hpp</span>
<a name="l00379"></a>00379       <span class="comment">//This is certainly not the nicest approach and will most likely by changed in the future, but it works :-)</span>
<a name="l00380"></a>00380       
<a name="l00381"></a>00381       <span class="comment">//matrix&lt;&gt;</span>
<a name="l00386"></a>00386 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00387"></a>00387       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00388"></a>00388                                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00389"></a>00389                                                 op_prod&gt; &amp; proxy);
<a name="l00390"></a>00390 
<a name="l00395"></a>00395       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00396"></a>00396       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00397"></a>00397                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00398"></a>00398                                                                           op_prod&gt; &amp; proxy);
<a name="l00399"></a>00399                                                 
<a name="l00404"></a>00404       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00405"></a>00405       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00406"></a>00406                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00407"></a>00407                                                                           op_prod&gt; &amp; proxy);
<a name="l00408"></a>00408 
<a name="l00413"></a>00413       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00414"></a>00414       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00415"></a>00415                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00416"></a>00416                                                                        op_prod&gt; &amp; proxy);
<a name="l00417"></a>00417 
<a name="l00422"></a>00422       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00423"></a>00423       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00424"></a>00424                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00425"></a>00425                                                                        op_prod&gt; &amp; proxy);
<a name="l00426"></a>00426 
<a name="l00427"></a>00427       <span class="comment">//transposed_matrix_proxy:</span>
<a name="l00432"></a>00432 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00433"></a>00433       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00434"></a>00434                                                                                                   <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00435"></a>00435                                                                                                   op_trans &gt;,
<a name="l00436"></a>00436                                                                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00437"></a>00437                                                                          op_prod&gt; &amp; proxy);
<a name="l00438"></a>00438 
<a name="l00443"></a>00443       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00444"></a>00444       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00445"></a>00445                                                                                                    <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00446"></a>00446                                                                                                    op_trans &gt;,
<a name="l00447"></a>00447                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00448"></a>00448                                                                           op_prod&gt; &amp; proxy);
<a name="l00449"></a>00449                                                 
<a name="l00454"></a>00454       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00455"></a>00455       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00456"></a>00456                                                                                                    <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00457"></a>00457                                                                                                    op_trans &gt;,
<a name="l00458"></a>00458                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00459"></a>00459                                                                           op_prod&gt; &amp; proxy);
<a name="l00460"></a>00460 
<a name="l00465"></a>00465       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00466"></a>00466       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00467"></a>00467                                                                                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00468"></a>00468                                                                                                 op_trans &gt;,
<a name="l00469"></a>00469                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00470"></a>00470                                                                        op_prod&gt; &amp; proxy);
<a name="l00471"></a>00471 
<a name="l00476"></a>00476       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00477"></a>00477       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00478"></a>00478                                                                                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix&lt;SCALARTYPE, F, MAT_ALIGNMENT&gt;</a>,
<a name="l00479"></a>00479                                                                                                 op_trans &gt;,
<a name="l00480"></a>00480                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00481"></a>00481                                                                        op_prod&gt; &amp; proxy);
<a name="l00482"></a>00482                                                                        
<a name="l00483"></a>00483                                                                        
<a name="l00484"></a>00484                                                                        
<a name="l00486"></a>00486 
<a name="l00490"></a>00490       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00491"></a>00491       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00492"></a>00492                                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00493"></a>00493                                                 op_prod&gt; &amp; proxy);
<a name="l00494"></a>00494 
<a name="l00499"></a>00499       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00500"></a>00500       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00501"></a>00501                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00502"></a>00502                                                                           op_prod&gt; &amp; proxy);
<a name="l00503"></a>00503                                                 
<a name="l00508"></a>00508       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00509"></a>00509       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00510"></a>00510                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00511"></a>00511                                                                           op_prod&gt; &amp; proxy);
<a name="l00512"></a>00512 
<a name="l00517"></a>00517       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00518"></a>00518       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00519"></a>00519                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00520"></a>00520                                                                        op_prod&gt; &amp; proxy);
<a name="l00521"></a>00521 
<a name="l00526"></a>00526       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00527"></a>00527       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00528"></a>00528                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00529"></a>00529                                                                        op_prod&gt; &amp; proxy);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531 
<a name="l00532"></a>00532       <span class="comment">//coordinate_matrix&lt;&gt;</span>
<a name="l00537"></a>00537 <span class="comment"></span>      <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00538"></a>00538       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c" title="Assignment operator. This vector is resized if &amp;#39;vec&amp;#39; is of a different size.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00539"></a>00539                                                 <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00540"></a>00540                                                 op_prod&gt; &amp; proxy);
<a name="l00541"></a>00541 
<a name="l00546"></a>00546       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00547"></a>00547       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00548"></a>00548                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00549"></a>00549                                                                           op_prod&gt; &amp; proxy);
<a name="l00550"></a>00550                                                 
<a name="l00555"></a>00555       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00556"></a>00556       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-=</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00557"></a>00557                                                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00558"></a>00558                                                                           op_prod&gt; &amp; proxy);
<a name="l00559"></a>00559 
<a name="l00564"></a>00564       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00565"></a>00565       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator+</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00566"></a>00566                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00567"></a>00567                                                                        op_prod&gt; &amp; proxy);
<a name="l00568"></a>00568 
<a name="l00573"></a>00573       <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAT_ALIGNMENT&gt;
<a name="l00574"></a>00574       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator-</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix&lt;SCALARTYPE, MAT_ALIGNMENT&gt;</a>,
<a name="l00575"></a>00575                                                                        <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00576"></a>00576                                                                        op_prod&gt; &amp; proxy);
<a name="l00577"></a>00577 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580       <span class="comment">//enlarge or reduce allocated memory and set unused memory to zero</span>
<a name="l00586"></a><a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">00586</a> <span class="comment"></span>      <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of &amp;#39;ALIGNMENT&amp;#39;...">resize</a>(<a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> new_size, <span class="keywordtype">bool</span> preserve = <span class="keyword">true</span>)
<a name="l00587"></a>00587       {
<a name="l00588"></a>00588         assert(new_size &gt; 0);
<a name="l00589"></a>00589         
<a name="l00590"></a>00590         <span class="keywordflow">if</span> (new_size != size_)
<a name="l00591"></a>00591         {
<a name="l00592"></a>00592           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_internal_size = viennacl::tools::roundUpToNextMultiple&lt;unsigned int&gt;(new_size, ALIGNMENT);
<a name="l00593"></a>00593         
<a name="l00594"></a>00594           std::vector&lt;SCALARTYPE&gt; temp(size_);
<a name="l00595"></a>00595           <span class="keywordflow">if</span> (preserve &amp;&amp; size_ &gt; 0)
<a name="l00596"></a>00596             <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">fast_copy</a>(*<span class="keyword">this</span>, temp);
<a name="l00597"></a>00597           temp.resize(new_size);  <span class="comment">//drop all entries above new_size</span>
<a name="l00598"></a>00598           temp.resize(new_internal_size); <span class="comment">//enlarge to fit new internal size</span>
<a name="l00599"></a>00599           
<a name="l00600"></a>00600           <span class="keywordflow">if</span> (new_internal_size != <a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>())
<a name="l00601"></a>00601           {
<a name="l00602"></a>00602             elements_ = <a class="code" href="namespaceviennacl_1_1ocl.html#a0c2a174533a0aca403ff7c4aa802edcf" title="Convenience function for returning the current context.">viennacl::ocl::current_context</a>().<a class="code" href="classviennacl_1_1ocl_1_1context.html#a22299eef7ac0c36ba322a2bb25e953c5" title="Creates a memory buffer within the context.">create_memory</a>(CL_MEM_READ_WRITE, <span class="keyword">sizeof</span>(SCALARTYPE)*new_internal_size);
<a name="l00603"></a>00603           }
<a name="l00604"></a>00604           
<a name="l00605"></a>00605           <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">fast_copy</a>(temp, *<span class="keyword">this</span>);
<a name="l00606"></a>00606           size_ = new_size;
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608         
<a name="l00609"></a>00609       }
<a name="l00610"></a>00610       
<a name="l00611"></a>00611 
<a name="l00612"></a>00612       <span class="comment">//read-write access to an element of the vector</span>
<a name="l00615"></a><a class="code" href="classviennacl_1_1vector.html#ad39a7d06af546a8df947a8a36722eb03">00615</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector.html#ad39a7d06af546a8df947a8a36722eb03" title="Read-write access to a single element of the vector.">operator()</a>(<a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index)
<a name="l00616"></a>00616       {
<a name="l00617"></a>00617         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(index, elements_);
<a name="l00618"></a>00618       }
<a name="l00619"></a>00619 
<a name="l00622"></a><a class="code" href="classviennacl_1_1vector.html#af8f3f9c5c359c354201a0e4386b4cfcc">00622</a>       <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector.html#af8f3f9c5c359c354201a0e4386b4cfcc" title="Read-write access to a single element of the vector.">operator[]</a>(<a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index)
<a name="l00623"></a>00623       {
<a name="l00624"></a>00624         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1entry__proxy.html" title="A proxy class for a single element of a vector or matrix. This proxy should not be noticed by end-use...">entry_proxy&lt;SCALARTYPE&gt;</a>(index, elements_);
<a name="l00625"></a>00625       }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 
<a name="l00630"></a><a class="code" href="classviennacl_1_1vector.html#a2de1bb775af4a87ce0b792154700c414">00630</a>       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector.html#ad39a7d06af546a8df947a8a36722eb03" title="Read-write access to a single element of the vector.">operator()</a>(<a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index)<span class="keyword"> const</span>
<a name="l00631"></a>00631 <span class="keyword">      </span>{
<a name="l00632"></a>00632         <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> tmp;
<a name="l00633"></a>00633         cl_int err;
<a name="l00634"></a>00634         err = clEnqueueCopyBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>(), elements_, tmp.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>(), <span class="keyword">sizeof</span>(SCALARTYPE)*index, 0, <span class="keyword">sizeof</span>(SCALARTYPE), 0, NULL, NULL);
<a name="l00635"></a>00635         <span class="comment">//assert(err == CL_SUCCESS);</span>
<a name="l00636"></a>00636         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l00637"></a>00637         <span class="keywordflow">return</span> tmp;
<a name="l00638"></a>00638       }
<a name="l00639"></a>00639       
<a name="l00642"></a><a class="code" href="classviennacl_1_1vector.html#acd1666d8bd98191443b3b62f0944a822">00642</a>       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <a class="code" href="classviennacl_1_1vector.html#af8f3f9c5c359c354201a0e4386b4cfcc" title="Read-write access to a single element of the vector.">operator[]</a>(<a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index)<span class="keyword"> const</span>
<a name="l00643"></a>00643 <span class="keyword">      </span>{
<a name="l00644"></a>00644         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector.html#ad39a7d06af546a8df947a8a36722eb03" title="Read-write access to a single element of the vector.">operator()</a>(index);
<a name="l00645"></a>00645       }
<a name="l00646"></a>00646       
<a name="l00649"></a><a class="code" href="classviennacl_1_1vector.html#a87bf465ad5a49ddd749505935d931db3">00649</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l00650"></a>00650       {
<a name="l00651"></a>00651         <a class="code" href="namespaceviennacl_1_1linalg.html#a225d1c31fb7c1dac9f5b94f17ae1f950" title="Adds a dense matrix to another.">viennacl::linalg::inplace_add</a>(*<span class="keyword">this</span>, vec);
<a name="l00652"></a>00652         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00653"></a>00653       }
<a name="l00654"></a>00654 
<a name="l00657"></a><a class="code" href="classviennacl_1_1vector.html#abe21f33c50e397aeefd7d075ce85d259">00657</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00658"></a>00658                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00659"></a>00659                                                                            op_prod&gt; &amp; proxy)
<a name="l00660"></a>00660       {
<a name="l00661"></a>00661         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00662"></a>00662         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00663"></a>00663       }
<a name="l00664"></a>00664 
<a name="l00667"></a><a class="code" href="classviennacl_1_1vector.html#a7aeced050a63cc0314a993d12330d2ab">00667</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00668"></a>00668                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00669"></a>00669                                                                            op_prod&gt; &amp; proxy)
<a name="l00670"></a>00670       {
<a name="l00671"></a>00671         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00672"></a>00672         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00673"></a>00673       }
<a name="l00674"></a>00674 
<a name="l00677"></a><a class="code" href="classviennacl_1_1vector.html#aeddc9d15b96937b89a6122abfbb4a4b0">00677</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00678"></a>00678                                                                            <span class="keyword">const</span> SCALARTYPE,
<a name="l00679"></a>00679                                                                            op_prod&gt; &amp; proxy)
<a name="l00680"></a>00680       {
<a name="l00681"></a>00681         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00682"></a>00682         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00683"></a>00683       }
<a name="l00684"></a>00684 
<a name="l00687"></a><a class="code" href="classviennacl_1_1vector.html#a2f8d78b1c904f274f2c50ec90f9a944e">00687</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00688"></a>00688                                                                            <span class="keyword">const</span> SCALARTYPE,
<a name="l00689"></a>00689                                                                            op_prod&gt; &amp; proxy)
<a name="l00690"></a>00690       {
<a name="l00691"></a>00691         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00692"></a>00692         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00693"></a>00693       }
<a name="l00694"></a>00694 
<a name="l00697"></a><a class="code" href="classviennacl_1_1vector.html#a478742d85955289d0fef99d591d92771">00697</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3" title="Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.">operator += </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00698"></a>00698                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00699"></a>00699                                                                            op_div&gt; &amp; proxy)
<a name="l00700"></a>00700       {
<a name="l00701"></a>00701         <a class="code" href="namespaceviennacl_1_1linalg.html#abbe5a4f98fb91f55c405aa857af71d83" title="Inplace divide-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_div_add</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00702"></a>00702         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00703"></a>00703       }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 
<a name="l00706"></a>00706 
<a name="l00709"></a><a class="code" href="classviennacl_1_1vector.html#aae3c76bbb1a3e6023b1af706ce981b49">00709</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l00710"></a>00710       {
<a name="l00711"></a>00711         <a class="code" href="namespaceviennacl_1_1linalg.html#ae88903a9ae8dbc3fc47db7f37da326a6" title="Adds a dense matrix to another.">viennacl::linalg::inplace_sub</a>(*<span class="keyword">this</span>, vec);
<a name="l00712"></a>00712         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00713"></a>00713       }
<a name="l00714"></a>00714 
<a name="l00717"></a><a class="code" href="classviennacl_1_1vector.html#aea40ee2f758aa6fc99ce786efc8ef02c">00717</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00718"></a>00718                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00719"></a>00719                                                                            op_prod&gt; &amp; proxy)
<a name="l00720"></a>00720       {
<a name="l00721"></a>00721         <a class="code" href="namespaceviennacl_1_1linalg.html#ab2cf15c4dcf00b57cf6342492ab8ea8e" title="Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead...">viennacl::linalg::inplace_mul_sub</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00722"></a>00722         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00723"></a>00723       }
<a name="l00724"></a>00724 
<a name="l00727"></a><a class="code" href="classviennacl_1_1vector.html#afb6860261a249d443031fcaa6940806a">00727</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00728"></a>00728                                                                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00729"></a>00729                                                                            op_prod&gt; &amp; proxy)
<a name="l00730"></a>00730       {
<a name="l00731"></a>00731         <a class="code" href="namespaceviennacl_1_1linalg.html#ab2cf15c4dcf00b57cf6342492ab8ea8e" title="Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead...">viennacl::linalg::inplace_mul_sub</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00732"></a>00732         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00733"></a>00733       }
<a name="l00734"></a>00734 
<a name="l00737"></a><a class="code" href="classviennacl_1_1vector.html#a067bc8f3532c3d398671ede297159c18">00737</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00738"></a>00738                                                                             <span class="keyword">const</span> SCALARTYPE,
<a name="l00739"></a>00739                                                                             op_prod&gt; &amp; proxy)
<a name="l00740"></a>00740       {
<a name="l00741"></a>00741         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(*<span class="keyword">this</span>, proxy.lhs(), -proxy.rhs());
<a name="l00742"></a>00742         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00743"></a>00743       }
<a name="l00744"></a>00744 
<a name="l00747"></a><a class="code" href="classviennacl_1_1vector.html#a32ebaa055c897b1a6f3ea49e3b7022dd">00747</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00748"></a>00748                                                                             <span class="keyword">const</span> SCALARTYPE,
<a name="l00749"></a>00749                                                                             op_prod&gt; &amp; proxy)
<a name="l00750"></a>00750       {
<a name="l00751"></a>00751         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(*<span class="keyword">this</span>, proxy.lhs(), -proxy.rhs());
<a name="l00752"></a>00752         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00753"></a>00753       }
<a name="l00754"></a>00754       
<a name="l00757"></a><a class="code" href="classviennacl_1_1vector.html#a983376d820f950a2bc06d987a604c9b3">00757</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68" title="Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.">operator -= </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00758"></a>00758                                                                             <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00759"></a>00759                                                                             op_div&gt; &amp; proxy)
<a name="l00760"></a>00760       {
<a name="l00761"></a>00761         <a class="code" href="namespaceviennacl_1_1linalg.html#aad1b78ccd178079d1c3c503b6810dd21" title="Inplace divide-subtract operation. Try to use the overloaded operators for vector instead...">viennacl::linalg::inplace_div_sub</a>(*<span class="keyword">this</span>, proxy.lhs(), proxy.rhs());
<a name="l00762"></a>00762         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00763"></a>00763       }
<a name="l00764"></a>00764       
<a name="l00765"></a>00765       
<a name="l00766"></a>00766       
<a name="l00767"></a>00767 
<a name="l00770"></a><a class="code" href="classviennacl_1_1vector.html#adad7d33d0bb340be923ded4b7050867b">00770</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#adad7d33d0bb340be923ded4b7050867b" title="Scales this vector by a CPU scalar value.">operator *= </a>(SCALARTYPE val)
<a name="l00771"></a>00771       {
<a name="l00772"></a>00772         <a class="code" href="namespaceviennacl_1_1linalg.html#a0e4c7521b309670969d542805ac87b35" title="Multiplies a dense matrix by a scalar.">viennacl::linalg::inplace_mult</a>(*<span class="keyword">this</span>, val);
<a name="l00773"></a>00773         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00774"></a>00774       }
<a name="l00775"></a>00775 
<a name="l00778"></a><a class="code" href="classviennacl_1_1vector.html#a32d20bcbd10c909d2041c30cc942f080">00778</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#adad7d33d0bb340be923ded4b7050867b" title="Scales this vector by a CPU scalar value.">operator *= </a>(<a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; gpu_val)
<a name="l00779"></a>00779       {
<a name="l00780"></a>00780         <a class="code" href="namespaceviennacl_1_1linalg.html#a0e4c7521b309670969d542805ac87b35" title="Multiplies a dense matrix by a scalar.">viennacl::linalg::inplace_mult</a>(*<span class="keyword">this</span>, gpu_val);
<a name="l00781"></a>00781         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00782"></a>00782       }
<a name="l00783"></a>00783 
<a name="l00786"></a><a class="code" href="classviennacl_1_1vector.html#af6ba5ebda72ab395ad1a1e5504088976">00786</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#af6ba5ebda72ab395ad1a1e5504088976" title="Scales this vector by a CPU scalar value.">operator /= </a>(SCALARTYPE val)
<a name="l00787"></a>00787       {
<a name="l00788"></a>00788         <a class="code" href="namespaceviennacl_1_1linalg.html#a0e4c7521b309670969d542805ac87b35" title="Multiplies a dense matrix by a scalar.">viennacl::linalg::inplace_mult</a>(*<span class="keyword">this</span>, static_cast&lt;SCALARTYPE&gt;(1) / val);
<a name="l00789"></a>00789         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00790"></a>00790       }
<a name="l00791"></a>00791       
<a name="l00794"></a><a class="code" href="classviennacl_1_1vector.html#a3ffe49fc9f161ce2ea1fb130cd0195ca">00794</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#af6ba5ebda72ab395ad1a1e5504088976" title="Scales this vector by a CPU scalar value.">operator /= </a>(<a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; gpu_val)
<a name="l00795"></a>00795       {
<a name="l00796"></a>00796         <a class="code" href="namespaceviennacl_1_1linalg.html#a6e86b6169a6ff7495734d3eef5d4fd33" title="Multiplies a dense matrix by a scalar.">viennacl::linalg::inplace_divide</a>(*<span class="keyword">this</span>, gpu_val);
<a name="l00797"></a>00797         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00798"></a>00798       }
<a name="l00799"></a>00799       
<a name="l00800"></a>00800       
<a name="l00801"></a>00801       
<a name="l00802"></a>00802       <span class="comment">// free addition</span>
<a name="l00803"></a>00803       
<a name="l00806"></a><a class="code" href="classviennacl_1_1vector.html#a87db4b1001dea6bfc9b47d1e07028552">00806</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)<span class="keyword"> const</span>
<a name="l00807"></a>00807 <span class="keyword">      </span>{
<a name="l00808"></a>00808         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>());
<a name="l00809"></a>00809         <a class="code" href="namespaceviennacl_1_1linalg.html#a2777d6a19ce110ae9df6609f1677be0f" title="Adds two dense matrices and writes the result to a third matrix.">viennacl::linalg::add</a>(*<span class="keyword">this</span>, vec, result);
<a name="l00810"></a>00810         <span class="keywordflow">return</span> result;
<a name="l00811"></a>00811       }
<a name="l00812"></a>00812       
<a name="l00815"></a><a class="code" href="classviennacl_1_1vector.html#abf44eeb0d6aebf7fac80026eb2aaff11">00815</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00816"></a>00816                                                                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00817"></a>00817                                                                            op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00818"></a>00818 <span class="keyword">      </span>{
<a name="l00819"></a>00819         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00820"></a>00820         <a class="code" href="namespaceviennacl_1_1linalg.html#a6047863f8fb097162ffad8b1b847d1df" title="Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fi...">viennacl::linalg::mul_add</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, result);
<a name="l00821"></a>00821         <span class="keywordflow">return</span> result;
<a name="l00822"></a>00822       }
<a name="l00823"></a>00823 
<a name="l00826"></a><a class="code" href="classviennacl_1_1vector.html#ae642a9b7a6e50936342bced1c2cc2aa9">00826</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00827"></a>00827                                                                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00828"></a>00828                                                                            op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00829"></a>00829 <span class="keyword">      </span>{
<a name="l00830"></a>00830         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00831"></a>00831         <a class="code" href="namespaceviennacl_1_1linalg.html#a6047863f8fb097162ffad8b1b847d1df" title="Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fi...">viennacl::linalg::mul_add</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, result);
<a name="l00832"></a>00832         <span class="keywordflow">return</span> result;
<a name="l00833"></a>00833       }
<a name="l00834"></a>00834 
<a name="l00837"></a><a class="code" href="classviennacl_1_1vector.html#a8c0fb94a7256a1afe4c16c4d54db7316">00837</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00838"></a>00838                                                                          <span class="keyword">const</span> SCALARTYPE,
<a name="l00839"></a>00839                                                                          op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00840"></a>00840 <span class="keyword">      </span>{
<a name="l00841"></a>00841         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00842"></a>00842         <a class="code" href="namespaceviennacl_1_1linalg.html#a6047863f8fb097162ffad8b1b847d1df" title="Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fi...">viennacl::linalg::mul_add</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, result);
<a name="l00843"></a>00843         <span class="keywordflow">return</span> result;
<a name="l00844"></a>00844       }
<a name="l00845"></a>00845 
<a name="l00848"></a><a class="code" href="classviennacl_1_1vector.html#a735ecd24c5432dbf339e9bf6a4bfefb6">00848</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973" title="Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.">operator + </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00849"></a>00849                                                                          <span class="keyword">const</span> SCALARTYPE,
<a name="l00850"></a>00850                                                                          op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00851"></a>00851 <span class="keyword">      </span>{
<a name="l00852"></a>00852         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00853"></a>00853         <a class="code" href="namespaceviennacl_1_1linalg.html#a6047863f8fb097162ffad8b1b847d1df" title="Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fi...">viennacl::linalg::mul_add</a>(proxy.lhs(), proxy.rhs(), *<span class="keyword">this</span>, result);
<a name="l00854"></a>00854         <span class="keywordflow">return</span> result;
<a name="l00855"></a>00855       }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 
<a name="l00858"></a>00858       <span class="comment">//free subtraction:</span>
<a name="l00861"></a><a class="code" href="classviennacl_1_1vector.html#ab4b953de766b713cf2016e69b75233de">00861</a> <span class="comment"></span>      <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)<span class="keyword"> const</span>
<a name="l00862"></a>00862 <span class="keyword">      </span>{
<a name="l00863"></a>00863         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00864"></a>00864         <a class="code" href="namespaceviennacl_1_1linalg.html#a707ace72b7ff8ad1e3a9ff2606567f1e" title="Adds two dense matrices and writes the result to a third matrix.">viennacl::linalg::sub</a>(*<span class="keyword">this</span>, vec, result);
<a name="l00865"></a>00865         <span class="keywordflow">return</span> result;
<a name="l00866"></a>00866       }
<a name="l00867"></a>00867 
<a name="l00870"></a><a class="code" href="classviennacl_1_1vector.html#a1f057bb893f457b22ddd46aecc973469">00870</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00871"></a>00871                                                                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00872"></a>00872                                                                            op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00873"></a>00873 <span class="keyword">      </span>{
<a name="l00874"></a>00874         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00875"></a>00875         result = *<span class="keyword">this</span>;
<a name="l00876"></a>00876         <a class="code" href="namespaceviennacl_1_1linalg.html#ab2cf15c4dcf00b57cf6342492ab8ea8e" title="Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead...">viennacl::linalg::inplace_mul_sub</a>(result, proxy.lhs(), proxy.rhs());
<a name="l00877"></a>00877         <span class="keywordflow">return</span> result;
<a name="l00878"></a>00878       }
<a name="l00879"></a>00879 
<a name="l00882"></a><a class="code" href="classviennacl_1_1vector.html#ab6a6205580e81d2e2e477f55b75f8645">00882</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00883"></a>00883                                                                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>,
<a name="l00884"></a>00884                                                                            op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00885"></a>00885 <span class="keyword">      </span>{
<a name="l00886"></a>00886         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00887"></a>00887         result = *<span class="keyword">this</span>;
<a name="l00888"></a>00888         <a class="code" href="namespaceviennacl_1_1linalg.html#ab2cf15c4dcf00b57cf6342492ab8ea8e" title="Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead...">viennacl::linalg::inplace_mul_sub</a>(result, proxy.lhs(), proxy.rhs());
<a name="l00889"></a>00889         <span class="keywordflow">return</span> result;
<a name="l00890"></a>00890       }
<a name="l00891"></a>00891 
<a name="l00894"></a><a class="code" href="classviennacl_1_1vector.html#a7b6c480cbd1da3812d587a729983fc4f">00894</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00895"></a>00895                                                                          <span class="keyword">const</span> SCALARTYPE,
<a name="l00896"></a>00896                                                                          op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00897"></a>00897 <span class="keyword">      </span>{
<a name="l00898"></a>00898         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00899"></a>00899         result = *<span class="keyword">this</span>;
<a name="l00900"></a>00900         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(result, proxy.lhs(), -proxy.rhs());
<a name="l00901"></a>00901         <span class="keywordflow">return</span> result;
<a name="l00902"></a>00902       }
<a name="l00903"></a>00903 
<a name="l00906"></a><a class="code" href="classviennacl_1_1vector.html#a92159381dc559d8caac28099589b85cf">00906</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <a class="code" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1" title="Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.">operator - </a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression</a>&lt; <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>,
<a name="l00907"></a>00907                                                                          <span class="keyword">const</span> SCALARTYPE,
<a name="l00908"></a>00908                                                                          op_prod&gt; &amp; proxy)<span class="keyword"> const</span>
<a name="l00909"></a>00909 <span class="keyword">      </span>{
<a name="l00910"></a>00910         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> result(size_);
<a name="l00911"></a>00911         result = *<span class="keyword">this</span>;
<a name="l00912"></a>00912         <a class="code" href="namespaceviennacl_1_1linalg.html#a7fadfccd4d7dd18f74cbe448302236e7" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.">viennacl::linalg::inplace_mul_add</a>(result, proxy.lhs(), -proxy.rhs());
<a name="l00913"></a>00913         <span class="keywordflow">return</span> result;
<a name="l00914"></a>00914       }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916       
<a name="l00917"></a>00917       <span class="comment">//free multiplication</span>
<a name="l00920"></a>00920 <span class="comment"></span>      <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_prod&gt; 
<a name="l00921"></a><a class="code" href="classviennacl_1_1vector.html#a0273e98b77b6a89e60116358fe27cc9d">00921</a>       <a class="code" href="classviennacl_1_1vector.html#a0273e98b77b6a89e60116358fe27cc9d" title="Scales the vector by a CPU scalar &amp;#39;alpha&amp;#39; and returns an expression template.">operator * </a>(SCALARTYPE <a class="code" href="namespaceviennacl_1_1io_1_1tag.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>)<span class="keyword"> const</span>
<a name="l00922"></a>00922 <span class="keyword">      </span>{
<a name="l00923"></a>00923         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_prod&gt;(*<span class="keyword">this</span>, value);
<a name="l00924"></a>00924       }
<a name="l00925"></a>00925 
<a name="l00928"></a>00928       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>, op_prod&gt; 
<a name="l00929"></a><a class="code" href="classviennacl_1_1vector.html#a3ff0ebfa2e17bab4dbad38c0cd50d948">00929</a>       <a class="code" href="classviennacl_1_1vector.html#a0273e98b77b6a89e60116358fe27cc9d" title="Scales the vector by a CPU scalar &amp;#39;alpha&amp;#39; and returns an expression template.">operator * </a>(<a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1tag.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>)<span class="keyword"> const</span>
<a name="l00930"></a>00930 <span class="keyword">      </span>{
<a name="l00931"></a>00931         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>, op_prod&gt;(*<span class="keyword">this</span>, value);
<a name="l00932"></a>00932       }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934       <span class="comment">//free division</span>
<a name="l00937"></a>00937 <span class="comment"></span>      <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_div&gt; 
<a name="l00938"></a><a class="code" href="classviennacl_1_1vector.html#ad87b95d3c182effc15136d7c610200af">00938</a>       <a class="code" href="classviennacl_1_1vector.html#ad87b95d3c182effc15136d7c610200af" title="Scales the vector by a CPU scalar &amp;#39;alpha&amp;#39; and returns an expression template.">operator / </a>(SCALARTYPE <a class="code" href="namespaceviennacl_1_1io_1_1tag.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>)<span class="keyword"> const</span>
<a name="l00939"></a>00939 <span class="keyword">      </span>{
<a name="l00940"></a>00940         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_div&gt;(*<span class="keyword">this</span>, value);
<a name="l00941"></a>00941       }
<a name="l00942"></a>00942 
<a name="l00945"></a>00945       <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>, op_div&gt; 
<a name="l00946"></a><a class="code" href="classviennacl_1_1vector.html#ad309219e4080cb6a6427f3321d159b2c">00946</a>       <a class="code" href="classviennacl_1_1vector.html#ad87b95d3c182effc15136d7c610200af" title="Scales the vector by a CPU scalar &amp;#39;alpha&amp;#39; and returns an expression template.">operator / </a>(<a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1tag.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>)<span class="keyword"> const</span>
<a name="l00947"></a>00947 <span class="keyword">      </span>{
<a name="l00948"></a>00948         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, ALIGNMENT&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>, op_div&gt;(*<span class="keyword">this</span>, value);
<a name="l00949"></a>00949       }
<a name="l00950"></a>00950       
<a name="l00951"></a>00951       
<a name="l00953"></a>00953 
<a name="l00954"></a><a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8">00954</a>       <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">iterator</a> <a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>()
<a name="l00955"></a>00955       {
<a name="l00956"></a>00956         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector.html#a589223a5e682b4a61d57bb8742b1cec9">iterator</a>(*<span class="keyword">this</span>, 0);
<a name="l00957"></a>00957       }
<a name="l00958"></a>00958 
<a name="l00960"></a><a class="code" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f">00960</a>       <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">iterator</a> <a class="code" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like).">end</a>()
<a name="l00961"></a>00961       {
<a name="l00962"></a>00962         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector.html#a589223a5e682b4a61d57bb8742b1cec9">iterator</a>(*<span class="keyword">this</span>, <a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00963"></a>00963       }
<a name="l00964"></a>00964 
<a name="l00966"></a><a class="code" href="classviennacl_1_1vector.html#aa4b02d4f1a8500fb07a551069060709f">00966</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_iterator</a> <a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>()<span class="keyword"> const</span>
<a name="l00967"></a>00967 <span class="keyword">      </span>{
<a name="l00968"></a>00968         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector.html#a5b0cecdbbf962357b5dc5f79dcae2d66">const_iterator</a>(*<span class="keyword">this</span>, 0);
<a name="l00969"></a>00969       }
<a name="l00970"></a>00970 
<a name="l00972"></a><a class="code" href="classviennacl_1_1vector.html#a350132543d80a1c1e5be844e6d2878ea">00972</a>       <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_iterator</a> <a class="code" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like).">end</a>()<span class="keyword"> const</span>
<a name="l00973"></a>00973 <span class="keyword">      </span>{
<a name="l00974"></a>00974         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector.html#a5b0cecdbbf962357b5dc5f79dcae2d66">const_iterator</a>(*<span class="keyword">this</span>, <a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00975"></a>00975       }
<a name="l00976"></a>00976 
<a name="l00979"></a><a class="code" href="classviennacl_1_1vector.html#af5a080ddc0576cfba4c7494ff8eccb09">00979</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#af5a080ddc0576cfba4c7494ff8eccb09" title="Swaps the entries of the two vectors.">swap</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; other)
<a name="l00980"></a>00980       {
<a name="l00981"></a>00981         <a class="code" href="classviennacl_1_1vector.html#af5a080ddc0576cfba4c7494ff8eccb09" title="Swaps the entries of the two vectors.">swap</a>(*<span class="keyword">this</span>, other);
<a name="l00982"></a>00982         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00983"></a>00983       };
<a name="l00984"></a>00984       
<a name="l00987"></a><a class="code" href="classviennacl_1_1vector.html#a3f3c31234d9a1c823383bd6e8c2c9222">00987</a>       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#a3f3c31234d9a1c823383bd6e8c2c9222" title="Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.">fast_swap</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; other) 
<a name="l00988"></a>00988       { 
<a name="l00989"></a>00989         assert(this-&gt;size_ == other.size_); 
<a name="l00990"></a>00990         this-&gt;elements_.<a class="code" href="classviennacl_1_1ocl_1_1handle.html#aca2a2fe50e9519f31c07e34d56a2a5eb" title="Swaps the OpenCL handle of two handle objects.">swap</a>(other.elements_); 
<a name="l00991"></a>00991         <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l00992"></a>00992       };       
<a name="l00993"></a>00993       
<a name="l00996"></a><a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7">00996</a>       <a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_; }
<a name="l00997"></a>00997       
<a name="l01000"></a><a class="code" href="classviennacl_1_1vector.html#a0ab5ce862c0331d9e45a6e1774fca131">01000</a>       <a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1vector.html#a0ab5ce862c0331d9e45a6e1774fca131" title="Returns the maximum possible size of the vector, which is given by 128 MByte due to limitations by Op...">max_size</a>()<span class="keyword"> const</span>
<a name="l01001"></a>01001 <span class="keyword">      </span>{
<a name="l01002"></a>01002         <span class="keywordflow">return</span> (128*1024*1024) / <span class="keyword">sizeof</span>(SCALARTYPE);  <span class="comment">//128 MB is maximum size of memory chunks in OpenCL!</span>
<a name="l01003"></a>01003       }
<a name="l01006"></a><a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c">01006</a>       <a class="code" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> <a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> viennacl::tools::roundUpToNextMultiple&lt;size_type&gt;(size_, ALIGNMENT); }
<a name="l01007"></a>01007       
<a name="l01009"></a><a class="code" href="classviennacl_1_1vector.html#a3f37b042a1e7cd4bd38fc564de81f0da">01009</a>       <span class="keywordtype">bool</span> <a class="code" href="classviennacl_1_1vector.html#a3f37b042a1e7cd4bd38fc564de81f0da" title="Returns true is the size is zero.">empty</a>() { <span class="keywordflow">return</span> size_ == 0; }
<a name="l01010"></a>01010       
<a name="l01012"></a><a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c">01012</a>       <span class="keyword">const</span> <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> &amp; <a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute viennacl::ocl::...">handle</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> elements_; }
<a name="l01013"></a>01013 
<a name="l01016"></a><a class="code" href="classviennacl_1_1vector.html#ac8bb3912a3ce86b15842e79d0b421204">01016</a>       <span class="keywordtype">void</span> <a class="code" href="classviennacl_1_1vector.html#ac8bb3912a3ce86b15842e79d0b421204" title="Resets all entries to zero. Does not change the size of the vector.">clear</a>()
<a name="l01017"></a>01017       {
<a name="l01018"></a>01018         <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = <a class="code" href="namespaceviennacl_1_1ocl.html#a61a73653d92f1eb2ef9c649ec253e29f" title="Convenience function for getting the kernel for a particular program from the current active context...">viennacl::ocl::get_kernel</a>(viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::program_name(), <span class="stringliteral">&quot;clear&quot;</span>);
<a name="l01019"></a>01019         
<a name="l01020"></a>01020         <a class="code" href="namespaceviennacl_1_1ocl.html#a46527eb5023de820b1f1c16ec5a11084" title="Enqueues a kernel in the provided queue.">viennacl::ocl::enqueue</a>(k(elements_, static_cast&lt;cl_uint&gt;(<a class="code" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size</a>())));
<a name="l01021"></a>01021       }
<a name="l01022"></a>01022       <span class="comment">//void swap(vector &amp; other){}</span>
<a name="l01023"></a>01023       
<a name="l01024"></a>01024 
<a name="l01025"></a>01025       <span class="comment">//TODO: Think about implementing the following public member functions</span>
<a name="l01026"></a>01026       <span class="comment">//void insert_element(unsigned int i, SCALARTYPE val){}</span>
<a name="l01027"></a>01027       <span class="comment">//void erase_element(unsigned int i){}</span>
<a name="l01028"></a>01028       
<a name="l01029"></a>01029     <span class="keyword">private</span>:
<a name="l01030"></a>01030       cl_uint size_;
<a name="l01031"></a>01031       <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> elements_;
<a name="l01032"></a>01032     }; <span class="comment">//vector</span>
<a name="l01033"></a>01033     
<a name="l01034"></a>01034 
<a name="l01035"></a>01035     <span class="comment">//</span>
<a name="l01037"></a>01037 <span class="comment"></span>    <span class="comment">//</span>
<a name="l01038"></a>01038     
<a name="l01045"></a>01045     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01046"></a><a class="code" href="namespaceviennacl.html#a7953e64a62d2209621a3f4a505dc9f9e">01046</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_begin,
<a name="l01047"></a>01047               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_end,
<a name="l01048"></a>01048               CPU_ITERATOR cpu_begin )
<a name="l01049"></a>01049     {
<a name="l01050"></a>01050       assert(gpu_end - gpu_begin &gt;= 0);
<a name="l01051"></a>01051       <span class="keywordflow">if</span> (gpu_end - gpu_begin != 0)
<a name="l01052"></a>01052       {
<a name="l01053"></a>01053         std::vector&lt;SCALARTYPE&gt; temp_buffer(gpu_end - gpu_begin);
<a name="l01054"></a>01054         cl_int err = clEnqueueReadBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().handle(),
<a name="l01055"></a>01055                                          gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a625da5e66b023a7ed067040a21ec834d">handle</a>(), CL_TRUE, 0, 
<a name="l01056"></a>01056                                          <span class="keyword">sizeof</span>(SCALARTYPE)*(gpu_end - gpu_begin),
<a name="l01057"></a>01057                                          &amp;(temp_buffer[0]), 0, NULL, NULL);
<a name="l01058"></a>01058         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l01059"></a>01059         <a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1ocl_1_1command__queue.html#adc3c5cffb594b811f8a851924349af5b" title="Waits until all kernels in the queue have finished their execution.">finish</a>();
<a name="l01060"></a>01060         
<a name="l01061"></a>01061         <span class="comment">//now copy entries to cpu_vec:</span>
<a name="l01062"></a>01062         <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">std::copy</a>(temp_buffer.begin(), temp_buffer.end(), cpu_begin);
<a name="l01063"></a>01063       }
<a name="l01064"></a>01064     }
<a name="l01065"></a>01065 
<a name="l01072"></a>01072     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01073"></a><a class="code" href="namespaceviennacl.html#a6713b60b19010992ea611ef7ecd4fdf2">01073</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_begin,
<a name="l01074"></a>01074               <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_end,
<a name="l01075"></a>01075               CPU_ITERATOR cpu_begin )
<a name="l01076"></a>01076 
<a name="l01077"></a>01077     {
<a name="l01078"></a>01078       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>(gpu_begin),
<a name="l01079"></a>01079            <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>(gpu_end),
<a name="l01080"></a>01080            cpu_begin);
<a name="l01081"></a>01081     }
<a name="l01082"></a>01082     
<a name="l01088"></a>01088     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPUVECTOR&gt;
<a name="l01089"></a><a class="code" href="namespaceviennacl.html#afb5884675d2f3a9ca1a57a3a722aa78a">01089</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <span class="keyword">const</span> &amp; gpu_vec,
<a name="l01090"></a>01090               CPUVECTOR &amp; cpu_vec )
<a name="l01091"></a>01091     {
<a name="l01092"></a>01092       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(gpu_vec.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>(), gpu_vec.<a class="code" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like).">end</a>(), cpu_vec.begin());
<a name="l01093"></a>01093     }
<a name="l01094"></a>01094 
<a name="l01095"></a>01095     <span class="comment">//from gpu to cpu. Type assumption: cpu_vec lies in a linear memory chunk</span>
<a name="l01107"></a>01107 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01108"></a><a class="code" href="namespaceviennacl.html#a9c694a91cf3e54637ed6a05ab7d9ce75">01108</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">fast_copy</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_begin,
<a name="l01109"></a>01109                    <span class="keyword">const</span> <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_end,
<a name="l01110"></a>01110                    CPU_ITERATOR cpu_begin )
<a name="l01111"></a>01111     {
<a name="l01112"></a>01112       <span class="keywordflow">if</span> (gpu_begin != gpu_end)
<a name="l01113"></a>01113       {
<a name="l01114"></a>01114         cl_int err = clEnqueueReadBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().handle(),
<a name="l01115"></a>01115                                          gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a625da5e66b023a7ed067040a21ec834d">handle</a>(), CL_TRUE, 0,
<a name="l01116"></a>01116                                          <span class="keyword">sizeof</span>(SCALARTYPE)*(gpu_end - gpu_begin),
<a name="l01117"></a>01117                                          &amp;(*cpu_begin), 0, NULL, NULL);
<a name="l01118"></a>01118         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l01119"></a>01119         <a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1ocl_1_1command__queue.html#adc3c5cffb594b811f8a851924349af5b" title="Waits until all kernels in the queue have finished their execution.">finish</a>();
<a name="l01120"></a>01120       }
<a name="l01121"></a>01121     }
<a name="l01122"></a>01122 
<a name="l01128"></a>01128     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPUVECTOR&gt;
<a name="l01129"></a><a class="code" href="namespaceviennacl.html#aad3621936e6071d2777aae22a5f891ec">01129</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">fast_copy</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> <span class="keyword">const</span> &amp; gpu_vec,
<a name="l01130"></a>01130                    CPUVECTOR &amp; cpu_vec )
<a name="l01131"></a>01131     {
<a name="l01132"></a>01132       <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">viennacl::fast_copy</a>(gpu_vec.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>(), gpu_vec.<a class="code" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like).">end</a>(), cpu_vec.begin());
<a name="l01133"></a>01133     }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 
<a name="l01137"></a>01137 <span class="preprocessor">    #ifdef VIENNACL_HAVE_EIGEN</span>
<a name="l01138"></a>01138 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01139"></a>01139     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(vector&lt;float, ALIGNMENT&gt; <span class="keyword">const</span> &amp; gpu_vec,
<a name="l01140"></a>01140               Eigen::VectorXf &amp; eigen_vec)
<a name="l01141"></a>01141     {
<a name="l01142"></a>01142       <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">viennacl::fast_copy</a>(gpu_vec.begin(), gpu_vec.end(), &amp;(eigen_vec[0]));
<a name="l01143"></a>01143     }
<a name="l01144"></a>01144     
<a name="l01145"></a>01145     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01146"></a>01146     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(vector&lt;double, ALIGNMENT&gt; &amp; gpu_vec,
<a name="l01147"></a>01147               Eigen::VectorXd &amp; eigen_vec)
<a name="l01148"></a>01148     {
<a name="l01149"></a>01149       <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">viennacl::fast_copy</a>(gpu_vec.begin(), gpu_vec.end(), &amp;(eigen_vec[0]));
<a name="l01150"></a>01150     }
<a name="l01151"></a>01151 <span class="preprocessor">    #endif</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span>
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     <span class="comment">//</span>
<a name="l01156"></a>01156 <span class="comment"></span>    <span class="comment">//</span>
<a name="l01157"></a>01157 
<a name="l01158"></a>01158     <span class="comment">//from cpu to gpu. Safe assumption: cpu_vector does not necessarily occupy a linear memory segment, but is not larger than the allocated memory on the GPU</span>
<a name="l01165"></a>01165 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01166"></a><a class="code" href="namespaceviennacl.html#afb1db189fa5cd8ee4a8222d8b87f3ab0">01166</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_begin,
<a name="l01167"></a>01167               CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_end,
<a name="l01168"></a>01168               <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> gpu_begin)
<a name="l01169"></a>01169     {
<a name="l01170"></a>01170       <span class="keywordflow">if</span> (cpu_begin != cpu_end)
<a name="l01171"></a>01171       {
<a name="l01172"></a>01172         <span class="comment">//we require that the size of the gpu_vector is larger or equal to the cpu-size</span>
<a name="l01173"></a>01173         std::vector&lt;SCALARTYPE&gt; temp_buffer(cpu_end - cpu_begin);
<a name="l01174"></a>01174         <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">std::copy</a>(cpu_begin, cpu_end, temp_buffer.begin());
<a name="l01175"></a>01175         cl_int err = clEnqueueWriteBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().handle(),
<a name="l01176"></a>01176                                           gpu_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#a7e12b10e3e03ef763a5aa8a70eb21aa7">handle</a>(), CL_TRUE, <span class="keyword">sizeof</span>(SCALARTYPE)*gpu_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>(),
<a name="l01177"></a>01177                                           <span class="keyword">sizeof</span>(SCALARTYPE)*(cpu_end - cpu_begin),
<a name="l01178"></a>01178                                           &amp;(temp_buffer[0]), 0, NULL, NULL);
<a name="l01179"></a>01179         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l01180"></a>01180       }
<a name="l01181"></a>01181     }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     <span class="comment">// for things like copy(std_vec.begin(), std_vec.end(), vcl_vec.begin() + 1);</span>
<a name="l01184"></a>01184     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01185"></a><a class="code" href="namespaceviennacl.html#a12da6187594db18ae7aa4874e1ad3f1d">01185</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_begin,
<a name="l01186"></a>01186               CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_end,
<a name="l01187"></a>01187               <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> gpu_begin)
<a name="l01188"></a>01188     {
<a name="l01189"></a>01189       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(cpu_begin, cpu_end, <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a>(gpu_begin));
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191 
<a name="l01197"></a>01197     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPUVECTOR&gt;
<a name="l01198"></a><a class="code" href="namespaceviennacl.html#a0d4fd919fa235b1c7dabd0049740e774">01198</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<span class="keyword">const</span> CPUVECTOR &amp; cpu_vec, <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_vec)
<a name="l01199"></a>01199     {
<a name="l01200"></a>01200       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(cpu_vec.begin(), cpu_vec.end(), gpu_vec.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>());
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202 
<a name="l01214"></a>01214     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPU_ITERATOR&gt;
<a name="l01215"></a><a class="code" href="namespaceviennacl.html#a9250bb8c996f6eab600899146e0cbf26">01215</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">fast_copy</a>(CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_begin,
<a name="l01216"></a>01216                    CPU_ITERATOR <span class="keyword">const</span> &amp; cpu_end,
<a name="l01217"></a>01217                    <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT&gt;</a> gpu_begin)
<a name="l01218"></a>01218     {
<a name="l01219"></a>01219       <span class="keywordflow">if</span> (cpu_begin != cpu_end)
<a name="l01220"></a>01220       {
<a name="l01221"></a>01221         <span class="comment">//we require that the size of the gpu_vector is larger or equal to the cpu-size</span>
<a name="l01222"></a>01222         cl_int err = clEnqueueWriteBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().handle(), 
<a name="l01223"></a>01223                                           gpu_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#a7e12b10e3e03ef763a5aa8a70eb21aa7">handle</a>(), CL_TRUE, 0, 
<a name="l01224"></a>01224                                           <span class="keyword">sizeof</span>(SCALARTYPE)*(cpu_end - cpu_begin), &amp;(*cpu_begin), 0, NULL, NULL);
<a name="l01225"></a>01225         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l01226"></a>01226       }
<a name="l01227"></a>01227     }
<a name="l01228"></a>01228 
<a name="l01229"></a>01229 
<a name="l01235"></a>01235     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT, <span class="keyword">typename</span> CPUVECTOR&gt;
<a name="l01236"></a><a class="code" href="namespaceviennacl.html#af7146b5952b3532c74728adc05d4de55">01236</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">fast_copy</a>(<span class="keyword">const</span> CPUVECTOR &amp; cpu_vec, <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; gpu_vec)
<a name="l01237"></a>01237     {
<a name="l01238"></a>01238       <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">viennacl::fast_copy</a>(cpu_vec.begin(), cpu_vec.end(), gpu_vec.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>());
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="preprocessor">    #ifdef VIENNACL_HAVE_EIGEN</span>
<a name="l01242"></a>01242 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01243"></a>01243     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(Eigen::VectorXf <span class="keyword">const</span> &amp; eigen_vec,
<a name="l01244"></a>01244               vector&lt;float, ALIGNMENT&gt; &amp; gpu_vec)
<a name="l01245"></a>01245     {
<a name="l01246"></a>01246       std::vector&lt;float&gt; entries(eigen_vec.size());
<a name="l01247"></a>01247       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt;entries.size(); ++i)
<a name="l01248"></a>01248         entries[i] = eigen_vec(i);
<a name="l01249"></a>01249       <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">viennacl::fast_copy</a>(entries.begin(), entries.end(), gpu_vec.begin());
<a name="l01250"></a>01250     }
<a name="l01251"></a>01251     
<a name="l01252"></a>01252     <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01253"></a>01253     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(Eigen::VectorXd <span class="keyword">const</span> &amp; eigen_vec,
<a name="l01254"></a>01254               vector&lt;double, ALIGNMENT&gt; &amp; gpu_vec)
<a name="l01255"></a>01255     {
<a name="l01256"></a>01256       std::vector&lt;double&gt; entries(eigen_vec.size());
<a name="l01257"></a>01257       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt;entries.size(); ++i)
<a name="l01258"></a>01258         entries[i] = eigen_vec(i);
<a name="l01259"></a>01259       <a class="code" href="namespaceviennacl.html#ab917c8f27a8f1cf7b8d6be54989efb99" title="Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU) without tempor...">viennacl::fast_copy</a>(entries.begin(), entries.end(), gpu_vec.begin());
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261 <span class="preprocessor">    #endif</span>
<a name="l01262"></a>01262 <span class="preprocessor"></span>    
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 
<a name="l01265"></a>01265     <span class="comment">//</span>
<a name="l01267"></a>01267 <span class="comment"></span>    <span class="comment">//</span>
<a name="l01274"></a>01274 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_SRC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_DEST&gt;
<a name="l01275"></a><a class="code" href="namespaceviennacl.html#af638a30a9dd2001143b4c92072c76d48">01275</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_begin,
<a name="l01276"></a>01276               <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_end,
<a name="l01277"></a>01277               <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a> gpu_dest_begin)
<a name="l01278"></a>01278     {
<a name="l01279"></a>01279       assert(gpu_src_end - gpu_src_begin &gt;= 0);
<a name="l01280"></a>01280       <span class="keywordflow">if</span> (gpu_src_begin != gpu_src_end)
<a name="l01281"></a>01281       {
<a name="l01282"></a>01282         cl_int err = clEnqueueCopyBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().handle(),
<a name="l01283"></a>01283                                           gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a625da5e66b023a7ed067040a21ec834d">handle</a>(),  <span class="comment">//src handle</span>
<a name="l01284"></a>01284                                           gpu_dest_begin.<a class="code" href="classviennacl_1_1vector__iterator.html#a7e12b10e3e03ef763a5aa8a70eb21aa7">handle</a>(), <span class="comment">//dest handle</span>
<a name="l01285"></a>01285                                           <span class="keyword">sizeof</span>(SCALARTYPE) * gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>(), <span class="comment">//src offset</span>
<a name="l01286"></a>01286                                           <span class="keyword">sizeof</span>(SCALARTYPE) * gpu_dest_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>(), <span class="comment">//dest offset</span>
<a name="l01287"></a>01287                                           <span class="keyword">sizeof</span>(SCALARTYPE) * (gpu_src_end.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>() - gpu_src_begin.<a class="code" href="classviennacl_1_1const__vector__iterator.html#a5a79972f223067007dcfd4350cbad30f">index</a>()), <span class="comment">//data length</span>
<a name="l01288"></a>01288                                           0, <span class="comment">//don&#39;t know -&gt; check!! (something related to increment?)</span>
<a name="l01289"></a>01289                                           NULL, NULL);
<a name="l01290"></a>01290         <a class="code" href="error_8hpp.html#a44f070f54255e72eb40c75ebd72ea602">VIENNACL_ERR_CHECK</a>(err);
<a name="l01291"></a>01291       }
<a name="l01292"></a>01292     }
<a name="l01293"></a>01293 
<a name="l01300"></a>01300     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_SRC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_DEST&gt;
<a name="l01301"></a><a class="code" href="namespaceviennacl.html#a9164bd549b986f39b035c24a426869b9">01301</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_begin,
<a name="l01302"></a>01302               <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_end,
<a name="l01303"></a>01303               <a class="code" href="classviennacl_1_1const__vector__iterator.html" title="A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated...">const_vector_iterator&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a> gpu_dest_begin)
<a name="l01304"></a>01304     {
<a name="l01305"></a>01305       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(gpu_src_begin, gpu_src_end, <a class="code" href="classviennacl_1_1vector__iterator.html" title="A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!">vector_iterator&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a>(gpu_dest_begin));
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307 
<a name="l01313"></a>01313     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_SRC, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT_DEST&gt;
<a name="l01314"></a><a class="code" href="namespaceviennacl.html#ad823fb30fd180da375a1e09d56c0a1b8">01314</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT_SRC&gt;</a> <span class="keyword">const</span> &amp; gpu_src_vec,
<a name="l01315"></a>01315               <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT_DEST&gt;</a> &amp; gpu_dest_vec )
<a name="l01316"></a>01316     {
<a name="l01317"></a>01317       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">viennacl::copy</a>(gpu_src_vec.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>(), gpu_src_vec.<a class="code" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f" title="Returns an iterator pointing to the end of the vector (STL like).">end</a>(), gpu_dest_vec.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>());
<a name="l01318"></a>01318     } 
<a name="l01319"></a>01319 
<a name="l01320"></a>01320 
<a name="l01321"></a>01321     
<a name="l01322"></a>01322     
<a name="l01323"></a>01323     
<a name="l01324"></a>01324 
<a name="l01325"></a>01325     <span class="comment">//global functions for handling vectors:</span>
<a name="l01330"></a>01330 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01331"></a><a class="code" href="namespaceviennacl.html#a5e572599ddbae8812154538849fa707c">01331</a>     std::ostream &amp; operator&lt;&lt;(std::ostream &amp; s, vector&lt;SCALARTYPE,ALIGNMENT&gt; <span class="keyword">const</span> &amp; val)
<a name="l01332"></a>01332     {
<a name="l01333"></a>01333       <a class="code" href="namespaceviennacl_1_1ocl.html#ac7871671987d322a8766aea79b1cd17a" title="Convenience function for getting the default queue for the currently active device in the active cont...">viennacl::ocl::get_queue</a>().<a class="code" href="classviennacl_1_1ocl_1_1command__queue.html#adc3c5cffb594b811f8a851924349af5b" title="Waits until all kernels in the queue have finished their execution.">finish</a>();
<a name="l01334"></a>01334       std::vector&lt;SCALARTYPE&gt; tmp(val.size());
<a name="l01335"></a>01335       <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU)...">copy</a>(val.begin(), val.end(), tmp.begin());
<a name="l01336"></a>01336       std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; val.size() &lt;&lt; <span class="stringliteral">&quot;](&quot;</span>;
<a name="l01337"></a>01337       <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;SCALARTYPE&gt;::size_type i=0; i&lt;val.size(); ++i)
<a name="l01338"></a>01338       {
<a name="l01339"></a>01339         <span class="keywordflow">if</span> (i &gt; 0)
<a name="l01340"></a>01340           s &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;
<a name="l01341"></a>01341         s &lt;&lt; tmp[i];
<a name="l01342"></a>01342       }
<a name="l01343"></a>01343       std::cout &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
<a name="l01344"></a>01344       <span class="keywordflow">return</span> s;
<a name="l01345"></a>01345     }
<a name="l01346"></a>01346 
<a name="l01353"></a>01353     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01354"></a><a class="code" href="namespaceviennacl.html#a0c01dfab44c6d3849f7d0eac55539142">01354</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl.html#a0c01dfab44c6d3849f7d0eac55539142" title="Swaps the contents of two vectors, data is copied.">swap</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l01355"></a>01355               <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2)
<a name="l01356"></a>01356     {
<a name="l01357"></a>01357       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l01358"></a>01358 
<a name="l01359"></a>01359       <a class="code" href="classviennacl_1_1ocl_1_1kernel.html" title="Represents an OpenCL kernel within ViennaCL.">viennacl::ocl::kernel</a> &amp; k = <a class="code" href="namespaceviennacl_1_1ocl.html#a61a73653d92f1eb2ef9c649ec253e29f" title="Convenience function for getting the kernel for a particular program from the current active context...">viennacl::ocl::get_kernel</a>(viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::program_name(), <span class="stringliteral">&quot;swap&quot;</span>);
<a name="l01360"></a>01360 
<a name="l01361"></a>01361       <a class="code" href="namespaceviennacl_1_1ocl.html#a46527eb5023de820b1f1c16ec5a11084" title="Enqueues a kernel in the provided queue.">viennacl::ocl::enqueue</a>(k(vec1, vec2, static_cast&lt;cl_uint&gt;(vec1.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>())));
<a name="l01362"></a>01362     }
<a name="l01363"></a>01363     
<a name="l01369"></a>01369     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l01370"></a><a class="code" href="namespaceviennacl.html#a976181b1f6aa698b64a4746f0949fce0">01370</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; <a class="code" href="namespaceviennacl.html#a976181b1f6aa698b64a4746f0949fce0" title="Swaps the content of two vectors by swapping OpenCL handles only, NO data is copied.">fast_swap</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; v1,
<a name="l01371"></a>01371                                               <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; v2) 
<a name="l01372"></a>01372     { 
<a name="l01373"></a>01373       <span class="keywordflow">return</span> v1.<a class="code" href="classviennacl_1_1vector.html#a3f3c31234d9a1c823383bd6e8c2c9222" title="Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.">fast_swap</a>(v2);
<a name="l01374"></a>01374     }       
<a name="l01375"></a>01375     
<a name="l01376"></a>01376     
<a name="l01377"></a>01377     
<a name="l01379"></a>01379 
<a name="l01384"></a>01384     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A&gt;
<a name="l01385"></a><a class="code" href="namespaceviennacl.html#aa60d7cda126efd13c3413453606850b7">01385</a>     <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, A&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_prod&gt; <a class="code" href="namespaceviennacl.html#a45c8d32b7d99c62cdb10899d70e7bad9">operator * </a>(SCALARTYPE <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1tag.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>, <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l01386"></a>01386     {
<a name="l01387"></a>01387       <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, A&gt;</a>, <span class="keyword">const</span> SCALARTYPE, op_prod&gt;(vec, value);
<a name="l01388"></a>01388     }
<a name="l01389"></a>01389 
<a name="l01395"></a>01395     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A&gt;
<a name="l01396"></a><a class="code" href="namespaceviennacl.html#a3b34a609403378a81c3a2589a5418077">01396</a>     <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, A&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>, op_prod&gt; <a class="code" href="namespaceviennacl.html#a45c8d32b7d99c62cdb10899d70e7bad9">operator * </a>(<a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1tag.html#a5c33da5929c9f2f9ef8d006d2350e6ec">value</a>, <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l01397"></a>01397     {
<a name="l01398"></a>01398         <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; const vector&lt;SCALARTYPE, A&gt;</a>, <span class="keyword">const</span> <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a>, op_prod&gt;(vec, value);
<a name="l01399"></a>01399     }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 
<a name="l01402"></a>01402     <span class="comment">//addition and subtraction of two vector_expressions:</span>
<a name="l01408"></a>01408 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l01409"></a>01409               <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l01410"></a>01410     <span class="keyword">typename</span> vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType
<a name="l01411"></a><a class="code" href="namespaceviennacl.html#aae3143a0fbb9e586b489cea90acf6659">01411</a>     <a class="code" href="namespaceviennacl.html#aae3143a0fbb9e586b489cea90acf6659" title="Operator overload for the addition of two vector expressions.">operator + </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01412"></a>01412                 <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01413"></a>01413     {
<a name="l01414"></a>01414       assert(proxy1.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>() == proxy2.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01415"></a>01415       <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067" title="Extracts the vector type from the two operands.">vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType</a> result(proxy1.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01416"></a>01416       result = proxy1;
<a name="l01417"></a>01417       result += proxy2;
<a name="l01418"></a>01418       <span class="keywordflow">return</span> result;
<a name="l01419"></a>01419     }
<a name="l01420"></a>01420 
<a name="l01426"></a>01426     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS1, <span class="keyword">typename</span> RHS1, <span class="keyword">typename</span> OP1,
<a name="l01427"></a>01427               <span class="keyword">typename</span> LHS2, <span class="keyword">typename</span> RHS2, <span class="keyword">typename</span> OP2&gt;
<a name="l01428"></a>01428     <span class="keyword">typename</span> vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType
<a name="l01429"></a><a class="code" href="namespaceviennacl.html#a77d42d098f9212ba53487deb6ddacf57">01429</a>     <a class="code" href="namespaceviennacl.html#a77d42d098f9212ba53487deb6ddacf57" title="Operator overload for the subtraction of two vector expressions.">operator - </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS1, RHS1, OP1&gt;</a> <span class="keyword">const</span> &amp; proxy1,
<a name="l01430"></a>01430                 <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS2, RHS2, OP2&gt;</a> <span class="keyword">const</span> &amp; proxy2)
<a name="l01431"></a>01431     {
<a name="l01432"></a>01432       assert(proxy1.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>() == proxy2.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01433"></a>01433       <span class="keyword">typename</span> <a class="code" href="classviennacl_1_1vector__expression.html#a5db65f00c1e206d9129dcd7721e46067" title="Extracts the vector type from the two operands.">vector_expression&lt; LHS1, RHS1, OP1&gt;::VectorType</a> result(proxy1.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01434"></a>01434       result = proxy1;
<a name="l01435"></a>01435       result -= proxy2;
<a name="l01436"></a>01436       <span class="keywordflow">return</span> result;
<a name="l01437"></a>01437     }
<a name="l01438"></a>01438     
<a name="l01440"></a>01440     
<a name="l01446"></a>01446     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01447"></a><a class="code" href="namespaceviennacl.html#a0808ef51d9a2d2e1ecbed3d4b63e159f">01447</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> <a class="code" href="namespaceviennacl.html#aae3143a0fbb9e586b489cea90acf6659" title="Operator overload for the addition of two vector expressions.">operator + </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l01448"></a>01448                                       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l01449"></a>01449     {
<a name="l01450"></a>01450       assert(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>() == vec.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l01451"></a>01451       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> result(vec.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l01452"></a>01452       result = proxy;
<a name="l01453"></a>01453       result += vec;
<a name="l01454"></a>01454       <span class="keywordflow">return</span> result;
<a name="l01455"></a>01455     }
<a name="l01456"></a>01456 
<a name="l01462"></a>01462     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01463"></a><a class="code" href="namespaceviennacl.html#ae00e47f8124b08cbeb8b7fc9ff537081">01463</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> <a class="code" href="namespaceviennacl.html#a77d42d098f9212ba53487deb6ddacf57" title="Operator overload for the subtraction of two vector expressions.">operator - </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l01464"></a>01464                                       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="namespaceviennacl_1_1io_1_1val.html#a80ef617bc6b5ed136631df552c86911c">vec</a>)
<a name="l01465"></a>01465     {
<a name="l01466"></a>01466       assert(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>() == vec.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l01467"></a>01467       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE, A&gt;</a> result(vec.<a class="code" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l01468"></a>01468       result = proxy;
<a name="l01469"></a>01469       result -= vec;
<a name="l01470"></a>01470       <span class="keywordflow">return</span> result;
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473 
<a name="l01479"></a>01479     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01480"></a><a class="code" href="namespaceviennacl.html#a00f47d8ad32713f98c6979c245b88cdb">01480</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE&gt;</a> <a class="code" href="namespaceviennacl.html#a45c8d32b7d99c62cdb10899d70e7bad9">operator * </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l01481"></a>01481                                    <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; val)
<a name="l01482"></a>01482     {
<a name="l01483"></a>01483       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE&gt;</a> result(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01484"></a>01484       result = proxy;
<a name="l01485"></a>01485       result *= val;
<a name="l01486"></a>01486       <span class="keywordflow">return</span> result;
<a name="l01487"></a>01487     }
<a name="l01488"></a>01488 
<a name="l01494"></a>01494     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01495"></a><a class="code" href="namespaceviennacl.html#a3aeb5b431a9c6d0b3af24a1513e8e9ad">01495</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE&gt;</a> <a class="code" href="namespaceviennacl.html#a3aeb5b431a9c6d0b3af24a1513e8e9ad" title="Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a vector_expression and then divided by alpha.">operator / </a>(<a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy,
<a name="l01496"></a>01496                                       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; val)
<a name="l01497"></a>01497     {
<a name="l01498"></a>01498       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE&gt;</a> result(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01499"></a>01499       result = proxy;
<a name="l01500"></a>01500       result /= val;
<a name="l01501"></a>01501       <span class="keywordflow">return</span> result;
<a name="l01502"></a>01502     }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504 
<a name="l01506"></a>01506     
<a name="l01512"></a>01512     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01513"></a><a class="code" href="namespaceviennacl.html#a66a24c58d27c6368ac879f4d7cc4cfc9">01513</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE&gt;</a> <a class="code" href="namespaceviennacl.html#a45c8d32b7d99c62cdb10899d70e7bad9">operator * </a>(<a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; val,
<a name="l01514"></a>01514                                    <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy)
<a name="l01515"></a>01515     {
<a name="l01516"></a>01516       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">vector&lt;SCALARTYPE&gt;</a> result(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01517"></a>01517       result = proxy;
<a name="l01518"></a>01518       result *= val;
<a name="l01519"></a>01519       <span class="keywordflow">return</span> result;
<a name="l01520"></a>01520     }
<a name="l01521"></a>01521     
<a name="l01527"></a>01527     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SCALARTYPE, <span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS, <span class="keyword">typename</span> OP&gt;
<a name="l01528"></a><a class="code" href="namespaceviennacl.html#a4522333fedaf508711a5aa02c47e5c7a">01528</a>     <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;SCALARTYPE&gt;</a> <a class="code" href="namespaceviennacl.html#a45c8d32b7d99c62cdb10899d70e7bad9">operator * </a>(SCALARTYPE val,
<a name="l01529"></a>01529                                    <a class="code" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector.">viennacl::vector_expression&lt; LHS, RHS, OP&gt;</a> <span class="keyword">const</span> &amp; proxy)
<a name="l01530"></a>01530     {
<a name="l01531"></a>01531       <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::v...">viennacl::vector&lt;SCALARTYPE&gt;</a> result(proxy.<a class="code" href="classviennacl_1_1vector__expression.html#a90ca964ebcc1b02bbcde225edd49e812" title="Returns the size of the result vector.">size</a>());
<a name="l01532"></a>01532       result = proxy;
<a name="l01533"></a>01533       result *= val;
<a name="l01534"></a>01534       <span class="keywordflow">return</span> result;
<a name="l01535"></a>01535     }
<a name="l01536"></a>01536 
<a name="l01537"></a>01537 }
<a name="l01538"></a>01538 
<a name="l01539"></a>01539 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat May 21 2011 20:36:51 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
