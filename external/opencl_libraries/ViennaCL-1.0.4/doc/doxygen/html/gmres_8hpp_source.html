<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: /export/development/ViennaCL/ViennaCL-1.0.4/viennacl/linalg/gmres.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>/export/development/ViennaCL/ViennaCL-1.0.4/viennacl/linalg/gmres.hpp</h1><a href="gmres_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* =======================================================================</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (c) 2010, Institute for Microelectronics, TU Vienna.</span>
<a name="l00003"></a>00003 <span class="comment">   http://www.iue.tuwien.ac.at</span>
<a name="l00004"></a>00004 <span class="comment">                             -----------------</span>
<a name="l00005"></a>00005 <span class="comment">                     ViennaCL - The Vienna Computing Library</span>
<a name="l00006"></a>00006 <span class="comment">                             -----------------</span>
<a name="l00007"></a>00007 <span class="comment">                            </span>
<a name="l00008"></a>00008 <span class="comment">   authors:    Karl Rupp                          rupp@iue.tuwien.ac.at</span>
<a name="l00009"></a>00009 <span class="comment">               Florian Rudolf                     flo.rudy+viennacl@gmail.com</span>
<a name="l00010"></a>00010 <span class="comment">               Josef Weinbub                      weinbub@iue.tuwien.ac.at</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   license:    MIT (X11), see file LICENSE in the ViennaCL base directory</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   file changelog: - May 28, 2010   New from scratch for first release</span>
<a name="l00015"></a>00015 <span class="comment">======================================================================= */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef _VIENNACL_GMRES_HPP_</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define _VIENNACL_GMRES_HPP_</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL...">viennacl/forwards.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="norm__2_8hpp.html">viennacl/linalg/norm_2.hpp</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="prod_8hpp.html">viennacl/linalg/prod.hpp</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="inner__prod_8hpp.html">viennacl/linalg/inner_prod.hpp</a>&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">namespace </span>viennacl
<a name="l00028"></a>00028 {
<a name="l00029"></a>00029   <span class="keyword">namespace </span>linalg
<a name="l00030"></a>00030   {
<a name="l00031"></a>00031     
<a name="l00034"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html">00034</a>     <span class="keyword">class </span><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html" title="A tag for the solver GMRES. Used for supplying solver parameters and for dispatching...">gmres_tag</a>       <span class="comment">//generalized minimum residual</span>
<a name="l00035"></a>00035     {
<a name="l00036"></a>00036       <span class="keyword">public</span>:
<a name="l00043"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a955b4df92cf6ab13d5d92f15fe85cdb4">00043</a>         <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a955b4df92cf6ab13d5d92f15fe85cdb4" title="The constructor.">gmres_tag</a>(<span class="keywordtype">double</span> tol = 1e-8, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a> = 20, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a16290e7b3ac1b41c490bbcf2837937a8">max_restarts</a> = 5) : _tol(tol), _max_restarts(<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a16290e7b3ac1b41c490bbcf2837937a8">max_restarts</a>), _krylov_dim(<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>) {};
<a name="l00044"></a>00044         
<a name="l00045"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a2e99612a88de21eaeb07e55be78a28a3">00045</a>         <span class="keywordtype">double</span> <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a2e99612a88de21eaeb07e55be78a28a3">tolerance</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _tol; }
<a name="l00046"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a16290e7b3ac1b41c490bbcf2837937a8">00046</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a16290e7b3ac1b41c490bbcf2837937a8">max_restarts</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _max_restarts; }
<a name="l00047"></a><a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">00047</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _krylov_dim; }
<a name="l00048"></a>00048         
<a name="l00049"></a>00049       <span class="keyword">private</span>:
<a name="l00050"></a>00050         <span class="keywordtype">double</span> _tol;
<a name="l00051"></a>00051         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _max_restarts;
<a name="l00052"></a>00052         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _krylov_dim;
<a name="l00053"></a>00053     };
<a name="l00054"></a>00054     
<a name="l00055"></a>00055     <span class="keyword">namespace</span>
<a name="l00056"></a>00056     {
<a name="l00057"></a>00057       
<a name="l00058"></a>00058       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SRC_VECTOR, <span class="keyword">typename</span> DEST_VECTOR&gt;
<a name="l00059"></a>00059       <span class="keywordtype">void</span> gmres_copy_helper(SRC_VECTOR <span class="keyword">const</span> &amp; src, DEST_VECTOR &amp; dest, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len)
<a name="l00060"></a>00060       {
<a name="l00061"></a>00061         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;len; ++i)
<a name="l00062"></a>00062           dest[i] = src[i];
<a name="l00063"></a>00063       }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ScalarType, <span class="keyword">typename</span> DEST_VECTOR&gt;
<a name="l00066"></a>00066       <span class="keywordtype">void</span> gmres_copy_helper(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;ScalarType&gt;</a> <span class="keyword">const</span> &amp; src, DEST_VECTOR &amp; dest, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len)
<a name="l00067"></a>00067       {
<a name="l00068"></a>00068         <a class="code" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core...">viennacl::copy</a>(src.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>(), src.<a class="code" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8" title="Returns an iterator pointing to the beginning of the vector (STL like).">begin</a>() + len, dest.begin());
<a name="l00069"></a>00069       }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     }
<a name="l00072"></a>00072 
<a name="l00083"></a>00083     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType, <span class="keyword">typename</span> PreconditionerType&gt;
<a name="l00084"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a76b4d001b76edd2253dc7d3a2852b391">00084</a>     VectorType <a class="code" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve</a>(<span class="keyword">const</span> MatrixType &amp; <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix</a>, VectorType <span class="keyword">const</span> &amp; rhs, <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html" title="A tag for the solver GMRES. Used for supplying solver parameters and for dispatching...">gmres_tag</a> <span class="keyword">const</span> &amp; tag, PreconditionerType <span class="keyword">const</span> &amp; precond)
<a name="l00085"></a>00085     {
<a name="l00086"></a>00086       <span class="keyword">typedef</span> <span class="keyword">typename</span> MatrixType::value_type                             ScalarType;
<a name="l00087"></a>00087       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structviennacl_1_1tools_1_1_c_p_u___s_c_a_l_a_r___t_y_p_e___d_e_d_u_c_e_r.html" title="Obtain the cpu scalar type from a type, including a GPU type like viennacl::scalar&amp;lt;T&amp;gt;...">viennacl::tools::CPU_SCALAR_TYPE_DEDUCER&lt;ScalarType&gt;::ResultType</a>    CPU_ScalarType;
<a name="l00088"></a>00088       VectorType result(rhs.size());
<a name="l00089"></a>00089       result.clear();
<a name="l00090"></a>00090       
<a name="l00091"></a>00091       VectorType res(rhs.size());
<a name="l00092"></a>00092       VectorType v_k_tilde(rhs.size());
<a name="l00093"></a>00093       VectorType v_k_tilde_temp(rhs.size());
<a name="l00094"></a>00094       
<a name="l00095"></a>00095       std::vector&lt; std::vector&lt;CPU_ScalarType&gt; &gt; R(tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>());
<a name="l00096"></a>00096       std::vector&lt;CPU_ScalarType&gt; projection_rhs(tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>());
<a name="l00097"></a>00097       std::vector&lt;VectorType&gt; U(tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>());
<a name="l00098"></a>00098       std::vector&lt;CPU_ScalarType&gt; cpu_temp(rhs.size());
<a name="l00099"></a>00099 
<a name="l00100"></a>00100       <span class="keyword">const</span> CPU_ScalarType gpu_scalar_minus_1 = <span class="keyword">static_cast&lt;</span>CPU_ScalarType<span class="keyword">&gt;</span>(-1);    <span class="comment">//representing the scalar &#39;-1&#39; on the GPU. Prevents blocking write operations</span>
<a name="l00101"></a>00101       <span class="keyword">const</span> CPU_ScalarType gpu_scalar_1 = <span class="keyword">static_cast&lt;</span>CPU_ScalarType<span class="keyword">&gt;</span>(1);    <span class="comment">//representing the scalar &#39;1&#39; on the GPU. Prevents blocking write operations</span>
<a name="l00102"></a>00102       <span class="keyword">const</span> CPU_ScalarType gpu_scalar_2 = <span class="keyword">static_cast&lt;</span>CPU_ScalarType<span class="keyword">&gt;</span>(2);    <span class="comment">//representing the scalar &#39;2&#39; on the GPU. Prevents blocking write operations</span>
<a name="l00103"></a>00103       
<a name="l00104"></a>00104       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;
<a name="l00105"></a>00105       <span class="keywordflow">for</span> (k = 0; k &lt; tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>(); ++k)
<a name="l00106"></a>00106       {
<a name="l00107"></a>00107         R[k].resize(tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>()); 
<a name="l00108"></a>00108         U[k].resize(rhs.size());
<a name="l00109"></a>00109       }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111       <span class="comment">//std::cout &lt;&lt; &quot;Starting GMRES...&quot; &lt;&lt; std::endl;</span>
<a name="l00112"></a>00112 
<a name="l00113"></a>00113       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> it = 0; it &lt; tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a16290e7b3ac1b41c490bbcf2837937a8">max_restarts</a>(); ++it)
<a name="l00114"></a>00114       {
<a name="l00115"></a>00115         res = rhs;
<a name="l00116"></a>00116         res -= <a class="code" href="namespaceviennacl_1_1linalg.html#acd380c11fa6a29fc1021e7b60f34dcf1">viennacl::linalg::prod</a>(matrix, result);  <span class="comment">//initial guess zero</span>
<a name="l00117"></a>00117         precond.apply(res);
<a name="l00118"></a>00118         
<a name="l00119"></a>00119         CPU_ScalarType rho_0 = <a class="code" href="namespaceviennacl_1_1linalg.html#a5f13104ad8997fe4eb97717fde2bec1a">viennacl::linalg::norm_2</a>(res); 
<a name="l00120"></a>00120         CPU_ScalarType rho = 1.0;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="keywordflow">if</span> (rho_0 &lt; tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a2e99612a88de21eaeb07e55be78a28a3">tolerance</a>())
<a name="l00123"></a>00123         {
<a name="l00124"></a>00124           <span class="comment">//std::cout &lt;&lt; &quot;Allowed Error reached at begin of loop&quot; &lt;&lt; std::endl;</span>
<a name="l00125"></a>00125           <span class="keywordflow">return</span> result;
<a name="l00126"></a>00126         }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         res /= rho_0;
<a name="l00129"></a>00129         <span class="keywordflow">for</span> (k=0; k&lt;tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>(); ++k)
<a name="l00130"></a>00130         {
<a name="l00131"></a>00131           R[k].clear();
<a name="l00132"></a>00132           U[k].clear();
<a name="l00133"></a>00133           R[k].resize(tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>()); 
<a name="l00134"></a>00134           U[k].resize(rhs.size());
<a name="l00135"></a>00135         }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="keywordflow">for</span> (k = 0; k &lt; tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a5841d44a68cceea5176b41420649ce89">krylov_dim</a>(); ++k)
<a name="l00138"></a>00138         {
<a name="l00139"></a>00139           <span class="comment">//compute v_k = A * v_{k-1} via Householder matrices</span>
<a name="l00140"></a>00140           <span class="keywordflow">if</span> (k == 0)
<a name="l00141"></a>00141           {
<a name="l00142"></a>00142             v_k_tilde = <a class="code" href="namespaceviennacl_1_1linalg.html#acd380c11fa6a29fc1021e7b60f34dcf1">viennacl::linalg::prod</a>(matrix, res);
<a name="l00143"></a>00143             precond.apply(v_k_tilde);
<a name="l00144"></a>00144           }
<a name="l00145"></a>00145           <span class="keywordflow">else</span>
<a name="l00146"></a>00146           {
<a name="l00147"></a>00147             v_k_tilde.clear();
<a name="l00148"></a>00148             v_k_tilde[k-1] = gpu_scalar_1;
<a name="l00149"></a>00149             <span class="comment">//Householder rotations part 1</span>
<a name="l00150"></a>00150             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = k-1; i &gt; -1; --i)
<a name="l00151"></a>00151               v_k_tilde -= U[i] * (<a class="code" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">viennacl::linalg::inner_prod</a>(U[i], v_k_tilde) * gpu_scalar_2);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153             v_k_tilde_temp = <a class="code" href="namespaceviennacl_1_1linalg.html#acd380c11fa6a29fc1021e7b60f34dcf1">viennacl::linalg::prod</a>(matrix, v_k_tilde);
<a name="l00154"></a>00154             precond.apply(v_k_tilde_temp);
<a name="l00155"></a>00155             v_k_tilde = v_k_tilde_temp;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157             <span class="comment">//Householder rotations part 2</span>
<a name="l00158"></a>00158             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; k; ++i)
<a name="l00159"></a>00159               v_k_tilde -= U[i] * (<a class="code" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">viennacl::linalg::inner_prod</a>(U[i], v_k_tilde) * gpu_scalar_2);
<a name="l00160"></a>00160           }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162           U[k].clear();
<a name="l00163"></a>00163           U[k].resize(rhs.size());
<a name="l00164"></a>00164           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; k; ++i)
<a name="l00165"></a>00165             U[k][i] = v_k_tilde[i];
<a name="l00166"></a>00166 
<a name="l00167"></a>00167           U[k][k] = std::sqrt( <a class="code" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">viennacl::linalg::inner_prod</a>(v_k_tilde, v_k_tilde) - <a class="code" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">viennacl::linalg::inner_prod</a>(U[k], U[k]) );
<a name="l00168"></a>00168 
<a name="l00169"></a>00169           <span class="comment">//generic copy from U to R (use of plain copy() leads to problems under Visual Studio 2008)</span>
<a name="l00170"></a>00170           gmres_copy_helper(U[k], R[k], k+1);
<a name="l00171"></a>00171           
<a name="l00172"></a>00172           U[k] -= v_k_tilde;
<a name="l00173"></a>00173           U[k] *= gpu_scalar_minus_1 / <a class="code" href="namespaceviennacl_1_1linalg.html#a5f13104ad8997fe4eb97717fde2bec1a">viennacl::linalg::norm_2</a>( U[k] );
<a name="l00174"></a>00174 
<a name="l00175"></a>00175           res -= U[k] * (<a class="code" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">viennacl::linalg::inner_prod</a>( U[k], res ) * gpu_scalar_2);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177           projection_rhs[k] = res[k];
<a name="l00178"></a>00178           rho *= std::sin( std::acos(projection_rhs[k] / rho) );
<a name="l00179"></a>00179 
<a name="l00180"></a>00180           <span class="keywordflow">if</span> (std::fabs(rho * rho_0) &lt; tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a2e99612a88de21eaeb07e55be78a28a3">tolerance</a>())
<a name="l00181"></a>00181           {
<a name="l00182"></a>00182             <span class="comment">//std::cout &lt;&lt; &quot;Krylov space big enough&quot; &lt;&lt; endl;</span>
<a name="l00183"></a>00183             <span class="keywordflow">break</span>;
<a name="l00184"></a>00184           }
<a name="l00185"></a>00185           
<a name="l00186"></a>00186         }
<a name="l00187"></a>00187         
<a name="l00188"></a>00188         <span class="comment">//inplace solution of the upper triangular matrix:</span>
<a name="l00189"></a>00189         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=k-1; i&gt;-1; --i)
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=i+1; j&lt;k; ++j)
<a name="l00192"></a>00192             <span class="comment">//temp_rhs[i] -= R[i][j] * temp_rhs[j];   //if R is not transposed</span>
<a name="l00193"></a>00193             projection_rhs[i] -= R[j][i] * projection_rhs[j];     <span class="comment">//R is transposed</span>
<a name="l00194"></a>00194             
<a name="l00195"></a>00195           projection_rhs[i] /= R[i][i];
<a name="l00196"></a>00196         }
<a name="l00197"></a>00197         
<a name="l00198"></a>00198         res *= projection_rhs[0];
<a name="l00199"></a>00199         
<a name="l00200"></a>00200         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; k-1; ++i)
<a name="l00201"></a>00201           res[i] += projection_rhs[i+1];
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = k-1; i &gt; -1; --i)
<a name="l00204"></a>00204           res -= U[i] * (<a class="code" href="namespaceviennacl_1_1linalg.html#a1348122d27efc695914431a7e9e15718">viennacl::linalg::inner_prod</a>(U[i], res) * gpu_scalar_2);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         res *= rho_0;
<a name="l00207"></a>00207         result += res;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="keywordflow">if</span> ( std::fabs(rho*rho_0) &lt; tag.<a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html#a2e99612a88de21eaeb07e55be78a28a3">tolerance</a>() )
<a name="l00210"></a>00210         {
<a name="l00211"></a>00211           <span class="comment">//std::cout &lt;&lt; &quot;Allowed Error reached at end of loop&quot; &lt;&lt; std::endl;</span>
<a name="l00212"></a>00212           <span class="keywordflow">return</span> result;
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         res = rhs;
<a name="l00216"></a>00216         res -= <a class="code" href="namespaceviennacl_1_1linalg.html#acd380c11fa6a29fc1021e7b60f34dcf1">viennacl::linalg::prod</a>(matrix, result);
<a name="l00217"></a>00217         <span class="comment">//std::cout &lt;&lt; &quot;norm_2(r)=&quot; &lt;&lt; norm_2(r) &lt;&lt; std::endl;</span>
<a name="l00218"></a>00218         <span class="comment">//std::cout &lt;&lt; &quot;std::abs(rho*rho_0)=&quot; &lt;&lt; std::abs(rho*rho_0) &lt;&lt; std::endl;</span>
<a name="l00219"></a>00219         <span class="comment">//std::cout &lt;&lt; r &lt;&lt; std::endl; </span>
<a name="l00220"></a>00220         
<a name="l00221"></a>00221       }
<a name="l00222"></a>00222 
<a name="l00223"></a>00223       <span class="keywordflow">return</span> result;
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225 
<a name="l00228"></a>00228     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">typename</span> VectorType&gt;
<a name="l00229"></a><a class="code" href="namespaceviennacl_1_1linalg.html#ad590c4eadb76eea1a806c3c4c026ba66">00229</a>     VectorType <a class="code" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve</a>(<span class="keyword">const</span> MatrixType &amp; <a class="code" href="classviennacl_1_1matrix.html" title="A dense matrix class.">matrix</a>, VectorType <span class="keyword">const</span> &amp; rhs, <a class="code" href="classviennacl_1_1linalg_1_1gmres__tag.html" title="A tag for the solver GMRES. Used for supplying solver parameters and for dispatching...">gmres_tag</a> <span class="keyword">const</span> &amp; tag)
<a name="l00230"></a>00230     {
<a name="l00231"></a>00231       <span class="keywordflow">return</span> <a class="code" href="namespaceviennacl_1_1linalg.html#ab50f87d195eb82ddbe5ce910e914bc55" title="Implementation of the stabilized Bi-conjugate gradient solver.">solve</a>(matrix, rhs, tag, <a class="code" href="classviennacl_1_1linalg_1_1no__precond.html" title="A tag class representing the use of no preconditioner.">no_precond</a>());
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 8 13:48:31 2010 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
