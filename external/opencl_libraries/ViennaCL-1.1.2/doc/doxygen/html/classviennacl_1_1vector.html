<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: vector&lt; SCALARTYPE, ALIGNMENT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennacl.html">viennacl</a>      </li>
      <li><a class="el" href="classviennacl_1_1vector.html">vector&lt; SCALARTYPE, ALIGNMENT &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>vector&lt; SCALARTYPE, ALIGNMENT &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="viennacl::vector" -->
<p>A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::vector.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; typename <br class="typebreak"/>
<a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t.html">viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT</a><br class="typebreak"/>
&lt; SCALARTYPE &gt;::ResultType &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aed985c700866b1bae61cb8bcd5d322fe">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a1d7ed47a15fea60d02986112826f40bc">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a5b0cecdbbf962357b5dc5f79dcae2d66">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a589223a5e682b4a61d57bb8742b1cec9">iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ad81d0c53b73688726d9e7da6fafe0383">vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor in order to be compatible with various containers.  <a href="#ad81d0c53b73688726d9e7da6fafe0383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a37af05b711e0806bd57ae6e4adfeb46e">vector</a> (<a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> vec_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An explicit constructor for the vector, allocating the given amount of memory (plus a padding specified by 'ALIGNMENT').  <a href="#a37af05b711e0806bd57ae6e4adfeb46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ae8ca03c5bcafbb1520e7382e8ac0050d">vector</a> (cl_mem existing_mem, <a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> vec_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a vector from existing OpenCL memory.  <a href="#ae8ca03c5bcafbb1520e7382e8ac0050d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a90f2d2832c55e1631a0cf00bc61c9a3d">vector</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#abcd7469cb88bdf2e0f146b73ef567887">vector</a> (const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The copy constructor.  <a href="#abcd7469cb88bdf2e0f146b73ef567887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a1442541c47d33407abda6838a344c49c">operator=</a> (const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. This vector is resized if 'vec' is of a different size.  <a href="#a1442541c47d33407abda6838a344c49c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ac4770655192f11ccca15bbd39219d725">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = alpha * v2, where alpha is a GPU scalar.  <a href="#ac4770655192f11ccca15bbd39219d725"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ae91c07bfd48f22c8ea54d42583c3611f">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const SCALARTYPE, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = alpha * v2, where alpha is a CPU scalar.  <a href="#ae91c07bfd48f22c8ea54d42583c3611f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a2cb54ea322ec4f89df8b798350c84f1b">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_div &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = v2 / alpha, where alpha is a GPU scalar.  <a href="#a2cb54ea322ec4f89df8b798350c84f1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a4a926e47e610c69c69d0f37a858cc69b">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const SCALARTYPE, op_div &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = v2 / alpha, where alpha is a CPU scalar.  <a href="#a4a926e47e610c69c69d0f37a858cc69b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a77b68e4bfde82a92f70728c40b652f03">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_add &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = v2 + v3.  <a href="#a77b68e4bfde82a92f70728c40b652f03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a5bcfcbcb1d03f00ee8942a39e881207f">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_sub &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = v2 - v3.  <a href="#a5bcfcbcb1d03f00ee8942a39e881207f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a276192f199fd2252c7296bd57dbb1a39">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a276192f199fd2252c7296bd57dbb1a39"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a8a3356317aca3d60689911cc206b35d3">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a8a3356317aca3d60689911cc206b35d3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#afdab89a0944ccdbe2ada1691060d7a68">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#afdab89a0944ccdbe2ada1691060d7a68"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#adb89283433101dc99dc1050471499973">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#adb89283433101dc99dc1050471499973"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a5363d6592a73924f46f913b12f039ba1">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a5363d6592a73924f46f913b12f039ba1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a600a2a87ea67dfaaacfe63252c558a70">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 = trans(A) * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a600a2a87ea67dfaaacfe63252c558a70"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a7170c99b16798d529af0325845639839">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 += trans(A) * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a7170c99b16798d529af0325845639839"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a42a2bea8b973e703dc74e7ad0a21ad75">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 -= trans(A) * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a42a2bea8b973e703dc74e7ad0a21ad75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#afa36924cb9eece8efec2a62996e0f97a">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 + trans(A) * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#afa36924cb9eece8efec2a62996e0f97a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a4ac366eca51e40271f505b2996173613">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 - trans(A) * v2, where v1, v2 are vectors and A is a dense matrix.  <a href="#a4ac366eca51e40271f505b2996173613"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a2a7d2a919692ddc123ebd1452d374d5b">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a2a7d2a919692ddc123ebd1452d374d5b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a6a36ddeab9a741c125c9d9d4d49f0e77">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a6a36ddeab9a741c125c9d9d4d49f0e77"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a26f886c3b1df2ffa849ad9ab2e9e4fe2">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a26f886c3b1df2ffa849ad9ab2e9e4fe2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a34b711b607f3675c773b2c4db62b2c67">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#a34b711b607f3675c773b2c4db62b2c67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aaa7f595ff02bf1124f5c5e45fad08896">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>.  <a href="#aaa7f595ff02bf1124f5c5e45fad08896"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a0acfd903198ff1e36ff67f62d67d7189">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#a0acfd903198ff1e36ff67f62d67d7189"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a558d5da8e439a7fac22354b25b84a458">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#a558d5da8e439a7fac22354b25b84a458"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a828077e1b1da533e174a7194f8a9210b">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#a828077e1b1da533e174a7194f8a9210b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a625df272798e5484b2b99645c164f618">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#a625df272798e5484b2b99645c164f618"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a38a33c6969ccc333a994d55cce743af9">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>.  <a href="#a38a33c6969ccc333a994d55cce743af9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ac3afd1fbe76f7fed3e2b36b1297fa42c">resize</a> (<a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> new_size, bool preserve=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the allocated memory for the vector. Pads the memory to be a multiple of 'ALIGNMENT'.  <a href="#ac3afd1fbe76f7fed3e2b36b1297fa42c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ad39a7d06af546a8df947a8a36722eb03">operator()</a> (<a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-write access to a single element of the vector.  <a href="#ad39a7d06af546a8df947a8a36722eb03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#af8f3f9c5c359c354201a0e4386b4cfcc">operator[]</a> (<a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-write access to a single element of the vector.  <a href="#af8f3f9c5c359c354201a0e4386b4cfcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a2de1bb775af4a87ce0b792154700c414">operator()</a> (<a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read access to a single element of the vector.  <a href="#a2de1bb775af4a87ce0b792154700c414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#acd1666d8bd98191443b3b62f0944a822">operator[]</a> (<a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read access to a single element of the vector.  <a href="#acd1666d8bd98191443b3b62f0944a822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a87bf465ad5a49ddd749505935d931db3">operator+=</a> (const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of a vector.  <a href="#a87bf465ad5a49ddd749505935d931db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#abe21f33c50e397aeefd7d075ce85d259">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a GPU scalar.  <a href="#abe21f33c50e397aeefd7d075ce85d259"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a7aeced050a63cc0314a993d12330d2ab">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a GPU scalar.  <a href="#a7aeced050a63cc0314a993d12330d2ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aeddc9d15b96937b89a6122abfbb4a4b0">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a CPU scalar.  <a href="#aeddc9d15b96937b89a6122abfbb4a4b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a2f8d78b1c904f274f2c50ec90f9a944e">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a CPU scalar.  <a href="#a2f8d78b1c904f274f2c50ec90f9a944e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a478742d85955289d0fef99d591d92771">operator+=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_div &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a GPU scalar.  <a href="#a478742d85955289d0fef99d591d92771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aae3c76bbb1a3e6023b1af706ce981b49">operator-=</a> (const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace subtraction of a vector.  <a href="#aae3c76bbb1a3e6023b1af706ce981b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aea40ee2f758aa6fc99ce786efc8ef02c">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a GPU scalar.  <a href="#aea40ee2f758aa6fc99ce786efc8ef02c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#afb6860261a249d443031fcaa6940806a">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a GPU scalar.  <a href="#afb6860261a249d443031fcaa6940806a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a067bc8f3532c3d398671ede297159c18">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a CPU scalar.  <a href="#a067bc8f3532c3d398671ede297159c18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a32ebaa055c897b1a6f3ea49e3b7022dd">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a CPU scalar.  <a href="#a32ebaa055c897b1a6f3ea49e3b7022dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a983376d820f950a2bc06d987a604c9b3">operator-=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_div &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a CPU scalar.  <a href="#a983376d820f950a2bc06d987a604c9b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#adad7d33d0bb340be923ded4b7050867b">operator*=</a> (SCALARTYPE val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales this vector by a CPU scalar value.  <a href="#adad7d33d0bb340be923ded4b7050867b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a32d20bcbd10c909d2041c30cc942f080">operator*=</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales this vector by a GPU scalar value.  <a href="#a32d20bcbd10c909d2041c30cc942f080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#af6ba5ebda72ab395ad1a1e5504088976">operator/=</a> (SCALARTYPE val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales this vector by a CPU scalar value.  <a href="#af6ba5ebda72ab395ad1a1e5504088976"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a3ffe49fc9f161ce2ea1fb130cd0195ca">operator/=</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;gpu_val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales this vector by a CPU scalar value.  <a href="#a3ffe49fc9f161ce2ea1fb130cd0195ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a87db4b1001dea6bfc9b47d1e07028552">operator+</a> (const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors.  <a href="#a87db4b1001dea6bfc9b47d1e07028552"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#abf44eeb0d6aebf7fac80026eb2aaff11">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a GPU scalar.  <a href="#abf44eeb0d6aebf7fac80026eb2aaff11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ae642a9b7a6e50936342bced1c2cc2aa9">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a GPU scalar.  <a href="#ae642a9b7a6e50936342bced1c2cc2aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a8c0fb94a7256a1afe4c16c4d54db7316">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a CPU scalar.  <a href="#a8c0fb94a7256a1afe4c16c4d54db7316"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a735ecd24c5432dbf339e9bf6a4bfefb6">operator+</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a CPU scalar.  <a href="#a735ecd24c5432dbf339e9bf6a4bfefb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ab4b953de766b713cf2016e69b75233de">operator-</a> (const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of result = v1 - v2.  <a href="#ab4b953de766b713cf2016e69b75233de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a1f057bb893f457b22ddd46aecc973469">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a GPU scalar.  <a href="#a1f057bb893f457b22ddd46aecc973469"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ab6a6205580e81d2e2e477f55b75f8645">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a GPU scalar.  <a href="#ab6a6205580e81d2e2e477f55b75f8645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a7b6c480cbd1da3812d587a729983fc4f">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a CPU scalar.  <a href="#a7b6c480cbd1da3812d587a729983fc4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a92159381dc559d8caac28099589b85cf">operator-</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a CPU scalar.  <a href="#a92159381dc559d8caac28099589b85cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const SCALARTYPE, op_prod &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a0273e98b77b6a89e60116358fe27cc9d">operator*</a> (SCALARTYPE value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the vector by a CPU scalar 'alpha' and returns an expression template.  <a href="#a0273e98b77b6a89e60116358fe27cc9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
, op_prod &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a3ff0ebfa2e17bab4dbad38c0cd50d948">operator*</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the vector by a GPU scalar 'alpha' and returns an expression template.  <a href="#a3ff0ebfa2e17bab4dbad38c0cd50d948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const SCALARTYPE, op_div &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ad87b95d3c182effc15136d7c610200af">operator/</a> (SCALARTYPE value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the vector by a CPU scalar 'alpha' and returns an expression template.  <a href="#ad87b95d3c182effc15136d7c610200af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;<br class="typebreak"/>
, op_div &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ad309219e4080cb6a6427f3321d159b2c">operator/</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales the vector by a GPU scalar 'alpha' and returns an expression template.  <a href="#ad309219e4080cb6a6427f3321d159b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ad69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator pointing to the beginning of the vector (STL like).  <a href="#ad69bd11391be1a1dba5c8202259664f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#acad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator pointing to the end of the vector (STL like).  <a href="#acad38d52497a975bfb6f2f6acd76631f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aa4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const-iterator pointing to the beginning of the vector (STL like).  <a href="#aa4b02d4f1a8500fb07a551069060709f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const-iterator pointing to the end of the vector (STL like).  <a href="#a350132543d80a1c1e5be844e6d2878ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#af5a080ddc0576cfba4c7494ff8eccb09">swap</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the entries of the two vectors.  <a href="#af5a080ddc0576cfba4c7494ff8eccb09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a3f3c31234d9a1c823383bd6e8c2c9222">fast_swap</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy.  <a href="#a3f3c31234d9a1c823383bd6e8c2c9222"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the length of the vector (cf. std::vector).  <a href="#a503ab01f6c0142145d3434f6924714e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a0ab5ce862c0331d9e45a6e1774fca131">max_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum possible size of the vector, which is given by 128 MByte due to limitations by OpenCL.  <a href="#a0ab5ce862c0331d9e45a6e1774fca131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c">internal_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the internal length of the vector, which is given by <a class="el" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size()</a> plus the extra memory due to padding the memory with zeros up to a multiple of 'ALIGNMENT'.  <a href="#aa50eb28af8d336f420b4de7b67ce738c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a3f37b042a1e7cd4bd38fc564de81f0da">empty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true is the size is zero.  <a href="#a3f37b042a1e7cd4bd38fc564de81f0da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle</a><br class="typebreak"/>
&lt; cl_mem &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c">handle</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the OpenCL memory <a class="el" href="classviennacl_1_1ocl_1_1handle.html" title="Handle class the effectively represents a smart pointer for OpenCL handles.">viennacl::ocl::handle</a>. Typically used for launching compute viennacl::ocl::kernels.  <a href="#abe419a13116160fd12b66f47c5180e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets all entries to zero. Does not change the size of the vector.  <a href="#ac8bb3912a3ce86b15842e79d0b421204"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a4989aaec23a5611beaa87e1653824aa6">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = A * v2, where A is a matrix.  <a href="#a4989aaec23a5611beaa87e1653824aa6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#a9591491bc69f66f82202a86f054ef7ac">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = A * v2, where A is a matrix.  <a href="#a9591491bc69f66f82202a86f054ef7ac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F, unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#abf65c6fc9600970e4ac00b693e0d04fb">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = A * v2, where A is a matrix.  <a href="#abf65c6fc9600970e4ac00b693e0d04fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F, unsigned int MAT_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, <br class="typebreak"/>
ALIGNMENT &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html#aa34adb8d02e43797f23d78bd0fcb7ce9">operator=</a> (const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the operation v1 = A * v2, where A is a matrix.  <a href="#aa34adb8d02e43797f23d78bd0fcb7ce9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class SCALARTYPE, unsigned int ALIGNMENT&gt;<br/>
 class viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt;</h3>

<p>A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::vector. </p>
<p>This is the basic vector type of ViennaCL. It is similar to std::vector and boost::numeric::ublas::vector and supports various linear algebra operations. By default, the internal length of the vector is padded to a multiple of 'ALIGNMENT' in order to speed up several GPU viennacl::ocl::kernels.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SCALARTYPE</em>&nbsp;</td><td>The floating point type, either 'float' or 'double' </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ALIGNMENT</em>&nbsp;</td><td>The internal memory size is given by (<a class="el" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size()</a>/ALIGNMENT + 1) * ALIGNMENT. ALIGNMENT must be a power of two. Best values or usually 4, 8 or 16, higher values are usually a waste of memory. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a5b0cecdbbf962357b5dc5f79dcae2d66"></a><!-- doxytag: member="viennacl::vector::const_iterator" ref="a5b0cecdbbf962357b5dc5f79dcae2d66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt;SCALARTYPE, ALIGNMENT&gt; <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d7ed47a15fea60d02986112826f40bc"></a><!-- doxytag: member="viennacl::vector::difference_type" ref="a1d7ed47a15fea60d02986112826f40bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceviennacl.html#aa2aeb075792a4f72abdd84b393d41869">vcl_ptrdiff_t</a> <a class="el" href="classviennacl_1_1vector.html#a1d7ed47a15fea60d02986112826f40bc">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a589223a5e682b4a61d57bb8742b1cec9"></a><!-- doxytag: member="viennacl::vector::iterator" ref="a589223a5e682b4a61d57bb8742b1cec9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt;SCALARTYPE, ALIGNMENT&gt; <a class="el" href="classviennacl_1_1vector__iterator.html">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e2cc70e5cd203262fe8270613f303ec"></a><!-- doxytag: member="viennacl::vector::size_type" ref="a8e2cc70e5cd203262fe8270613f303ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceviennacl.html#a151281d5407af580310fed77af40f052">vcl_size_t</a> <a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed985c700866b1bae61cb8bcd5d322fe"></a><!-- doxytag: member="viennacl::vector::value_type" ref="aed985c700866b1bae61cb8bcd5d322fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;typename <a class="el" href="structviennacl_1_1tools_1_1_c_h_e_c_k___s_c_a_l_a_r___t_e_m_p_l_a_t_e___a_r_g_u_m_e_n_t.html">viennacl::tools::CHECK_SCALAR_TEMPLATE_ARGUMENT</a>&lt;SCALARTYPE&gt;::ResultType&gt; <a class="el" href="classviennacl_1_1scalar.html">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad81d0c53b73688726d9e7da6fafe0383"></a><!-- doxytag: member="viennacl::vector::vector" ref="ad81d0c53b73688726d9e7da6fafe0383" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor in order to be compatible with various containers. </p>

</div>
</div>
<a class="anchor" id="a37af05b711e0806bd57ae6e4adfeb46e"></a><!-- doxytag: member="viennacl::vector::vector" ref="a37af05b711e0806bd57ae6e4adfeb46e" args="(size_type vec_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>vec_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An explicit constructor for the vector, allocating the given amount of memory (plus a padding specified by 'ALIGNMENT'). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec_size</em>&nbsp;</td><td>The length (i.e. size) of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8ca03c5bcafbb1520e7382e8ac0050d"></a><!-- doxytag: member="viennacl::vector::vector" ref="ae8ca03c5bcafbb1520e7382e8ac0050d" args="(cl_mem existing_mem, size_type vec_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">cl_mem&nbsp;</td>
          <td class="paramname"> <em>existing_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>vec_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a vector from existing OpenCL memory. </p>
<p>Note: The provided memory must take an eventual ALIGNMENT into account, i.e. existing_mem must be at least of size <a class="el" href="classviennacl_1_1vector.html#aa50eb28af8d336f420b4de7b67ce738c" title="Returns the internal length of the vector, which is given by size() plus the extra memory due to padd...">internal_size()</a>! This is trivially the case with the default alignment, but should be considered when using vector&lt;&gt; with an alignment parameter not equal to 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>existing_mem</em>&nbsp;</td><td>An OpenCL handle representing the memory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec_size</em>&nbsp;</td><td>The size of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90f2d2832c55e1631a0cf00bc61c9a3d"></a><!-- doxytag: member="viennacl::vector::vector" ref="a90f2d2832c55e1631a0cf00bc61c9a3d" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abcd7469cb88bdf2e0f146b73ef567887"></a><!-- doxytag: member="viennacl::vector::vector" ref="abcd7469cb88bdf2e0f146b73ef567887" args="(const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The copy constructor. </p>
<p>Entries of 'vec' are directly copied to this vector. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad69bd11391be1a1dba5c8202259664f8"></a><!-- doxytag: member="viennacl::vector::begin" ref="ad69bd11391be1a1dba5c8202259664f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__iterator.html">iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an iterator pointing to the beginning of the vector (STL like). </p>

</div>
</div>
<a class="anchor" id="aa4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="viennacl::vector::begin" ref="aa4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const-iterator pointing to the beginning of the vector (STL like). </p>

</div>
</div>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="viennacl::vector::clear" ref="ac8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets all entries to zero. Does not change the size of the vector. </p>

</div>
</div>
<a class="anchor" id="a3f37b042a1e7cd4bd38fc564de81f0da"></a><!-- doxytag: member="viennacl::vector::empty" ref="a3f37b042a1e7cd4bd38fc564de81f0da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true is the size is zero. </p>

</div>
</div>
<a class="anchor" id="a350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="viennacl::vector::end" ref="a350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const-iterator pointing to the end of the vector (STL like). </p>

</div>
</div>
<a class="anchor" id="acad38d52497a975bfb6f2f6acd76631f"></a><!-- doxytag: member="viennacl::vector::end" ref="acad38d52497a975bfb6f2f6acd76631f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__iterator.html">iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an iterator pointing to the end of the vector (STL like). </p>

</div>
</div>
<a class="anchor" id="a3f3c31234d9a1c823383bd6e8c2c9222"></a><!-- doxytag: member="viennacl::vector::fast_swap" ref="a3f3c31234d9a1c823383bd6e8c2c9222" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; fast_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the handles of two vectors by swapping the OpenCL handles only, no data copy. </p>

</div>
</div>
<a class="anchor" id="abe419a13116160fd12b66f47c5180e5c"></a><!-- doxytag: member="viennacl::vector::handle" ref="abe419a13116160fd12b66f47c5180e5c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle</a>&lt;cl_mem&gt;&amp; handle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the OpenCL memory <a class="el" href="classviennacl_1_1ocl_1_1handle.html" title="Handle class the effectively represents a smart pointer for OpenCL handles.">viennacl::ocl::handle</a>. Typically used for launching compute viennacl::ocl::kernels. </p>

</div>
</div>
<a class="anchor" id="aa50eb28af8d336f420b4de7b67ce738c"></a><!-- doxytag: member="viennacl::vector::internal_size" ref="aa50eb28af8d336f420b4de7b67ce738c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> internal_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the internal length of the vector, which is given by <a class="el" href="classviennacl_1_1vector.html#a503ab01f6c0142145d3434f6924714e7" title="Returns the length of the vector (cf. std::vector).">size()</a> plus the extra memory due to padding the memory with zeros up to a multiple of 'ALIGNMENT'. </p>

</div>
</div>
<a class="anchor" id="a0ab5ce862c0331d9e45a6e1774fca131"></a><!-- doxytag: member="viennacl::vector::max_size" ref="a0ab5ce862c0331d9e45a6e1774fca131" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum possible size of the vector, which is given by 128 MByte due to limitations by OpenCL. </p>

</div>
</div>
<a class="anchor" id="ad39a7d06af546a8df947a8a36722eb03"></a><!-- doxytag: member="viennacl::vector::operator()" ref="ad39a7d06af546a8df947a8a36722eb03" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt;SCALARTYPE&gt; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read-write access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="a2de1bb775af4a87ce0b792154700c414"></a><!-- doxytag: member="viennacl::vector::operator()" ref="a2de1bb775af4a87ce0b792154700c414" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="a0273e98b77b6a89e60116358fe27cc9d"></a><!-- doxytag: member="viennacl::vector::operator*" ref="a0273e98b77b6a89e60116358fe27cc9d" args="(SCALARTYPE value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;, const SCALARTYPE, op_prod&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a CPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="a3ff0ebfa2e17bab4dbad38c0cd50d948"></a><!-- doxytag: member="viennacl::vector::operator*" ref="a3ff0ebfa2e17bab4dbad38c0cd50d948" args="(scalar&lt; SCALARTYPE &gt; const &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt;, op_prod&gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a GPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="adad7d33d0bb340be923ded4b7050867b"></a><!-- doxytag: member="viennacl::vector::operator*=" ref="adad7d33d0bb340be923ded4b7050867b" args="(SCALARTYPE val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a CPU scalar value. </p>

</div>
</div>
<a class="anchor" id="a32d20bcbd10c909d2041c30cc942f080"></a><!-- doxytag: member="viennacl::vector::operator*=" ref="a32d20bcbd10c909d2041c30cc942f080" args="(scalar&lt; SCALARTYPE &gt; const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a GPU scalar value. </p>

</div>
</div>
<a class="anchor" id="afa36924cb9eece8efec2a62996e0f97a"></a><!-- doxytag: member="viennacl::vector::operator+" ref="afa36924cb9eece8efec2a62996e0f97a" args="(const vector_expression&lt; const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 + trans(A) * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34b711b607f3675c773b2c4db62b2c67"></a><!-- doxytag: member="viennacl::vector::operator+" ref="a34b711b607f3675c773b2c4db62b2c67" args="(const vector_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87db4b1001dea6bfc9b47d1e07028552"></a><!-- doxytag: member="viennacl::vector::operator+" ref="a87db4b1001dea6bfc9b47d1e07028552" args="(const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors. </p>

</div>
</div>
<a class="anchor" id="abf44eeb0d6aebf7fac80026eb2aaff11"></a><!-- doxytag: member="viennacl::vector::operator+" ref="abf44eeb0d6aebf7fac80026eb2aaff11" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="ae642a9b7a6e50936342bced1c2cc2aa9"></a><!-- doxytag: member="viennacl::vector::operator+" ref="ae642a9b7a6e50936342bced1c2cc2aa9" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a8c0fb94a7256a1afe4c16c4d54db7316"></a><!-- doxytag: member="viennacl::vector::operator+" ref="a8c0fb94a7256a1afe4c16c4d54db7316" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="a735ecd24c5432dbf339e9bf6a4bfefb6"></a><!-- doxytag: member="viennacl::vector::operator+" ref="a735ecd24c5432dbf339e9bf6a4bfefb6" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 + v2 * alpha, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="adb89283433101dc99dc1050471499973"></a><!-- doxytag: member="viennacl::vector::operator+" ref="adb89283433101dc99dc1050471499973" args="(const vector_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a625df272798e5484b2b99645c164f618"></a><!-- doxytag: member="viennacl::vector::operator+" ref="a625df272798e5484b2b99645c164f618" args="(const vector_expression&lt; const coordinate_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 + A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the operation 'result = v1 + A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87bf465ad5a49ddd749505935d931db3"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a87bf465ad5a49ddd749505935d931db3" args="(const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a vector. </p>

</div>
</div>
<a class="anchor" id="a8a3356317aca3d60689911cc206b35d3"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a8a3356317aca3d60689911cc206b35d3" args="(const vector_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation v1 += A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe21f33c50e397aeefd7d075ce85d259"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="abe21f33c50e397aeefd7d075ce85d259" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a7aeced050a63cc0314a993d12330d2ab"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a7aeced050a63cc0314a993d12330d2ab" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a6a36ddeab9a741c125c9d9d4d49f0e77"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a6a36ddeab9a741c125c9d9d4d49f0e77" args="(const vector_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the operation v1 += A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeddc9d15b96937b89a6122abfbb4a4b0"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="aeddc9d15b96937b89a6122abfbb4a4b0" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="a2f8d78b1c904f274f2c50ec90f9a944e"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a2f8d78b1c904f274f2c50ec90f9a944e" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="a478742d85955289d0fef99d591d92771"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a478742d85955289d0fef99d591d92771" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_div &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_div &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace addition of a scaled vector, i.e. v1 += alpha * v2, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a7170c99b16798d529af0325845639839"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a7170c99b16798d529af0325845639839" args="(const vector_expression&lt; const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 += trans(A) * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation v1 += A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a558d5da8e439a7fac22354b25b84a458"></a><!-- doxytag: member="viennacl::vector::operator+=" ref="a558d5da8e439a7fac22354b25b84a458" args="(const vector_expression&lt; const coordinate_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 += A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the operation v1 += A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ac366eca51e40271f505b2996173613"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="a4ac366eca51e40271f505b2996173613" args="(const vector_expression&lt; const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 - trans(A) * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4b953de766b713cf2016e69b75233de"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="ab4b953de766b713cf2016e69b75233de" args="(const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of result = v1 - v2. </p>

</div>
</div>
<a class="anchor" id="aaa7f595ff02bf1124f5c5e45fad08896"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="aaa7f595ff02bf1124f5c5e45fad08896" args="(const vector_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f057bb893f457b22ddd46aecc973469"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="a1f057bb893f457b22ddd46aecc973469" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a92159381dc559d8caac28099589b85cf"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="a92159381dc559d8caac28099589b85cf" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="a38a33c6969ccc333a994d55cce743af9"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="a38a33c6969ccc333a994d55cce743af9" args="(const vector_expression&lt; const coordinate_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6a6205580e81d2e2e477f55b75f8645"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="ab6a6205580e81d2e2e477f55b75f8645" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a7b6c480cbd1da3812d587a729983fc4f"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="a7b6c480cbd1da3812d587a729983fc4f" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds up two vectors, i.e. result = v1 - v2 * alpha, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="a5363d6592a73924f46f913b12f039ba1"></a><!-- doxytag: member="viennacl::vector::operator&#45;" ref="a5363d6592a73924f46f913b12f039ba1" args="(const vector_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 - A * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation 'result = v1 - A * v2', where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a067bc8f3532c3d398671ede297159c18"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="a067bc8f3532c3d398671ede297159c18" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="aae3c76bbb1a3e6023b1af706ce981b49"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="aae3c76bbb1a3e6023b1af706ce981b49" args="(const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a vector. </p>

</div>
</div>
<a class="anchor" id="a32ebaa055c897b1a6f3ea49e3b7022dd"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="a32ebaa055c897b1a6f3ea49e3b7022dd" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="afdab89a0944ccdbe2ada1691060d7a68"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="afdab89a0944ccdbe2ada1691060d7a68" args="(const vector_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation v1 -= A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea40ee2f758aa6fc99ce786efc8ef02c"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="aea40ee2f758aa6fc99ce786efc8ef02c" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a26f886c3b1df2ffa849ad9ab2e9e4fe2"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="a26f886c3b1df2ffa849ad9ab2e9e4fe2" args="(const vector_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<p>Implementation of the operation v1 -= A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a983376d820f950a2bc06d987a604c9b3"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="a983376d820f950a2bc06d987a604c9b3" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_div &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_div &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a CPU scalar. </p>

</div>
</div>
<a class="anchor" id="a828077e1b1da533e174a7194f8a9210b"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="a828077e1b1da533e174a7194f8a9210b" args="(const vector_expression&lt; const coordinate_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 -= A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<p>Implementation of the operation v1 -= A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb6860261a249d443031fcaa6940806a"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="afb6860261a249d443031fcaa6940806a" args="(const vector_expression&lt; const vector&lt; SCALARTYPE, ALIGNMENT &gt;, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inplace subtraction of a scaled vector, i.e. v1 -= alpha * v2, where alpha is a GPU scalar. </p>

</div>
</div>
<a class="anchor" id="a42a2bea8b973e703dc74e7ad0a21ad75"></a><!-- doxytag: member="viennacl::vector::operator&#45;=" ref="a42a2bea8b973e703dc74e7ad0a21ad75" args="(const vector_expression&lt; const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 -= trans(A) * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<p>Implementation of the operation v1 -= A * v2, where A is a matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad309219e4080cb6a6427f3321d159b2c"></a><!-- doxytag: member="viennacl::vector::operator/" ref="ad309219e4080cb6a6427f3321d159b2c" args="(scalar&lt; SCALARTYPE &gt; const &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt;, op_div&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a GPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="ad87b95d3c182effc15136d7c610200af"></a><!-- doxytag: member="viennacl::vector::operator/" ref="ad87b95d3c182effc15136d7c610200af" args="(SCALARTYPE value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;, const SCALARTYPE, op_div&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the vector by a CPU scalar 'alpha' and returns an expression template. </p>

</div>
</div>
<a class="anchor" id="af6ba5ebda72ab395ad1a1e5504088976"></a><!-- doxytag: member="viennacl::vector::operator/=" ref="af6ba5ebda72ab395ad1a1e5504088976" args="(SCALARTYPE val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a CPU scalar value. </p>

</div>
</div>
<a class="anchor" id="a3ffe49fc9f161ce2ea1fb130cd0195ca"></a><!-- doxytag: member="viennacl::vector::operator/=" ref="a3ffe49fc9f161ce2ea1fb130cd0195ca" args="(scalar&lt; SCALARTYPE &gt; const &amp;gpu_val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this vector by a CPU scalar value. </p>

</div>
</div>
<a class="anchor" id="abf65c6fc9600970e4ac00b693e0d04fb"></a><!-- doxytag: member="viennacl::vector::operator=" ref="abf65c6fc9600970e4ac00b693e0d04fb" args="(const viennacl::vector_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = A * v2, where A is a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae91c07bfd48f22c8ea54d42583c3611f"></a><!-- doxytag: member="viennacl::vector::operator=" ref="ae91c07bfd48f22c8ea54d42583c3611f" args="(const vector_expression&lt; VectorType, const SCALARTYPE, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const SCALARTYPE, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = alpha * v2, where alpha is a CPU scalar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bcfcbcb1d03f00ee8942a39e881207f"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a5bcfcbcb1d03f00ee8942a39e881207f" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_sub &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_sub &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 - v3. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa34adb8d02e43797f23d78bd0fcb7ce9"></a><!-- doxytag: member="viennacl::vector::operator=" ref="aa34adb8d02e43797f23d78bd0fcb7ce9" args="(const viennacl::vector_expression&lt; const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = A * v2, where A is a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77b68e4bfde82a92f70728c40b652f03"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a77b68e4bfde82a92f70728c40b652f03" args="(const vector_expression&lt; vector&lt; SCALARTYPE, ALIGNMENT &gt;, vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_add &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_add &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 + v3. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4989aaec23a5611beaa87e1653824aa6"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a4989aaec23a5611beaa87e1653824aa6" args="(const viennacl::vector_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = A * v2, where A is a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a7d2a919692ddc123ebd1452d374d5b"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a2a7d2a919692ddc123ebd1452d374d5b" args="(const vector_expression&lt; const compressed_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a276192f199fd2252c7296bd57dbb1a39"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a276192f199fd2252c7296bd57dbb1a39" args="(const vector_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0acfd903198ff1e36ff67f62d67d7189"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a0acfd903198ff1e36ff67f62d67d7189" args="(const vector_expression&lt; const coordinate_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 = A * v2, where v1, v2 are vectors and A is a sparse matrix of type <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row an...">coordinate_matrix</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4770655192f11ccca15bbd39219d725"></a><!-- doxytag: member="viennacl::vector::operator=" ref="ac4770655192f11ccca15bbd39219d725" args="(const vector_expression&lt; VectorType, const scalar&lt; SCALARTYPE &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = alpha * v2, where alpha is a GPU scalar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9591491bc69f66f82202a86f054ef7ac"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a9591491bc69f66f82202a86f054ef7ac" args="(const viennacl::vector_expression&lt; const coordinate_matrix&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, viennacl::op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = A * v2, where A is a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a600a2a87ea67dfaaacfe63252c558a70"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a600a2a87ea67dfaaacfe63252c558a70" args="(const vector_expression&lt; const matrix_expression&lt; const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const matrix&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const vector&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix__expression.html">matrix_expression</a>&lt; const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, MAT_ALIGNMENT &gt;, op_trans &gt;, const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt;, op_prod &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for v1 = trans(A) * v2, where v1, v2 are vectors and A is a dense matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1442541c47d33407abda6838a344c49c"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a1442541c47d33407abda6838a344c49c" args="(const vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. This vector is resized if 'vec' is of a different size. </p>

</div>
</div>
<a class="anchor" id="a4a926e47e610c69c69d0f37a858cc69b"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a4a926e47e610c69c69d0f37a858cc69b" args="(const vector_expression&lt; VectorType, const SCALARTYPE, op_div &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const SCALARTYPE, op_div &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 / alpha, where alpha is a CPU scalar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cb54ea322ec4f89df8b798350c84f1b"></a><!-- doxytag: member="viennacl::vector::operator=" ref="a2cb54ea322ec4f89df8b798350c84f1b" args="(const vector_expression&lt; VectorType, const scalar&lt; SCALARTYPE &gt;, op_div &gt; &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; VectorType, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_div &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the operation v1 = v2 / alpha, where alpha is a GPU scalar. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>An expression template proxy class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd1666d8bd98191443b3b62f0944a822"></a><!-- doxytag: member="viennacl::vector::operator[]" ref="acd1666d8bd98191443b3b62f0944a822" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="af8f3f9c5c359c354201a0e4386b4cfcc"></a><!-- doxytag: member="viennacl::vector::operator[]" ref="af8f3f9c5c359c354201a0e4386b4cfcc" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1entry__proxy.html">entry_proxy</a>&lt;SCALARTYPE&gt; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read-write access to a single element of the vector. </p>

</div>
</div>
<a class="anchor" id="ac3afd1fbe76f7fed3e2b36b1297fa42c"></a><!-- doxytag: member="viennacl::vector::resize" ref="ac3afd1fbe76f7fed3e2b36b1297fa42c" args="(size_type new_size, bool preserve=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>preserve</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the allocated memory for the vector. Pads the memory to be a multiple of 'ALIGNMENT'. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_size</em>&nbsp;</td><td>The new size of the vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>preserve</em>&nbsp;</td><td>If true, old entries of the vector are preserved, otherwise eventually discarded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a503ab01f6c0142145d3434f6924714e7"></a><!-- doxytag: member="viennacl::vector::size" ref="a503ab01f6c0142145d3434f6924714e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html#a8e2cc70e5cd203262fe8270613f303ec">size_type</a> size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of the vector (cf. std::vector). </p>

</div>
</div>
<a class="anchor" id="af5a080ddc0576cfba4c7494ff8eccb09"></a><!-- doxytag: member="viennacl::vector::swap" ref="af5a080ddc0576cfba4c7494ff8eccb09" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, ALIGNMENT&gt;&amp; swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the entries of the two vectors. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/data/development/ViennaCL/ViennaCL-1.1.2/viennacl/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
<li>/data/development/ViennaCL/ViennaCL-1.1.2/viennacl/linalg/<a class="el" href="compressed__matrix__operations_8hpp_source.html">compressed_matrix_operations.hpp</a></li>
<li>/data/development/ViennaCL/ViennaCL-1.1.2/viennacl/linalg/<a class="el" href="coordinate__matrix__operations_8hpp_source.html">coordinate_matrix_operations.hpp</a></li>
<li>/data/development/ViennaCL/ViennaCL-1.1.2/viennacl/linalg/<a class="el" href="matrix__operations_8hpp_source.html">matrix_operations.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat May 21 2011 20:36:51 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
