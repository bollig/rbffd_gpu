<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: viennacl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>viennacl Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">linalg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1ocl.html">ocl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1tools.html">tools</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1traits.html">traits</a></td></tr>
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A sparse square matrix in compressed sparse rows format.  <a href="classviennacl_1_1compressed__matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A sparse square matrix, where entries are stored as triplets (i,j, val), where i and j are the row and column indices and val denotes the entry.  <a href="classviennacl_1_1coordinate__matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__none.html">tag_none</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas.html">is_ublas</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__ublas.html">tag_ublas</a>.  <a href="structviennacl_1_1is__ublas.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__ublas_3_01viennacl_1_1tag__ublas_01_4.html">is_ublas&lt; viennacl::tag_ublas &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl.html">is_viennacl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meta function which checks whether a tag is <a class="el" href="structviennacl_1_1tag__viennacl.html">tag_viennacl</a>.  <a href="structviennacl_1_1is__viennacl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1is__viennacl_3_01viennacl_1_1tag__viennacl_01_4.html">is_viennacl&lt; viennacl::tag_viennacl &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__major.html">row_major</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag for row-major storage of a dense matrix.  <a href="structviennacl_1_1row__major.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1outer__prod__proxy.html">outer_prod_proxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy class for outer products of two vectors.  <a href="classviennacl_1_1outer__prod__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__times__outer__prod__proxy.html">scalar_times_outer_prod_proxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy class for scaled outer products of two vectors.  <a href="classviennacl_1_1scalar__times__outer__prod__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">transposed_matrix_proxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy class for a transposed matrix. Allows several operations without rearranging the underlying values in the GPU memory.  <a href="classviennacl_1_1transposed__matrix__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1row__iteration.html">row_iteration</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag indicating iteration along increasing row index of a matrix.  <a href="structviennacl_1_1row__iteration.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennacl_1_1col__iteration.html">col_iteration</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag indicating iteration along increasing columns index of a matrix.  <a href="structviennacl_1_1col__iteration.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix__iterator.html">matrix_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1matrix.html">matrix</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dense matrix class.  <a href="classviennacl_1_1matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar__expression.html">scalar_expression</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy for scalar expressions (e.g. from inner vector products).  <a href="classviennacl_1_1scalar__expression.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1scalar.html">scalar</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a single scalar value on the GPU and behaves mostly like a built-in scalar type like float or double.  <a href="classviennacl_1_1scalar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__entry__proxy.html">vector_entry_proxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy class for a single element of a <a class="el" href="classviennacl_1_1vector__entry__proxy.html" title="A proxy class for a single element of a vector_entry_proxy. This proxy should not...">vector_entry_proxy</a>. This proxy should not be noticed by end-users of the library.  <a href="classviennacl_1_1vector__entry__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An expression template class that represents a binary operation that yields a vector.  <a href="classviennacl_1_1vector__expression.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A STL-type const-iterator for vector elements. Elements can be accessed, but cannot be manipulated. VERY SLOW!!  <a href="classviennacl_1_1const__vector__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A STL-type iterator for vector elements. Elements can be accessed and manipulated. VERY SLOW!!  <a href="classviennacl_1_1vector__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennacl_1_1vector.html">vector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::vector.  <a href="classviennacl_1_1vector.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU).  <a href="#a5684964ce1519c88a443aa14be9428f0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a25d1118aadbe1e6cb69b70df35f94763">copy</a> (const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#a25d1118aadbe1e6cb69b70df35f94763"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6b202ebcc6108940a59881c42f3d86da">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#a6b202ebcc6108940a59881c42f3d86da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8a0feeb7a31a31f45e1d014512758fe6">copy</a> (const <a class="el" href="classviennacl_1_1compressed__matrix.html">compressed_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#a8a0feeb7a31a31f45e1d014512758fe6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a87f711ebb1d8fd6435d31f1841f9cfaf">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU).  <a href="#a87f711ebb1d8fd6435d31f1841f9cfaf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab4fb2cd615454e656202d5d6f1a54483">copy</a> (const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device.  <a href="#ab4fb2cd615454e656202d5d6f1a54483"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab2ea05f107d5ec7f31214a2898ccbe08">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host.  <a href="#ab2ea05f107d5ec7f31214a2898ccbe08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae1d2b8aa5bf56f7479a66d51713708d2">copy</a> (const <a class="el" href="classviennacl_1_1coordinate__matrix.html">coordinate_matrix</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format .  <a href="#ae1d2b8aa5bf56f7479a66d51713708d2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac8061f55851ab8cd200d50bf3e949ccc">copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#ac8061f55851ab8cd200d50bf3e949ccc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#abc6cd55d2644b2c6b5f69cb733fb6f24">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the matrix. Output is compatible to boost::numeric::ublas.  <a href="#abc6cd55d2644b2c6b5f69cb733fb6f24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">transposed_matrix_proxy</a><br class="typebreak"/>
&lt; SCALARTYPE, F, ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8da1dfc8d7832ead0ca3c01ec37c5cf7">trans</a> (<a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an expression template class representing a transposed matrix.  <a href="#a8da1dfc8d7832ead0ca3c01ec37c5cf7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4bd43fae5bc2cdd71e384d1794527add">copy</a> (const CPU_MATRIX &amp;cpu_matrix, <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU).  <a href="#a4bd43fae5bc2cdd71e384d1794527add"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CPU_MATRIX , typename SCALARTYPE , typename F , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0b4ced508c064fe8b45f437b538ed2ca">copy</a> (const <a class="el" href="classviennacl_1_1matrix.html">matrix</a>&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU).  <a href="#a0b4ced508c064fe8b45f437b538ed2ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__times__outer__prod__proxy.html">viennacl::scalar_times_outer_prod_proxy</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ac3402618ff57e6b66ed5bcadc51f9843">operator*</a> (<a class="el" href="classviennacl_1_1outer__prod__proxy.html">viennacl::outer_prod_proxy</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; const &amp;proxy, SCALARTYPE val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int VECTOR_ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__times__outer__prod__proxy.html">viennacl::scalar_times_outer_prod_proxy</a><br class="typebreak"/>
&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3dca91331baecf974234fcd13cee9bbb">operator*</a> (SCALARTYPE val, <a class="el" href="classviennacl_1_1outer__prod__proxy.html">viennacl::outer_prod_proxy</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; const &amp;proxy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5b3d6b04f0d7dac6aec4342e0b37656e">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows to directly print the value of a scalar to an output stream.  <a href="#a5b3d6b04f0d7dac6aec4342e0b37656e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a834e2780c8a9f06bc3330a532b3a3b19">operator&gt;&gt;</a> (std::ostream &amp;s, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows to directly read a value of a scalar from an input stream.  <a href="#a834e2780c8a9f06bc3330a532b3a3b19"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a7953e64a62d2209621a3f4a505dc9f9e">copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a7953e64a62d2209621a3f4a505dc9f9e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a6713b60b19010992ea611ef7ecd4fdf2">copy</a> (const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory.  <a href="#a6713b60b19010992ea611ef7ecd4fdf2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ab80ba5f6bd02bd6ec96a321372d98f7a">copy</a> (<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());.  <a href="#ab80ba5f6bd02bd6ec96a321372d98f7a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a9c694a91cf3e54637ed6a05ab7d9ce75">fast_copy</a> (const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const <a class="el" href="classviennacl_1_1const__vector__iterator.html">const_vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a9c694a91cf3e54637ed6a05ab7d9ce75"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPUVECTOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0d4fd919fa235b1c7dabd0049740e774">copy</a> (const CPUVECTOR &amp;cpu_vec, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());.  <a href="#a0d4fd919fa235b1c7dabd0049740e774"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int ALIGNMENT, typename CPU_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a8425c13c31042c0dd60e2867a6ad1f10">fast_copy</a> (CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, const <a class="el" href="classviennacl_1_1vector__iterator.html">vector_iterator</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector.  <a href="#a8425c13c31042c0dd60e2867a6ad1f10"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a5e572599ddbae8812154538849fa707c">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output stream. Output format is ublas compatible.  <a href="#a5e572599ddbae8812154538849fa707c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a15fc847e38bb974cbe07bd591436b41a">swap</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=viennacl::ocl::device().work_items_per_group())</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the contents of two vectors.  <a href="#a15fc847e38bb974cbe07bd591436b41a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;, const <br class="typebreak"/>
SCALARTYPE, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aa60d7cda126efd13c3413453606850b7">operator*</a> (SCALARTYPE const &amp;value, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector.  <a href="#aa60d7cda126efd13c3413453606850b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;, const <br class="typebreak"/>
<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt;, op_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3b34a609403378a81c3a2589a5418077">operator*</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;value, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the expression alpha * v1, where alpha is a ViennaCL scalar (float or double) and v1 is a ViennaCL vector.  <a href="#a3b34a609403378a81c3a2589a5418077"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#aae3143a0fbb9e586b489cea90acf6659">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the addition of two vector expressions.  <a href="#aae3143a0fbb9e586b489cea90acf6659"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename RHS1 , typename OP1 , typename LHS2 , typename RHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, <br class="typebreak"/>
OP1 &gt;::VectorType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a77d42d098f9212ba53487deb6ddacf57">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the subtraction of two vector expressions.  <a href="#a77d42d098f9212ba53487deb6ddacf57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A, typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a0808ef51d9a2d2e1ecbed3d4b63e159f">operator+</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the addition of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then added to vec2.  <a href="#a0808ef51d9a2d2e1ecbed3d4b63e159f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , unsigned int A, typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#ae00e47f8124b08cbeb8b7fc9ff537081">operator-</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE, A &gt; const &amp;vec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the subtraction of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then added to vec2.  <a href="#ae00e47f8124b08cbeb8b7fc9ff537081"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a00f47d8ad32713f98c6979c245b88cdb">operator*</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then multiplied with alpha from the right.  <a href="#a00f47d8ad32713f98c6979c245b88cdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a3aeb5b431a9c6d0b3af24a1513e8e9ad">operator/</a> (<a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy, <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then divided by alpha.  <a href="#a3aeb5b431a9c6d0b3af24a1513e8e9ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a66a24c58d27c6368ac879f4d7cc4cfc9">operator*</a> (<a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt; SCALARTYPE &gt; const &amp;val, <a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then multiplied with alpha from the left.  <a href="#a66a24c58d27c6368ac879f4d7cc4cfc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SCALARTYPE , typename LHS , typename RHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html#a4522333fedaf508711a5aa02c47e5c7a">operator*</a> (SCALARTYPE val, <a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;proxy)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator overload for the multiplication of a vector expression with a host scalar (float or double) from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then multiplied with alpha from the left.  <a href="#a4522333fedaf508711a5aa02c47e5c7a"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0d4fd919fa235b1c7dabd0049740e774"></a><!-- doxytag: member="viennacl::copy" ref="a0d4fd919fa235b1c7dabd0049740e774" args="(const CPUVECTOR &amp;cpu_vec, vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPUVECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a cpu vector to a gpu vector. Convenience wrapper for viennacl::linalg::copy(cpu_vec.begin(), cpu_vec.end(), gpu_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_vec</em>&nbsp;</td><td>A cpu vector. Type requirements: Iterator can be obtained via member function .begin() and .end() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_vec</em>&nbsp;</td><td>The gpu vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab80ba5f6bd02bd6ec96a321372d98f7a"></a><!-- doxytag: member="viennacl::copy" ref="ab80ba5f6bd02bd6ec96a321372d98f7a" args="(vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_vec, CPUVECTOR &amp;cpu_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPUVECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer from a gpu vector to a cpu vector. Convenience wrapper for viennacl::linalg::copy(gpu_vec.begin(), gpu_vec.end(), cpu_vec.begin());. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_vec</em>&nbsp;</td><td>A gpu vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_vec</em>&nbsp;</td><td>The cpu vector. Type requirements: Output iterator can be obtained via member function .begin() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6713b60b19010992ea611ef7ecd4fdf2"></a><!-- doxytag: member="viennacl::copy" ref="a6713b60b19010992ea611ef7ecd4fdf2" args="(const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_end</em>&nbsp;</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7953e64a62d2209621a3f4a505dc9f9e"></a><!-- doxytag: member="viennacl::copy" ref="a7953e64a62d2209621a3f4a505dc9f9e" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>GPU constant iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_end</em>&nbsp;</td><td>GPU constant iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b4ced508c064fe8b45f437b538ed2ca"></a><!-- doxytag: member="viennacl::copy" ref="a0b4ced508c064fe8b45f437b538ed2ca" args="(const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the OpenCL device (GPU or multi-core CPU) to the host (CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A dense memory on the host. Must have at least as many rows and columns as the gpu_matrix! Type requirement: Access to entries via operator() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bd43fae5bc2cdd71e384d1794527add"></a><!-- doxytag: member="viennacl::copy" ref="a4bd43fae5bc2cdd71e384d1794527add" args="(const CPU_MATRIX &amp;cpu_matrix, matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a dense matrix from the host (CPU) to the OpenCL device (GPU or multi-core CPU). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A dense memory on the host. Type requirements: .size1() returns number of rows, .size2() returns number of columns. Access to entries via operator() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8061f55851ab8cd200d50bf3e949ccc"></a><!-- doxytag: member="viennacl::copy" ref="ac8061f55851ab8cd200d50bf3e949ccc" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer for the entries of a GPU vector to the CPU. The cpu type does not need to lie in a linear piece of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>CPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_end</em>&nbsp;</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1d2b8aa5bf56f7479a66d51713708d2"></a><!-- doxytag: member="viennacl::copy" ref="ae1d2b8aa5bf56f7479a66d51713708d2" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2ea05f107d5ec7f31214a2898ccbe08"></a><!-- doxytag: member="viennacl::copy" ref="ab2ea05f107d5ec7f31214a2898ccbe08" args="(const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fb2cd615454e656202d5d6f1a54483"></a><!-- doxytag: member="viennacl::copy" ref="ab4fb2cd615454e656202d5d6f1a54483" args="(const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1coordinate__matrix.html" title="A sparse square matrix, where entries are stored as triplets (i,j, val), where i...">coordinate_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87f711ebb1d8fd6435d31f1841f9cfaf"></a><!-- doxytag: member="viennacl::copy" ref="a87f711ebb1d8fd6435d31f1841f9cfaf" args="(const CPU_MATRIX &amp;cpu_matrix, coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coordinate_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU). </p>
<p>For the requirements on the CPU_MATRIX type, see the documentation of the function copy(CPU_MATRIX, compressed_matrix&lt;&gt;)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a0feeb7a31a31f45e1d014512758fe6"></a><!-- doxytag: member="viennacl::copy" ref="a8a0feeb7a31a31f45e1d014512758fe6" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from an OpenCL device to the host. The host type is the std::vector&lt; std::map &lt; &gt; &gt; format . </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b202ebcc6108940a59881c42f3d86da"></a><!-- doxytag: member="viennacl::copy" ref="a6b202ebcc6108940a59881c42f3d86da" args="(const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix, CPU_MATRIX &amp;cpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the OpenCL device (either GPU or multi-core CPU) to the host. </p>
<p>There are two type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>resize(rows, cols) A resize function to bring the matrix into the correct size</li>
<li>operator(i,j) Write new entries via the parenthesis operator</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25d1118aadbe1e6cb69b70df35f94763"></a><!-- doxytag: member="viennacl::copy" ref="a25d1118aadbe1e6cb69b70df35f94763" args="(const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::map&lt; unsigned int, SCALARTYPE &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix in the std::vector&lt; std::map &lt; &gt; &gt; format to an OpenCL device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5684964ce1519c88a443aa14be9428f0"></a><!-- doxytag: member="viennacl::copy" ref="a5684964ce1519c88a443aa14be9428f0" args="(const CPU_MATRIX &amp;cpu_matrix, compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::copy </td>
          <td>(</td>
          <td class="paramtype">const CPU_MATRIX &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">compressed_matrix&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core CPU). </p>
<p>There are some type requirements on the CPU_MATRIX type (fulfilled by e.g. boost::numeric::ublas):</p>
<ul>
<li>.size1() returns the number of rows</li>
<li>.size2() returns the number of columns</li>
<li>const_iterator1 is a type definition for an iterator along increasing row indices</li>
<li>const_iterator2 is a type definition for an iterator along increasing columns indices</li>
<li>The const_iterator1 type provides an iterator of type const_iterator2 via members .begin() and .end() that iterates along column indices in the current row.</li>
<li>The types const_iterator1 and const_iterator2 provide members functions .index1() and .index2() that return the current row and column indices respectively.</li>
<li>Dereferenciation of an object of type const_iterator2 returns the entry.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_matrix</em>&nbsp;</td><td>A sparse matrix on the host. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A <a class="el" href="classviennacl_1_1compressed__matrix.html" title="A sparse square matrix in compressed sparse rows format.">compressed_matrix</a> from ViennaCL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8425c13c31042c0dd60e2867a6ad1f10"></a><!-- doxytag: member="viennacl::fast_copy" ref="a8425c13c31042c0dd60e2867a6ad1f10" args="(CPU_ITERATOR const &amp;cpu_begin, CPU_ITERATOR const &amp;cpu_end, const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR const &amp;&nbsp;</td>
          <td class="paramname"> <em>cpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a CPU vector to the GPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core...">copy()</a> function, because entries are directly read from the cpu vector, starting with &amp;(*cpu.begin()). However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>CPU iterator pointing to the beginning of the cpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_end</em>&nbsp;</td><td>CPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>Output iterator for the gpu vector. The gpu vector must be at least as long as the cpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c694a91cf3e54637ed6a05ab7d9ce75"></a><!-- doxytag: member="viennacl::fast_copy" ref="a9c694a91cf3e54637ed6a05ab7d9ce75" args="(const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_begin, const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;gpu_end, CPU_ITERATOR cpu_begin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::fast_copy </td>
          <td>(</td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_vector_iterator&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CPU_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>cpu_begin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>STL-like transfer of a GPU vector to the CPU. The cpu type is assumed to reside in a linear piece of memory, such as e.g. for std::vector. </p>
<p>This method is faster than the plain <a class="el" href="namespaceviennacl.html#a5684964ce1519c88a443aa14be9428f0" title="Copies a sparse matrix from the host to the OpenCL device (either GPU or multi-core...">copy()</a> function, because entries are directly written to the cpu vector, starting with &amp;(*cpu.begin()) However, keep in mind that the cpu type MUST represent a linear piece of memory, otherwise you will run into undefined behavior.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gpu_begin</em>&nbsp;</td><td>GPU iterator pointing to the beginning of the gpu vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_end</em>&nbsp;</td><td>GPU iterator pointing to the end of the vector (STL-like) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpu_begin</em>&nbsp;</td><td>Output iterator for the cpu vector. The cpu vector must be at least as long as the gpu vector! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4522333fedaf508711a5aa02c47e5c7a"></a><!-- doxytag: member="viennacl::operator*" ref="a4522333fedaf508711a5aa02c47e5c7a" args="(SCALARTYPE val, viennacl::vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt;SCALARTYPE&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector__expression.html">viennacl::vector_expression</a>&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a host scalar (float or double) from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66a24c58d27c6368ac879f4d7cc4cfc9"></a><!-- doxytag: member="viennacl::operator*" ref="a66a24c58d27c6368ac879f4d7cc4cfc9" args="(scalar&lt; SCALARTYPE &gt; const &amp;val, vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a ViennaCL scalar from the left, e.g. alpha * (beta * vec1). Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then multiplied with alpha from the left. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00f47d8ad32713f98c6979c245b88cdb"></a><!-- doxytag: member="viennacl::operator*" ref="a00f47d8ad32713f98c6979c245b88cdb" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, scalar&lt; SCALARTYPE &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the multiplication of a vector expression with a scalar from the right, e.g. (beta * vec1) * alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then multiplied with alpha from the right. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b34a609403378a81c3a2589a5418077"></a><!-- doxytag: member="viennacl::operator*" ref="a3b34a609403378a81c3a2589a5418077" args="(scalar&lt; SCALARTYPE &gt; const &amp;value, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt;, const <a class="el" href="classviennacl_1_1scalar.html">scalar</a>&lt;SCALARTYPE&gt;, op_prod&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a ViennaCL scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The ViennaCL scalar </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa60d7cda126efd13c3413453606850b7"></a><!-- doxytag: member="viennacl::operator*" ref="aa60d7cda126efd13c3413453606850b7" args="(SCALARTYPE const &amp;value, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; const <a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt;, const SCALARTYPE, op_prod&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the expression alpha * v1, where alpha is a host scalar (float or double) and v1 is a ViennaCL vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The host scalar (float or double) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>A ViennaCL vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dca91331baecf974234fcd13cee9bbb"></a><!-- doxytag: member="viennacl::operator*" ref="a3dca91331baecf974234fcd13cee9bbb" args="(SCALARTYPE val, viennacl::outer_prod_proxy&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; const &amp;proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__times__outer__prod__proxy.html">viennacl::scalar_times_outer_prod_proxy</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1outer__prod__proxy.html">viennacl::outer_prod_proxy</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3402618ff57e6b66ed5bcadc51f9843"></a><!-- doxytag: member="viennacl::operator*" ref="ac3402618ff57e6b66ed5bcadc51f9843" args="(viennacl::outer_prod_proxy&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; const &amp;proxy, SCALARTYPE val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1scalar__times__outer__prod__proxy.html">viennacl::scalar_times_outer_prod_proxy</a>&lt;SCALARTYPE, VECTOR_ALIGNMENT&gt; viennacl::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1outer__prod__proxy.html">viennacl::outer_prod_proxy</a>&lt; SCALARTYPE, VECTOR_ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SCALARTYPE&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0808ef51d9a2d2e1ecbed3d4b63e159f"></a><!-- doxytag: member="viennacl::operator+" ref="a0808ef51d9a2d2e1ecbed3d4b63e159f" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt; viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then added to vec2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>Right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae3143a0fbb9e586b489cea90acf6659"></a><!-- doxytag: member="viennacl::operator+" ref="aae3143a0fbb9e586b489cea90acf6659" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;::VectorType viennacl::operator+ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the addition of two vector expressions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy1</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy2</em>&nbsp;</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae00e47f8124b08cbeb8b7fc9ff537081"></a><!-- doxytag: member="viennacl::operator&#45;" ref="ae00e47f8124b08cbeb8b7fc9ff537081" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, vector&lt; SCALARTYPE, A &gt; const &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE, A&gt; viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of a vector expression from the left, e.g. alpha * vec1 + vec2. Here, alpha * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then added to vec2. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec</em>&nbsp;</td><td>Right hand side vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77d42d098f9212ba53487deb6ddacf57"></a><!-- doxytag: member="viennacl::operator&#45;" ref="a77d42d098f9212ba53487deb6ddacf57" args="(vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;proxy1, vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;proxy2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector__expression.html">vector_expression</a>&lt; LHS1, RHS1, OP1&gt;::VectorType viennacl::operator- </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS1, RHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_expression&lt; LHS2, RHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the subtraction of two vector expressions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy1</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proxy2</em>&nbsp;</td><td>Right hand side vector expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aeb5b431a9c6d0b3af24a1513e8e9ad"></a><!-- doxytag: member="viennacl::operator/" ref="a3aeb5b431a9c6d0b3af24a1513e8e9ad" args="(vector_expression&lt; LHS, RHS, OP &gt; const &amp;proxy, scalar&lt; SCALARTYPE &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1vector.html">vector</a>&lt;SCALARTYPE&gt; viennacl::operator/ </td>
          <td>(</td>
          <td class="paramtype">vector_expression&lt; LHS, RHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&lt; SCALARTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator overload for the division of a vector expression by a scalar from the right, e.g. (beta * vec1) / alpha. Here, beta * vec1 is wrapped into a <a class="el" href="classviennacl_1_1vector__expression.html" title="An expression template class that represents a binary operation that yields a vector...">vector_expression</a> and then divided by alpha. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>Left hand side vector expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Right hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e572599ddbae8812154538849fa707c"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a5e572599ddbae8812154538849fa707c" args="(std::ostream &amp;s, vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; SCALARTYPE, ALIGNMENT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output stream. Output format is ublas compatible. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>STL output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The vector that should be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b3d6b04f0d7dac6aec4342e0b37656e"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="a5b3d6b04f0d7dac6aec4342e0b37656e" args="(std::ostream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly print the value of a scalar to an output stream. </p>

</div>
</div>
<a class="anchor" id="abc6cd55d2644b2c6b5f69cb733fb6f24"></a><!-- doxytag: member="viennacl::operator&lt;&lt;" ref="abc6cd55d2644b2c6b5f69cb733fb6f24" args="(std::ostream &amp;s, const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;gpu_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennacl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>gpu_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the matrix. Output is compatible to boost::numeric::ublas. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>STL output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gpu_matrix</em>&nbsp;</td><td>A dense ViennaCL matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a834e2780c8a9f06bc3330a532b3a3b19"></a><!-- doxytag: member="viennacl::operator&gt;&gt;" ref="a834e2780c8a9f06bc3330a532b3a3b19" args="(std::ostream &amp;s, const scalar&lt; SCALARTYPE &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; viennacl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const scalar&lt; SCALARTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to directly read a value of a scalar from an input stream. </p>

</div>
</div>
<a class="anchor" id="a15fc847e38bb974cbe07bd591436b41a"></a><!-- doxytag: member="viennacl::swap" ref="a15fc847e38bb974cbe07bd591436b41a" args="(viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, viennacl::vector&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=viennacl::ocl::device().work_items_per_group())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennacl::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NUM_THREADS</em> = <code>viennacl::ocl::device().work_items_per_group()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two vectors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vec1</em>&nbsp;</td><td>The first vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vec2</em>&nbsp;</td><td>The second vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NUM_THREADS</em>&nbsp;</td><td>The number of threads per work group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8da1dfc8d7832ead0ca3c01ec37c5cf7"></a><!-- doxytag: member="viennacl::trans" ref="a8da1dfc8d7832ead0ca3c01ec37c5cf7" args="(matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennacl_1_1transposed__matrix__proxy.html">transposed_matrix_proxy</a>&lt;SCALARTYPE, F, ALIGNMENT&gt; viennacl::trans </td>
          <td>(</td>
          <td class="paramtype">matrix&lt; SCALARTYPE, F, ALIGNMENT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an expression template class representing a transposed matrix. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 8 13:48:32 2010 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
