\chapter{Algorithms}

This chapter gives an overview over the available algorithms in {\ViennaCL}. The focus of {\ViennaCL} is on iterative solvers, for which {\ViennaCL} provides a generic implementation that allows the use of the same code on the CPU and on the GPU.

\section{Direct Solvers} \label{sec:direct-solvers}
{\ViennaCLversion} provides triangular solvers and LU factorization without pivoting for the solution of dense linear systems. The interface is similar to that of {\ublas}

\begin{lstlisting}
  viennacl::matrix<float>  vcl_matrix;
  viennacl::vector<float>  vcl_rhs;
  viennacl::vector<float>  vcl_result;

  /* Set up matrix and vectors here */

  //solution of an upper triangular system:
  vcl_result = viennacl::linalg::solve(vcl_matrix,
                                       vcl_rhs,
                                       viennacl::linalg::upper_tag());
  //solution of an lower triangular system:
  vcl_result = viennacl::linalg::solve(vcl_matrix,
                                       vcl_rhs,
                                       viennacl::linalg::lower_tag());

  //solution of a full system right into the load vector vcl_rhs:
  viennacl::linalg::lu_factorize(vcl_matrix);
  viennacl::linalg::lu_substitute(vcl_matrix, vcl_rhs);    
\end{lstlisting}
In {\ViennaCLminorversion} there is no pivoting included in the LU factorization process, hence the computation may break down or yield results with poor accuracy. However, for certain classes of matrices (like diagonal dominant matrices) good results can be obtained without pivoting.

\section{Iterative Solvers} \label{sec:iterative-solvers}
{\ViennaCL} provides different iterative solvers for various classes of
matrices, listed in Tab.~\ref{tab:linear-solvers}. Unlike direct solvers, the
convergence of iterative solvers relies on certain properties of the system
matrix. Keep in mind that an iterative solver may fail to converge, especially
if the matrix is ill conditioned or a wrong solver is chosen. 


\TIP{For full details on linear solver calls, refer to the reference
documentation located in \texttt{doc/doxygen/} and to the tutorials}

\TIP{The iterative solvers can directly be used for {\ublas} objects!}

\NOTE{In {\ViennaCLversion}, GMRES using ATI GPUs is known to yield wrong results! 
 However, GMRES works smoothly if using the ATI Stream SDK on CPUs.
 At present it is not clear whether these problems on ATI GPUs are caused by {\ViennaCL} or the ATI Stream SDK.}

\begin{lstlisting}
viennacl::compressed_matrix<float>  vcl_matrix;
viennacl::vector<float>  vcl_rhs;
viennacl::vector<float>  vcl_result;

/* Set up matrix and vectors here */

//solution using conjugate gradient solver:
vcl_result = viennacl::linalg::solve(vcl_matrix,
				      vcl_rhs,
				      viennacl::linalg::cg_tag());

//solution using BiCGStab solver:
vcl_result = viennacl::linalg::solve(vcl_matrix,
				      vcl_rhs,
				      viennacl::linalg::bicgstab_tag());

//solution using GMRES solver:
vcl_result = viennacl::linalg::solve(vcl_matrix,
				      vcl_rhs,
				      viennacl::linalg::gmres_tag());
\end{lstlisting}

\begin{table}[tb]
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{4cm}|p{3cm}|p{7.5cm}}
Method & Matrix class & ViennaCL\\
\hline
Conjugate Gradient (CG) & symmetric positive definite & \texttt{y = solve(A, x, cg\_tag());} \\
Stabilized Bi-CG (BiCGStab) & non-symmetric & \texttt{y = solve(A, x, bicgstab\_tag());} \\
Generalized Minimum Residual (GMRES) & general & \texttt{y = solve(A, x, gmres\_tag());} \\
\hline
\end{tabular}
\caption{Linear solver routines in {\ViennaCL} for the computation of $y$ in the expression $Ay = x$ with given $A$, $x$.}
\label{tab:linear-solvers}
\end{center}
\end{table}


\section{Preconditioners}
{\ViennaCL} ships with a generic implementation of an incomplete LU factorization preconditioner with threshold (ILUT). The incomplete factorization is computed on a single CPU core due to its sequential nature, so one must not expect large performance gains if most time is spent on preconditioning. Other preconditioners more suitable for GPUs are in preparation.

\TIP{The preconditioner also works for {\ublas} types!}

\begin{lstlisting}
using viennacl::linalg::ilut_precond;
using viennacl::compressed_matrix;

compressed_matrix<float>  vcl_matrix;
viennacl::vector<float>  vcl_rhs;
viennacl::vector<float>  vcl_result;

/* Set up matrix and vectors here */

//compute preconditioner:
ilut_precond< compressed_matrix<float> > vcl_ilut(vcl_matrix,
                                                  viennacl::linalg::ilut_tag());

//solve (e.g. using conjugate gradient solver)
vcl_result = viennacl::linalg::solve(vcl_matrix,
                                     vcl_rhs,
                                     viennacl::linalg::cg_tag(),
                                     vcl_ilut);   //preconditioner provided here
\end{lstlisting}

% 
% \section{Eigenvalues}
% {\ViennaCL} provides the methods listed in Tab.~\ref{tab:eigenvalue-computations} for eigenvalue computations.
% 
% \TIP{For full details on functions for eigenvalue computations, refer to the
% reference documentation located in \texttt{doc/doxygen/}}
% 
% 
% \begin{table}[tb]
% \begin{center}
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{l|l|l}
% Method & Used for & ViennaCL\\
% \hline
% Lanczos & symmetric matrices & \texttt{lanczos(A, x, y);} \\
% Arnoldi & non-symmetric matrices & \texttt{arnoldi(A, x, y);} \\
% \hline
% \end{tabular}
% \caption{Eigenvalue routines in {\ViennaCL}. \texttt{y} denotes the vector the
% result is written to. The length of \texttt{y} equals to the number of
% eigenvalues computed.}
% 
% \label{tab:eigenvalue-computations}
% \end{center}
% \end{table}
% 
% 


%}