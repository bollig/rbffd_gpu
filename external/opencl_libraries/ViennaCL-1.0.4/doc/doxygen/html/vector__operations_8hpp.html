<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: /export/development/ViennaCL/ViennaCL-1.0.4/viennacl/linalg/vector_operations.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/export/development/ViennaCL/ViennaCL-1.0.4/viennacl/linalg/vector_operations.hpp File Reference</h1><code>#include &quot;<a class="el" href="forwards_8h_source.html">viennacl/forwards.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="device_8hpp_source.html">viennacl/ocl/device.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="handle_8hpp_source.html">viennacl/ocl/handle.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="kernel_8hpp_source.html">viennacl/ocl/kernel.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="scalar_8hpp_source.html">viennacl/scalar.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tools_8hpp_source.html">viennacl/tools/tools.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="vector__kernels_8h_source.html">viennacl/linalg/kernels/vector_kernels.h</a>&quot;</code><br/>

<p><a href="vector__operations_8hpp_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl.html">viennacl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html">viennacl::linalg</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#ace5ef08d2e7baddbd98262f0093665de">add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#ace5ef08d2e7baddbd98262f0093665de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a57d94fbbd2c6becdc836360b48560c36">inplace_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a57d94fbbd2c6becdc836360b48560c36"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a99aa3a3f1e37472564b2b73c61231a37">sub</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtraction of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a99aa3a3f1e37472564b2b73c61231a37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6df0e919b134ddfd7ef814e35b9d71b1">inplace_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace addition of two vectors. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6df0e919b134ddfd7ef814e35b9d71b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#abd5ba35456dad83b2b92bdc2b975f1de">mult</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#abd5ba35456dad83b2b92bdc2b975f1de"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aad80ec890c37305239e26131957a60fb">mult</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aad80ec890c37305239e26131957a60fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6324a36a09e1a21cc4cc4d866dda5bc4">inplace_mult</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6324a36a09e1a21cc4cc4d866dda5bc4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aecbb67f095fe30240a634cce5dfe8e66">inplace_mult</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, SCALARTYPE alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#aecbb67f095fe30240a634cce5dfe8e66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a951fc996a086d8d946471305bd947de3">divide</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a951fc996a086d8d946471305bd947de3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acc6c8bf5616af9dd1402d85d23cc7d2b">inplace_divide</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scales a vector inplace. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#acc6c8bf5616af9dd1402d85d23cc7d2b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6469ec227ee3c0a9f8c9e31d16e80856">mul_add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, scalar&lt; SCALARTYPE &gt; const &amp;alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6469ec227ee3c0a9f8c9e31d16e80856"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a148b16c1cf52db44408ff100bda45be2">mul_add</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, SCALARTYPE alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a148b16c1cf52db44408ff100bda45be2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a4911ae3ec8685a1f041e37c009c31892">inplace_mul_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a4911ae3ec8685a1f041e37c009c31892"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#adab8fb5aa2530e48c7ba7d2987aa4448">inplace_mul_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#adab8fb5aa2530e48c7ba7d2987aa4448"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a7ab4e344aa136d4221bc2f22c1431a03">mul_sub</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, scalar&lt; SCALARTYPE &gt; const &amp;alpha, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;result, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a7ab4e344aa136d4221bc2f22c1431a03"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a247561256ec5f76d90f68cd4271749ea">inplace_mul_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace Multiply-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a247561256ec5f76d90f68cd4271749ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a6e9cf3be544743cf0f79d8eea4d63b3b">inplace_div_add</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace divide-add operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a6e9cf3be544743cf0f79d8eea4d63b3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a11f746acdd474fb7de5347e562fb92d6">inplace_div_sub</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; const &amp;alpha, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inplace divide-subtract operation. Try to use the overloaded operators for vector instead, unless you want to fine-tune the number of GPU threads involved.  <a href="#a11f746acdd474fb7de5347e562fb92d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a507b21e23e973342ea180f6f0cfed447">inner_prod_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, scalar&lt; SCALARTYPE &gt; &amp;result, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the inner product of two vectors - implementation. Library users should call inner_prod(vec1, vec2).  <a href="#a507b21e23e973342ea180f6f0cfed447"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT1, unsigned int ALIGNMENT2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennacl_1_1scalar__expression.html">viennacl::scalar_expression</a><br class="typebreak"/>
&lt; const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT1 &gt;<br class="typebreak"/>
, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a><br class="typebreak"/>
&lt; SCALARTYPE, ALIGNMENT2 &gt;<br class="typebreak"/>
, viennacl::op_inner_prod &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#acec2a9ca55e33f98defcde0b2cf3db18">inner_prod_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT1 &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT2 &gt; &amp;vec2, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the inner product of two vectors.  <a href="#acec2a9ca55e33f98defcde0b2cf3db18"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SCALARTYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a773963ad0576dedd6ea9677a964d7eb6">norm_1</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the l^1-norm of a vector.  <a href="#a773963ad0576dedd6ea9677a964d7eb6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a8cb58d3e096e8eefd750aee35249765e">norm_2_impl</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, scalar&lt; SCALARTYPE &gt; &amp;result, unsigned int NUM_THREADS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the l^2-norm of a vector - implementation.  <a href="#a8cb58d3e096e8eefd750aee35249765e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">SCALARTYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#aed0642dda58cce7ebceffceb2bb1dc7c">norm_inf</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the supremum-norm of a vector.  <a href="#aed0642dda58cce7ebceffceb2bb1dc7c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cl_uint&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a3b084a55303d0df592ffd96ea591eb93">index_norm_inf</a> (const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vcl_vec, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the index of the first entry that is equal to the supremum-norm in modulus.  <a href="#a3b084a55303d0df592ffd96ea591eb93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SCALARTYPE , unsigned int ALIGNMENT&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennacl_1_1linalg.html#a475332833e58b7d657544f3e40164f9a">plane_rotation</a> (<a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec1, const <a class="el" href="classviennacl_1_1vector.html">viennacl::vector</a>&lt; SCALARTYPE, ALIGNMENT &gt; &amp;vec2, SCALARTYPE alpha, SCALARTYPE beta, unsigned int NUM_THREADS=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes a plane rotation of two vectors.  <a href="#a475332833e58b7d657544f3e40164f9a"></a><br/></td></tr>
</table>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 8 13:48:32 2010 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
