<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaCL - The Vienna Computing Library: /export/development/ViennaCL/ViennaCL-1.0.4/viennacl/linalg/vector_operations.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>/export/development/ViennaCL/ViennaCL-1.0.4/viennacl/linalg/vector_operations.hpp</h1><a href="vector__operations_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* =======================================================================</span>
<a name="l00002"></a>00002 <span class="comment">   Copyright (c) 2010, Institute for Microelectronics, TU Vienna.</span>
<a name="l00003"></a>00003 <span class="comment">   http://www.iue.tuwien.ac.at</span>
<a name="l00004"></a>00004 <span class="comment">                             -----------------</span>
<a name="l00005"></a>00005 <span class="comment">                     ViennaCL - The Vienna Computing Library</span>
<a name="l00006"></a>00006 <span class="comment">                             -----------------</span>
<a name="l00007"></a>00007 <span class="comment">                            </span>
<a name="l00008"></a>00008 <span class="comment">   authors:    Karl Rupp                          rupp@iue.tuwien.ac.at</span>
<a name="l00009"></a>00009 <span class="comment">               Florian Rudolf                     flo.rudy+viennacl@gmail.com</span>
<a name="l00010"></a>00010 <span class="comment">               Josef Weinbub                      weinbub@iue.tuwien.ac.at</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   license:    MIT (X11), see file LICENSE in the ViennaCL base directory</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   file changelog: - May 28, 2010   New from scratch for first release</span>
<a name="l00015"></a>00015 <span class="comment">======================================================================= */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef _VIENNACL_VECTOR_OPERATIONS_HPP_</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define _VIENNACL_VECTOR_OPERATIONS_HPP_</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="This file provides the forward declarations for the main types used within ViennaCL...">viennacl/forwards.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="device_8hpp.html">viennacl/ocl/device.hpp</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="handle_8hpp.html">viennacl/ocl/handle.hpp</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="kernel_8hpp.html">viennacl/ocl/kernel.hpp</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="scalar_8hpp.html">viennacl/scalar.hpp</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="tools_8hpp.html">viennacl/tools/tools.hpp</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="vector__kernels_8h.html">viennacl/linalg/kernels/vector_kernels.h</a>&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keyword">namespace </span>viennacl
<a name="l00029"></a>00029 {
<a name="l00030"></a>00030   <span class="keyword">namespace </span>linalg
<a name="l00031"></a>00031   {
<a name="l00039"></a>00039     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00040"></a><a class="code" href="namespaceviennacl_1_1linalg.html#ace5ef08d2e7baddbd98262f0093665de">00040</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6ca4f06df288fda54a8ed6f5665b19df" title="Adds two dense matrices and writes the result to a third matrix.">add</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1, 
<a name="l00041"></a>00041              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2, 
<a name="l00042"></a>00042              <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result, 
<a name="l00043"></a>00043              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00044"></a>00044     {
<a name="l00045"></a>00045       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00046"></a>00046       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00047"></a>00047       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00048"></a>00048       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00049"></a>00049       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00050"></a>00050       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00051"></a>00051       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::add</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00052"></a>00052       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::add</a>.setArgument(pos++, size);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00055"></a>00055         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00056"></a>00056                                                                               <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00057"></a>00057       <span class="keywordflow">else</span>
<a name="l00058"></a>00058         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060 
<a name="l00069"></a>00069     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00070"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a57d94fbbd2c6becdc836360b48560c36">00070</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a57d94fbbd2c6becdc836360b48560c36" title="Inplace addition of two vectors. Try to use the overloaded operators for vector instead...">inplace_add</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00071"></a>00071                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2, 
<a name="l00072"></a>00072                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00073"></a>00073     {
<a name="l00074"></a>00074       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00075"></a>00075       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00076"></a>00076       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00077"></a>00077       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00078"></a>00078       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00079"></a>00079       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_add</a>.setArgument(pos++, size);
<a name="l00080"></a>00080 
<a name="l00081"></a>00081       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00082"></a>00082         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00083"></a>00083                                                                                      <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00084"></a>00084       <span class="keywordflow">else</span>
<a name="l00085"></a>00085         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00086"></a>00086     }
<a name="l00087"></a>00087 
<a name="l00097"></a>00097     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00098"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a99aa3a3f1e37472564b2b73c61231a37">00098</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a99aa3a3f1e37472564b2b73c61231a37" title="Subtraction of two vectors. Try to use the overloaded operators for vector instead...">sub</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00099"></a>00099              <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00100"></a>00100              <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00101"></a>00101              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00104"></a>00104       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00105"></a>00105       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00106"></a>00106       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00107"></a>00107       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sub</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00108"></a>00108       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sub</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00109"></a>00109       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sub</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00110"></a>00110       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sub</a>.setArgument(pos++, size);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00113"></a>00113         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00114"></a>00114                                                                              <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00115"></a>00115       <span class="keywordflow">else</span>
<a name="l00116"></a>00116         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00117"></a>00117     }
<a name="l00118"></a>00118 
<a name="l00127"></a>00127     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00128"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a6df0e919b134ddfd7ef814e35b9d71b1">00128</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6df0e919b134ddfd7ef814e35b9d71b1" title="Inplace addition of two vectors. Try to use the overloaded operators for vector instead...">inplace_sub</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1, 
<a name="l00129"></a>00129                      <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00130"></a>00130                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00131"></a>00131     {
<a name="l00132"></a>00132       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00133"></a>00133       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00134"></a>00134       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00135"></a>00135       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_sub</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00136"></a>00136       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_sub</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00137"></a>00137       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_sub</a>.setArgument(pos++, size);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00140"></a>00140         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00141"></a>00141                                                                                      <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00142"></a>00142       <span class="keywordflow">else</span>
<a name="l00143"></a>00143         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     <span class="comment">//result = vec * scalar</span>
<a name="l00157"></a>00157 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00158"></a><a class="code" href="namespaceviennacl_1_1linalg.html#abd5ba35456dad83b2b92bdc2b975f1de">00158</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#abd5ba35456dad83b2b92bdc2b975f1de" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you...">mult</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec,
<a name="l00159"></a>00159               <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00160"></a>00160               <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00161"></a>00161               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00164"></a>00164       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00165"></a>00165       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00166"></a>00166       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::mult</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00167"></a>00167       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::mult</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00168"></a>00168       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00169"></a>00169 
<a name="l00170"></a>00170       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00171"></a>00171         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00172"></a>00172                                                                                <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00173"></a>00173       <span class="keywordflow">else</span>
<a name="l00174"></a>00174         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176 
<a name="l00186"></a>00186     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00187"></a><a class="code" href="namespaceviennacl_1_1linalg.html#aad80ec890c37305239e26131957a60fb">00187</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#abd5ba35456dad83b2b92bdc2b975f1de" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you...">mult</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec,
<a name="l00188"></a>00188               SCALARTYPE alpha,
<a name="l00189"></a>00189               <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00190"></a>00190               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00191"></a>00191     {
<a name="l00192"></a>00192       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00193"></a>00193       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00194"></a>00194       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00195"></a>00195       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_mult</a>.setArgument(pos++, alpha);
<a name="l00196"></a>00196       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_mult</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00197"></a>00197       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00198"></a>00198 
<a name="l00199"></a>00199       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00200"></a>00200         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00201"></a>00201                                                                                    <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00202"></a>00202       <span class="keywordflow">else</span>
<a name="l00203"></a>00203         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205 
<a name="l00214"></a>00214     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00215"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a6324a36a09e1a21cc4cc4d866dda5bc4">00215</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6324a36a09e1a21cc4cc4d866dda5bc4" title="Scales a vector inplace. Try to use the overloaded operators for vector instead,...">inplace_mult</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec,
<a name="l00216"></a>00216                       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00217"></a>00217                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00218"></a>00218     {
<a name="l00219"></a>00219       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00220"></a>00220       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00221"></a>00221       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_mult</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00222"></a>00222       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00223"></a>00223 
<a name="l00224"></a>00224       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00225"></a>00225         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00226"></a>00226                                                                                        <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00227"></a>00227       <span class="keywordflow">else</span>
<a name="l00228"></a>00228         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00239"></a>00239     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00240"></a><a class="code" href="namespaceviennacl_1_1linalg.html#aecbb67f095fe30240a634cce5dfe8e66">00240</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6324a36a09e1a21cc4cc4d866dda5bc4" title="Scales a vector inplace. Try to use the overloaded operators for vector instead,...">inplace_mult</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec,
<a name="l00241"></a>00241                       SCALARTYPE alpha,
<a name="l00242"></a>00242                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00243"></a>00243     {
<a name="l00244"></a>00244       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00245"></a>00245       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_inplace_mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00246"></a>00246       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_inplace_mult</a>.setArgument(pos++, alpha);
<a name="l00247"></a>00247       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_inplace_mult</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00248"></a>00248 
<a name="l00249"></a>00249       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00250"></a>00250         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_inplace_mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00251"></a>00251                                                                                            <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00252"></a>00252       <span class="keywordflow">else</span>
<a name="l00253"></a>00253         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::cpu_inplace_mult</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="comment">//result = vec / scalar</span>
<a name="l00266"></a>00266 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00267"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a951fc996a086d8d946471305bd947de3">00267</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a951fc996a086d8d946471305bd947de3" title="Scales a vector. Try to use the overloaded operators for vector instead, unless you...">divide</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec,
<a name="l00268"></a>00268                 <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00269"></a>00269                 <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00270"></a>00270                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00271"></a>00271     {
<a name="l00272"></a>00272       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00273"></a>00273       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00274"></a>00274       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::divide</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00275"></a>00275       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::divide</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00276"></a>00276       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::divide</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00277"></a>00277       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::divide</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00278"></a>00278 
<a name="l00279"></a>00279       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00280"></a>00280         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::divide</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00281"></a>00281                                                                                  <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00282"></a>00282       <span class="keywordflow">else</span>
<a name="l00283"></a>00283         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::divide</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 
<a name="l00294"></a>00294     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00295"></a><a class="code" href="namespaceviennacl_1_1linalg.html#acc6c8bf5616af9dd1402d85d23cc7d2b">00295</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#acc6c8bf5616af9dd1402d85d23cc7d2b" title="Scales a vector inplace. Try to use the overloaded operators for vector instead,...">inplace_divide</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec,
<a name="l00296"></a>00296                         <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00297"></a>00297                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00298"></a>00298     {
<a name="l00299"></a>00299       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00300"></a>00300       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_divide</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00301"></a>00301       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_divide</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00302"></a>00302       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_divide</a>.setArgument(pos++, vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00303"></a>00303 
<a name="l00304"></a>00304       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00305"></a>00305         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_divide</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00306"></a>00306                                                                                          <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00307"></a>00307       <span class="keywordflow">else</span>
<a name="l00308"></a>00308         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE, ALIGNMENT&gt;::inplace_divide</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     <span class="comment">//result = factor * vec1 + vec2</span>
<a name="l00322"></a>00322 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00323"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a6469ec227ee3c0a9f8c9e31d16e80856">00323</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6469ec227ee3c0a9f8c9e31d16e80856" title="Multiply-add operation. Try to use the overloaded operators for vector instead, unless...">mul_add</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00324"></a>00324                  <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00325"></a>00325                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00326"></a>00326                  <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00327"></a>00327                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00328"></a>00328     {
<a name="l00329"></a>00329       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00330"></a>00330       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00331"></a>00331       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00332"></a>00332       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00333"></a>00333       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00334"></a>00334       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00335"></a>00335       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00336"></a>00336       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00337"></a>00337       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.setArgument(pos++, size);
<a name="l00338"></a>00338 
<a name="l00339"></a>00339       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00340"></a>00340         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00341"></a>00341                                                                                  <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00342"></a>00342       <span class="keywordflow">else</span>
<a name="l00343"></a>00343         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00344"></a>00344     }
<a name="l00345"></a>00345 
<a name="l00356"></a>00356     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00357"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a148b16c1cf52db44408ff100bda45be2">00357</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6469ec227ee3c0a9f8c9e31d16e80856" title="Multiply-add operation. Try to use the overloaded operators for vector instead, unless...">mul_add</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00358"></a>00358                  SCALARTYPE alpha,
<a name="l00359"></a>00359                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00360"></a>00360                  <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00361"></a>00361                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00362"></a>00362     {
<a name="l00363"></a>00363       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00364"></a>00364       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00365"></a>00365       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00366"></a>00366       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00367"></a>00367       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00368"></a>00368       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.setArgument(pos++, alpha);
<a name="l00369"></a>00369       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00370"></a>00370       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00371"></a>00371       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.setArgument(pos++, size);
<a name="l00372"></a>00372 
<a name="l00373"></a>00373       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00374"></a>00374         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00375"></a>00375                                                                                      <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00376"></a>00376       <span class="keywordflow">else</span>
<a name="l00377"></a>00377         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     <span class="comment">//vec1 += factor * vec2</span>
<a name="l00390"></a>00390 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00391"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a4911ae3ec8685a1f041e37c009c31892">00391</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a4911ae3ec8685a1f041e37c009c31892" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead...">inplace_mul_add</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00392"></a>00392                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00393"></a>00393                          <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00394"></a>00394                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00395"></a>00395     {
<a name="l00396"></a>00396       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00397"></a>00397       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00398"></a>00398       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00399"></a>00399       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00400"></a>00400       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00401"></a>00401       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_add</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00402"></a>00402       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_add</a>.setArgument(pos++, size);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00405"></a>00405         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00406"></a>00406                                                                                          <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00407"></a>00407       <span class="keywordflow">else</span>
<a name="l00408"></a>00408         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411 
<a name="l00421"></a>00421     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00422"></a><a class="code" href="namespaceviennacl_1_1linalg.html#adab8fb5aa2530e48c7ba7d2987aa4448">00422</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a4911ae3ec8685a1f041e37c009c31892" title="Inplace Multiply-add operation. Try to use the overloaded operators for vector instead...">inplace_mul_add</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00423"></a>00423                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00424"></a>00424                          SCALARTYPE alpha,
<a name="l00425"></a>00425                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00428"></a>00428       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00429"></a>00429       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00430"></a>00430       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_inplace_mul_add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00431"></a>00431       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_inplace_mul_add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00432"></a>00432       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_inplace_mul_add</a>.setArgument(pos++, alpha);
<a name="l00433"></a>00433       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_inplace_mul_add</a>.setArgument(pos++, size);
<a name="l00434"></a>00434 
<a name="l00435"></a>00435       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00436"></a>00436         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_inplace_mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00437"></a>00437                                                                                              <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00438"></a>00438       <span class="keywordflow">else</span>
<a name="l00439"></a>00439         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::cpu_inplace_mul_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441 
<a name="l00452"></a>00452     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00453"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a7ab4e344aa136d4221bc2f22c1431a03">00453</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a7ab4e344aa136d4221bc2f22c1431a03" title="Multiply-subtract operation. Try to use the overloaded operators for vector instead...">mul_sub</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00454"></a>00454                  <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00455"></a>00455                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00456"></a>00456                  <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; result,
<a name="l00457"></a>00457                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00458"></a>00458     {
<a name="l00459"></a>00459       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00460"></a>00460       result.<a class="code" href="classviennacl_1_1vector.html#ac0edeb416e183b65593e095c6d8c1d7d" title="Resizes the allocated memory for the vector. Pads the memory to be a multiple of...">resize</a>(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00461"></a>00461       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00462"></a>00462       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00463"></a>00463       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00464"></a>00464       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00465"></a>00465       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00466"></a>00466       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00467"></a>00467       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.setArgument(pos++, size);
<a name="l00468"></a>00468 
<a name="l00469"></a>00469       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00470"></a>00470         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00471"></a>00471                                                                                  <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00472"></a>00472       <span class="keywordflow">else</span>
<a name="l00473"></a>00473         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::mul_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 
<a name="l00486"></a>00486     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00487"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a247561256ec5f76d90f68cd4271749ea">00487</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a247561256ec5f76d90f68cd4271749ea" title="Inplace Multiply-subtract operation. Try to use the overloaded operators for vector...">inplace_mul_sub</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00488"></a>00488                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00489"></a>00489                          <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00490"></a>00490                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00493"></a>00493       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00494"></a>00494       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00495"></a>00495       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_sub</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00496"></a>00496       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_sub</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00497"></a>00497       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_sub</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00498"></a>00498       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_sub</a>.setArgument(pos++, size);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00501"></a>00501         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00502"></a>00502                                                                                          <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00503"></a>00503       <span class="keywordflow">else</span>
<a name="l00504"></a>00504         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_mul_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00505"></a>00505     }
<a name="l00506"></a>00506 
<a name="l00516"></a>00516     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00517"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a6e9cf3be544743cf0f79d8eea4d63b3b">00517</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a6e9cf3be544743cf0f79d8eea4d63b3b" title="Inplace divide-add operation. Try to use the overloaded operators for vector instead...">inplace_div_add</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00518"></a>00518                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00519"></a>00519                          <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00520"></a>00520                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00521"></a>00521     {
<a name="l00522"></a>00522       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00523"></a>00523       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00524"></a>00524       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00525"></a>00525       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_add</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00526"></a>00526       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_add</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00527"></a>00527       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_add</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00528"></a>00528       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_add</a>.setArgument(pos++, size);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00531"></a>00531         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00532"></a>00532                                                                                          <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00533"></a>00533       <span class="keywordflow">else</span>
<a name="l00534"></a>00534         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_add</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00535"></a>00535     }
<a name="l00536"></a>00536 
<a name="l00546"></a>00546     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00547"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a11f746acdd474fb7de5347e562fb92d6">00547</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a11f746acdd474fb7de5347e562fb92d6" title="Inplace divide-subtract operation. Try to use the overloaded operators for vector...">inplace_div_sub</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00548"></a>00548                          <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00549"></a>00549                          <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> <span class="keyword">const</span> &amp; alpha,
<a name="l00550"></a>00550                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00551"></a>00551     {
<a name="l00552"></a>00552       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00553"></a>00553       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00554"></a>00554       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00555"></a>00555       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_sub</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00556"></a>00556       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_sub</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00557"></a>00557       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_sub</a>.setArgument(pos++, alpha.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00558"></a>00558       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_sub</a>.setArgument(pos++, size);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00561"></a>00561         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00562"></a>00562                                                                                          <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00563"></a>00563       <span class="keywordflow">else</span>
<a name="l00564"></a>00564         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inplace_div_sub</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00565"></a>00565     }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <span class="comment">//implementation of inner product:</span>
<a name="l00572"></a>00572     <span class="comment">//namespace {</span>
<a name="l00580"></a>00580 <span class="comment"></span>      <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00581"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a507b21e23e973342ea180f6f0cfed447">00581</a>       <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#acec2a9ca55e33f98defcde0b2cf3db18" title="Computes the inner product of two vectors.">inner_prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00582"></a>00582                            <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00583"></a>00583                            <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> &amp; result,
<a name="l00584"></a>00584                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS <span class="comment">/* see forwards.h */</span>)
<a name="l00585"></a>00585       {
<a name="l00586"></a>00586         assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00587"></a>00587         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = std::min(vec1.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>(), vec2.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>());
<a name="l00588"></a>00588         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00589"></a>00589         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> group_num = 8;   <span class="comment">//Note: group_num MUST be a power of two!</span>
<a name="l00590"></a>00590         <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE&gt;</a> temp(group_num);
<a name="l00591"></a>00591         
<a name="l00592"></a>00592         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00593"></a>00593         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00594"></a>00594         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.setArgument(pos++, size);
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00596"></a>00596           <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00597"></a>00597         <span class="keywordflow">else</span>
<a name="l00598"></a>00598           <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*NUM_THREADS);
<a name="l00599"></a>00599         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.setArgument(pos++, temp.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00602"></a>00602           <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.start1D(group_num * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00603"></a>00603                                                                                       <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00604"></a>00604         <span class="keywordflow">else</span>
<a name="l00605"></a>00605           <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::inner_prod</a>.start1D(group_num * NUM_THREADS, NUM_THREADS);
<a name="l00606"></a>00606         
<a name="l00607"></a>00607         pos = 0;
<a name="l00608"></a>00608         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sum</a>.setArgument(pos++, temp.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00609"></a>00609         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sum</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00610"></a>00610         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sum</a>.setArgument(pos++, group_num);
<a name="l00611"></a>00611         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::sum</a>.start1D(group_num, group_num);
<a name="l00612"></a>00612       }
<a name="l00613"></a>00613     <span class="comment">//}</span>
<a name="l00614"></a>00614 
<a name="l00615"></a>00615     <span class="comment">//public interface of inner product</span>
<a name="l00623"></a>00623 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT1, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT2&gt;
<a name="l00624"></a>00624     <a class="code" href="classviennacl_1_1scalar__expression.html" title="A proxy for scalar expressions (e.g. from inner vector products).">viennacl::scalar_expression&lt; const viennacl::vector&lt;SCALARTYPE, ALIGNMENT1&gt;</a>, 
<a name="l00625"></a>00625                                  <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT2&gt;</a>,
<a name="l00626"></a>00626                                  viennacl::op_inner_prod &gt;
<a name="l00627"></a><a class="code" href="namespaceviennacl_1_1linalg.html#acec2a9ca55e33f98defcde0b2cf3db18">00627</a>     <a class="code" href="namespaceviennacl_1_1linalg.html#acec2a9ca55e33f98defcde0b2cf3db18" title="Computes the inner product of two vectors.">inner_prod_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT1&gt;</a> &amp; vec1,
<a name="l00628"></a>00628                     <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT2&gt;</a> &amp; vec2,
<a name="l00629"></a>00629                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS <span class="comment">/* declared in forwards.h */</span>)
<a name="l00630"></a>00630     {
<a name="l00631"></a>00631       <span class="keywordflow">return</span> <a class="code" href="classviennacl_1_1scalar__expression.html" title="A proxy for scalar expressions (e.g. from inner vector products).">viennacl::scalar_expression&lt; const viennacl::vector&lt;SCALARTYPE, ALIGNMENT1&gt;</a>, 
<a name="l00632"></a>00632                                           <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT2&gt;</a>,
<a name="l00633"></a>00633                                           viennacl::op_inner_prod &gt;(vec1, vec2);
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 
<a name="l00637"></a>00637     
<a name="l00644"></a>00644     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00645"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a773963ad0576dedd6ea9677a964d7eb6">00645</a>     SCALARTYPE <a class="code" href="namespaceviennacl_1_1linalg.html#a773963ad0576dedd6ea9677a964d7eb6" title="Computes the l^1-norm of a vector.">norm_1</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vcl_vec,
<a name="l00646"></a>00646                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00647"></a>00647     {
<a name="l00648"></a>00648       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> result;
<a name="l00649"></a>00649       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = vcl_vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>();
<a name="l00650"></a>00650       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00651"></a>00651       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.setArgument(pos++, vcl_vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00652"></a>00652       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.setArgument(pos++, size);
<a name="l00653"></a>00653       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00654"></a>00654         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00655"></a>00655       <span class="keywordflow">else</span>
<a name="l00656"></a>00656         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*NUM_THREADS);
<a name="l00657"></a>00657       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00658"></a>00658 
<a name="l00659"></a>00659       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00660"></a>00660         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00661"></a>00661                                                                                 <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00662"></a>00662       <span class="keywordflow">else</span>
<a name="l00663"></a>00663         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_1</a>.start1D(NUM_THREADS,NUM_THREADS);
<a name="l00664"></a>00664       
<a name="l00665"></a>00665       <span class="keywordflow">return</span> result;
<a name="l00666"></a>00666     }
<a name="l00667"></a>00667 
<a name="l00675"></a>00675     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00676"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a8cb58d3e096e8eefd750aee35249765e">00676</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a8cb58d3e096e8eefd750aee35249765e" title="Computes the l^2-norm of a vector - implementation.">norm_2_impl</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vcl_vec,
<a name="l00677"></a>00677                      <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> &amp; result,
<a name="l00678"></a>00678                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS <span class="comment">/* declared in forwards.h */</span>)
<a name="l00679"></a>00679     {
<a name="l00680"></a>00680       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = vcl_vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>();
<a name="l00681"></a>00681       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00682"></a>00682       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.setArgument(pos++, vcl_vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00683"></a>00683       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.setArgument(pos++, size);
<a name="l00684"></a>00684       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00685"></a>00685         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00686"></a>00686       <span class="keywordflow">else</span>
<a name="l00687"></a>00687         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*NUM_THREADS);
<a name="l00688"></a>00688       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00689"></a>00689 
<a name="l00690"></a>00690       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00691"></a>00691         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00692"></a>00692                                                                                 <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00693"></a>00693       <span class="keywordflow">else</span>
<a name="l00694"></a>00694         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_2</a>.start1D(NUM_THREADS, NUM_THREADS);
<a name="l00695"></a>00695     }
<a name="l00696"></a>00696 
<a name="l00703"></a>00703     <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00704"></a><a class="code" href="namespaceviennacl_1_1linalg.html#aed0642dda58cce7ebceffceb2bb1dc7c">00704</a>     SCALARTYPE <a class="code" href="namespaceviennacl_1_1linalg.html#aed0642dda58cce7ebceffceb2bb1dc7c" title="Computes the supremum-norm of a vector.">norm_inf</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vcl_vec,
<a name="l00705"></a>00705                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00706"></a>00706     {
<a name="l00707"></a>00707       <a class="code" href="classviennacl_1_1scalar.html" title="This class represents a single scalar value on the GPU and behaves mostly like a...">scalar&lt;SCALARTYPE&gt;</a> result;
<a name="l00708"></a>00708       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = vcl_vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>();
<a name="l00709"></a>00709       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00710"></a>00710       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.setArgument(pos++, vcl_vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00711"></a>00711       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.setArgument(pos++, size);
<a name="l00712"></a>00712       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00713"></a>00713         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00714"></a>00714       <span class="keywordflow">else</span>
<a name="l00715"></a>00715         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*NUM_THREADS);
<a name="l00716"></a>00716       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.setArgument(pos++, result.<a class="code" href="classviennacl_1_1scalar.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL handle.">handle</a>());
<a name="l00717"></a>00717 
<a name="l00718"></a>00718       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00719"></a>00719         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00720"></a>00720                                                                                   <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00721"></a>00721       <span class="keywordflow">else</span>
<a name="l00722"></a>00722         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::norm_inf</a>.start1D(NUM_THREADS, NUM_THREADS);
<a name="l00723"></a>00723       
<a name="l00724"></a>00724       <span class="keywordflow">return</span> result;
<a name="l00725"></a>00725     }
<a name="l00726"></a>00726 
<a name="l00727"></a>00727     <span class="comment">//This function should return a CPU scalar, otherwise statements like </span>
<a name="l00728"></a>00728     <span class="comment">// vcl_rhs[index_norm_inf(vcl_rhs)] </span>
<a name="l00729"></a>00729     <span class="comment">// are ambiguous</span>
<a name="l00736"></a>00736 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00737"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a3b084a55303d0df592ffd96ea591eb93">00737</a>     cl_uint <a class="code" href="namespaceviennacl_1_1linalg.html#a3b084a55303d0df592ffd96ea591eb93" title="Computes the index of the first entry that is equal to the supremum-norm in modulus...">index_norm_inf</a>(<span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vcl_vec,
<a name="l00738"></a>00738                            <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00739"></a>00739     {
<a name="l00740"></a>00740       <a class="code" href="classviennacl_1_1ocl_1_1handle.html">viennacl::ocl::handle&lt;cl_mem&gt;</a> h = <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().createMemory(CL_MEM_READ_WRITE, <span class="keyword">sizeof</span>(cl_uint));
<a name="l00741"></a>00741       
<a name="l00742"></a>00742       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = vcl_vec.<a class="code" href="classviennacl_1_1vector.html#ae799d7807e1fa709f0a81c77175ca7df" title="Returns the internal length of the vector, which is given by size() plus the extra...">internal_size</a>();
<a name="l00743"></a>00743       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00744"></a>00744       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setArgument(pos++, vcl_vec.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00745"></a>00745       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setArgument(pos++, size);
<a name="l00746"></a>00746       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00747"></a>00747       {
<a name="l00748"></a>00748         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00749"></a>00749         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(cl_uint)*<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00750"></a>00750       }
<a name="l00751"></a>00751       <span class="keywordflow">else</span>
<a name="l00752"></a>00752       {
<a name="l00753"></a>00753         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(SCALARTYPE)*NUM_THREADS);
<a name="l00754"></a>00754         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setLocalBuffer(pos++, <span class="keyword">sizeof</span>(cl_uint)*NUM_THREADS);
<a name="l00755"></a>00755       }
<a name="l00756"></a>00756         
<a name="l00757"></a>00757       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.setArgument(pos++, h);
<a name="l00758"></a>00758 
<a name="l00759"></a>00759       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00760"></a>00760         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00761"></a>00761                                                                                         <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00762"></a>00762       <span class="keywordflow">else</span>
<a name="l00763"></a>00763         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::index_norm_inf</a>.start1D(NUM_THREADS, NUM_THREADS);
<a name="l00764"></a>00764       
<a name="l00765"></a>00765       <span class="comment">//read value:</span>
<a name="l00766"></a>00766       cl_uint result;
<a name="l00767"></a>00767       cl_int err;
<a name="l00768"></a>00768       err = clEnqueueReadBuffer(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().queue(), h, CL_TRUE, 0, <span class="keyword">sizeof</span>(cl_uint), &amp;result, 0, NULL, NULL);
<a name="l00769"></a>00769       assert(err == CL_SUCCESS);
<a name="l00770"></a>00770       <a class="code" href="namespaceviennacl_1_1ocl.html#a4065dfa2dfe83d8d192ec7db06deb294" title="Blocks until all kernels on the device have finished.">viennacl::ocl::finish</a>();
<a name="l00771"></a>00771       <span class="keywordflow">return</span> result;
<a name="l00772"></a>00772     }
<a name="l00773"></a>00773     
<a name="l00774"></a>00774     <span class="comment">//TODO: Special case vec1 == vec2 allows improvement!!</span>
<a name="l00786"></a>00786 <span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> SCALARTYPE, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ALIGNMENT&gt;
<a name="l00787"></a><a class="code" href="namespaceviennacl_1_1linalg.html#a475332833e58b7d657544f3e40164f9a">00787</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceviennacl_1_1linalg.html#a475332833e58b7d657544f3e40164f9a" title="Computes a plane rotation of two vectors.">plane_rotation</a>(<a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec1,
<a name="l00788"></a>00788                         <span class="keyword">const</span> <a class="code" href="classviennacl_1_1vector.html" title="A vector class representing a linear memory sequence on the GPU. Inspired by boost::numeric::ublas::...">viennacl::vector&lt;SCALARTYPE, ALIGNMENT&gt;</a> &amp; vec2,
<a name="l00789"></a>00789                         SCALARTYPE alpha,
<a name="l00790"></a>00790                         SCALARTYPE beta,
<a name="l00791"></a>00791                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NUM_THREADS = 0)
<a name="l00792"></a>00792     {
<a name="l00793"></a>00793       assert(vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>() == vec2.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>());
<a name="l00794"></a>00794       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = vec1.<a class="code" href="classviennacl_1_1vector.html#aff09a36722db9359027ac40fad8deadf" title="Returns the length of the vector (cf. std::vector).">size</a>();
<a name="l00795"></a>00795       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
<a name="l00796"></a>00796       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.setArgument(pos++, vec1.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00797"></a>00797       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.setArgument(pos++, vec2.<a class="code" href="classviennacl_1_1vector.html#abe419a13116160fd12b66f47c5180e5c" title="Returns the OpenCL memory viennacl::ocl::handle. Typically used for launching compute...">handle</a>());
<a name="l00798"></a>00798       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.setArgument(pos++, alpha);
<a name="l00799"></a>00799       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.setArgument(pos++, beta);
<a name="l00800"></a>00800       <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.setArgument(pos++, size);
<a name="l00801"></a>00801 
<a name="l00802"></a>00802       <span class="keywordflow">if</span> (NUM_THREADS == 0)
<a name="l00803"></a>00803         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group(),
<a name="l00804"></a>00804                                                                                         <a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_items_per_group());
<a name="l00805"></a>00805       <span class="keywordflow">else</span>
<a name="l00806"></a>00806         <a class="code" href="structviennacl_1_1linalg_1_1kernels_1_1vector.html">viennacl::linalg::kernels::vector&lt;SCALARTYPE,ALIGNMENT&gt;::plane_rotation</a>.start1D(<a class="code" href="namespaceviennacl_1_1ocl.html#af2e084ced53a661782ef64b64a5e0b36" title="Singleton pattern. Returns a compute device.">viennacl::ocl::device</a>().work_groups() * NUM_THREADS, NUM_THREADS);
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808     
<a name="l00809"></a>00809   } <span class="comment">//namespace linalg</span>
<a name="l00810"></a>00810 } <span class="comment">//namespace viennacl</span>
<a name="l00811"></a>00811 
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="preprocessor">#endif</span>
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jul 8 13:48:31 2010 for ViennaCL - The Vienna Computing Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
