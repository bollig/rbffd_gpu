\chapter{Algorithms}

This chapter gives an overview over the available algorithms in {\ViennaCL}.
The focus of {\ViennaCL} is on iterative solvers, for which {\ViennaCL} provides a generic implementation that allows the use of the same code on the CPU (either using \ublas, Eigen, MTL4 or \OpenCL) and on the GPU (using \OpenCL).

\section{Direct Solvers} \label{sec:direct-solvers}
{\ViennaCLversion} provides triangular solvers and LU factorization without pivoting for the solution of dense linear systems. The interface is similar to that of {\ublas}

\begin{lstlisting}
  using namespace viennacl::linalg;  //to keep solver calls short
  viennacl::matrix<float>  vcl_matrix;
  viennacl::vector<float>  vcl_rhs;
  viennacl::vector<float>  vcl_result;

  /* Set up matrix and vectors here */

  //solution of an upper triangular system:
  vcl_result = solve(vcl_matrix, vcl_rhs, upper_tag());
  //solution of a lower triangular system:
  vcl_result = solve(vcl_matrix, vcl_rhs, lower_tag());

  //solution of a full system right into the load vector vcl_rhs:
  lu_factorize(vcl_matrix);
  lu_substitute(vcl_matrix, vcl_rhs);    
\end{lstlisting}
In {\ViennaCLminorversion} there is no pivoting included in the LU factorization
process, hence the computation may break down or yield results with poor
accuracy. However, for certain classes of matrices (like diagonal dominant
matrices) good results can be obtained without pivoting.

It is also possible to solve for multiple right hand sides:
\begin{lstlisting}
  using namespace viennacl::linalg;  //to keep solver calls short
  viennacl::matrix<float>  vcl_matrix;
  viennacl::matrix<float>  vcl_rhs_matrix;
  viennacl::matrix<float>  vcl_result;

  /* Set up matrices here */

  //solution of an upper triangular system:
  vcl_result = solve(vcl_matrix, vcl_rhs_matrix, upper_tag());

  //solution of a lower triangular system:
  vcl_result = solve(vcl_matrix, vcl_rhs_matrix, lower_tag());
\end{lstlisting}


\section{Iterative Solvers} \label{sec:iterative-solvers}
{\ViennaCL} provides different iterative solvers for various classes of
matrices, listed in Tab.~\ref{tab:linear-solvers}. Unlike direct solvers, the
convergence of iterative solvers relies on certain properties of the system
matrix. Keep in mind that an iterative solver may fail to converge, especially
if the matrix is ill conditioned or a wrong solver is chosen. 

\TIP{For full details on linear solver calls, refer to the reference
documentation located in \texttt{doc/doxygen/} and to the tutorials}

\TIP{The iterative solvers can directly be used for {\ublas}, Eigen and MTL4 objects! Please have a look at Chap.~\ref{chap:other-libs} and the respective tutorials in the examples/tutorials/ folder.}

\NOTE{In {\ViennaCLversion}, GMRES using ATI GPUs yields wrong results due to a bug in Stream SDK v2.1. Consider using newer versions of the Stream SDK.}

\begin{lstlisting}
viennacl::compressed_matrix<float>  vcl_matrix;
viennacl::vector<float>  vcl_rhs;
viennacl::vector<float>  vcl_result;

/* Set up matrix and vectors here */

//solution using conjugate gradient solver:
vcl_result = viennacl::linalg::solve(vcl_matrix,
				     vcl_rhs,
				     viennacl::linalg::cg_tag());

//solution using BiCGStab solver:
vcl_result = viennacl::linalg::solve(vcl_matrix,
				     vcl_rhs,
				     viennacl::linalg::bicgstab_tag());

//solution using GMRES solver:
vcl_result = viennacl::linalg::solve(vcl_matrix,
				     vcl_rhs,
				     viennacl::linalg::gmres_tag());
\end{lstlisting}

\begin{table}[tb]
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{4cm}|p{3cm}|p{7.5cm}}
Method & Matrix class & ViennaCL\\
\hline
Conjugate Gradient (CG) & symmetric positive definite & \texttt{y = solve(A, x, cg\_tag());} \\
Stabilized Bi-CG (BiCGStab) & non-symmetric & \texttt{y = solve(A, x, bicgstab\_tag());} \\
Generalized Minimum Residual (GMRES) & general & \texttt{y = solve(A, x, gmres\_tag());} \\
\hline
\end{tabular}
\caption{Linear solver routines in {\ViennaCL} for the computation of $y$ in the expression $Ay = x$ with given $A$, $x$.}
\label{tab:linear-solvers}
\end{center}
\end{table}

Customized error tolerances can be set in the solver tags. The convention is
that solver tags take the relative error tolerance as first argument and the
maximum number of iteration steps as second argument. Furthermore, after the
solver run the number of iterations and the estimated error can be obtained from
the solver tags as follows:
\begin{lstlisting}
// conjugate gradient solver with tolerance 1e10
// and at most 100 iterations:
viennacl::linalg::cg_tag custom_cg(1e-10, 100);
vcl_result = viennacl::linalg::solve(vcl_matrix, vcl_rhs, custom_cg);
//print number of iterations taken and estimated error:
std::cout << "No. of iters: " << custom_cg.iters() << std::endl;
std::cout << "Est. error: " << custom_cg.error() << std::endl;
\end{lstlisting}
The BiCGStab solver tag can be customized in exactly the same way. The GMRES
solver tag takes as third argument the dimension of the Krylov space. Thus, a
tag for GMRES(30) with tolerance $1\mathrm{E}\!-\!10$ and at most $100$ total
iterations
(hence, up to three restarts) can be set up by 
\begin{lstlisting}
viennacl::linalg::gmres_tag custom_gmres(1e-10, 100, 30);
\end{lstlisting}

\section{Preconditioners}
{\ViennaCL} ships with a generic implementation of an incomplete LU
factorization preconditioner with threshold (ILUT), a Jacobi preconditioner and
a row-scaling preconditioner. The incomplete factorization for ILUT is computed
on a single CPU core due to its sequential nature, so one must not expect large
performance gains if most time is spent on preconditioning. More
preconditioners are in preparation and any contributions are very welcome.

\TIP{The preconditioner also works for {\ublas} types!}

\begin{lstlisting}
using viennacl::linalg::ilut_precond;
using viennacl::compressed_matrix;

typedef compressed_matrix<float>   SparseMatrix;
SparseMatrix  vcl_matrix;
viennacl::vector<float>  vcl_rhs;
viennacl::vector<float>  vcl_result;

/* Set up matrix and vectors here */

//compute ILUT preconditioner:
ilut_precond< SparseMatrix > vcl_ilut(vcl_matrix,
                                      viennacl::linalg::ilut_tag());
//compute Jacobi preconditioner:
jacobi_precond< SparseMatrix > vcl_jacobi(vcl_matrix,
                                          viennacl::linalg::jacobi_tag());
//compute ILUT preconditioner:
row_scaling< SparseMatrix > vcl_row_scaling(vcl_matrix,
                                      viennacl::linalg::row_scaling_tag());

//solve (e.g. using conjugate gradient solver)
vcl_result = viennacl::linalg::solve(vcl_matrix,
                                     vcl_rhs,
                                     viennacl::linalg::cg_tag(),
                                     vcl_ilut);   //preconditioner here
\end{lstlisting}

\begin{table}[tb]
\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{3cm}|p{4cm}|p{7cm}}
Method & Brief description & Parameters\\
\hline
ILUT & incomplete LU factorization & First parameter: Maximum number of entries
per row. Second parameter: Drop tolerance. \\
Jacobi & Divide each row in $A$ by its diagonal entry & none \\
Row Scaling & Divide each row in $A$ by its norm & First parameter specifies
the norm (1: $l^1$-norm, 2: $l^2$-norm)\\
\hline
\end{tabular}
\caption{Preconditioners for iterative solvers in {\ViennaCL}.}
\label{tab:preconditioners}
\end{center}
\end{table}
